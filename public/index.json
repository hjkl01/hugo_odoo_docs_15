[
{
	"uri": "/odoo/readme/",
	"title": "Odoo开发手册",
	"tags": [],
	"description": "",
	"content": "Odoo 15开发手册目录 第一章 使用开发者模式快速入门 Odoo 15 第二章 Odoo 15开发之开发环境准备 第三章 Odoo 15开发之创建第一个 Odoo 应用 第四章 Odoo 15开发之模块继承 第五章 Odoo 15开发之导入、导出以及模块数据 第六章 Odoo 15开发之模型 - 结构化应用数据 第七章 Odoo 15开发之记录集 - 使用模型数据 第八章 Odoo 15开发之业务逻辑 - 业务流程的支持 第九章 Odoo 15开发之外部 API - 集成第三方系统 代码地址：Source Code\nOdoo 12开发手册目录 第一章 使用开发者模式快速入门 Odoo 12\n第二章 Odoo 12开发之开发环境准备\n第三章 Odoo 12 开发之创建第一个 Odoo 应用\n第四章 Odoo 12 开发之模块继承\n第五章 Odoo 12开发之导入、导出以及模块数据\n第六章 Odoo 12开发之模型 - 结构化应用数据\n第七章 Odoo 12开发之记录集 - 使用模型数据\n第八章 Odoo 12开发之业务逻辑 - 业务流程的支持\n第九章 Odoo 12开发之外部 API - 集成第三方系统\n第十章 Odoo 12开发之后台视图 - 设计用户界面\n第十一章 Odoo 12开发之看板视图和用户端 QWeb\n第十二章 Odoo 12开发之报表和服务端 QWeb\n第十三章 Odoo 12开发之创建网站前端功能\n第十四章 Odoo 12开发之部署和维护生产实例\n代码地址：Source Code\n"
},
{
	"uri": "/odoo/1/",
	"title": "第一章 使用开发者模式快速入门 Odoo 15",
	"tags": [],
	"description": "",
	"content": "Odoo提供了一个快速应用开发框架，尤其适合构建商业应用。这类应用通常用于保存业务记录和工作流。Odoo 不仅简化了这类应用的构建，还提供了看板、日历、图表等视图的丰富组件，用于创建难以抗拒的用户界面。\n本章我们直接进入实操，通过web 界面进行编码一探Odoo 的内部，这甚至都不需要配置本地开发环境。这样会让我们直观地感受 Odoo 应用所涉及到的组件。同时，我们还会了解一些查看已有应用及快速构建原型的基本工具。\n本文主要内容有：\nto-do (任务清单)应用 掌握 Odoo 的基础结构 使用 Odoo SaaS 测试库 在服务器上安装 Odoo 激活开发者模式 对模型添加自定义字段 新建模型 创建菜单项及动作 配置访问控制权限 创建视图 学习完本章，读者会熟悉 Odoo 自定义和开发的主要组成部分。\n技术准备 学习本章至少要求有一个现代浏览器，如 Firefox 或 Chrome。有浏览器并且可以联网，就可以通过 Odoo SaaS测试库学习本章，无需进行本地安装。\n当然读者也可以使用本地安装的 Odoo 实例。可以参见在服务器上安装 Odoo一节，其中讲解了 Windows、Ubuntu 和红帽企业版 Linux(RHEL)上安装预打包版本。此外，还可以使用 Docker 安装。\n引入 to-do 清单应用 本章中我们会使用一个示例项目来演示所讲解的概念。这个项目就是一个简单的 to-do清单 Odoo应用。\n使用这个应用我们可以新增清单，然后标记完成。比如可在项目中添加买鸡蛋，然后在购买后勾选已完成。并且To-do 清单应仅对用户自己可见，因而当前用户仅能获取自己的 to-do 列表。为了增加点趣味性，我们添加了一些复杂功能，允许 to-do清单包含一组和任务相关的用户，即工作小组。\n就该应用我们应考虑以下几层：\n数据层：通过模型实现 业务逻辑层：通过 Pyhon自动化编码实现 展示层：通过视图实现 对于数据层，我们需要一个 To-do 清单模型，我们还将利用内置的 Contact(也称之为 Partner)模型来支持工作组的功能。当然还要记得在新的模型中配置访问权限。\n业务逻辑层中我们使用框架处理增删改查(CRUD)基本操作。本例中我们无需使用额外的自动化支持。我们需要在开发者模块中使用 Python 代码来使用自动化功能。我们暂不需要在开发的模板中使用，但可以在 Technical 菜单下的 Automated Actions 工具来通过 UI 界面实现这种业务逻辑。在本章后面的例子中会进行使用。\n最后在展示层中我们将为应用添加菜单项，以及 to-do 模型的视图。业务应用的基本视图是用于查看已有记录的列表视图、深入查看记录详情的表单视图。为增强易用性，我们还可以在列表视图的搜索框中预置过滤项。搜索选项通过搜索视图组件进行实现。\n以下是创建 to-do 列表应用的步骤\n新建 to-do 清单模型 创建菜单项并让其对用户可见 配置访问控制权限 为 to-do 清单创建列表和表单视图 新增的 to-do 清单模型包含如下字段\nDescription: 字符 类型 Is Done?标记：布尔型 应用的具体功能包含团队功能：即可添加执行同一任务的一组用户。因此需要一个表示用户的模型。Odoo 自带就有Contact模型( 技术名称为res.partner)，可用于存储个人、公司和地址。\n任务清单模型应当包含一个工作团队字段，可用于选择一组用户。我们希望仅有指定的人可被选择加入工作团队。因此我们需要修改 Contact 模型添加Is Work Team?标记。仅带有此标记的用户可添加至工作团队。\n为实现工作团队的功能，我们需要向Contact 模型和表单视图添加一个字段。在进入实施之前，我们先讨论一些与 Odoo 框架相关的功能，然后学习如何准备要使用的环境。\n理解 Odoo 的基本概念 对一初学 Odoo 的人可能有些概念不是那么一目了然。我们在学习之前先进行掌握。\n有关 Odoo 和 Odoo 社区 Odoo 是一个是 Fabien 在比利时所创建的Odoo SA 公司所发布的软件产品。Odoo 软件产品是由公司主导的，也就是说路线图及开发都由 Odoo SA 紧紧控制在手里。但同时又遵循开源的条例，欢迎社区贡献代码。\nOdoo 软件采取开源内核的商业模式，也就是说部分代码是开源的、部分是自有产权。基于这一模式，Odoo 发布了两个版本。\n社区版（CE）对外公开、开源，使用 LGPL 开源证书。\n企业版（EE）仅对官方合作伙伴及持有专有证书的顾客开放，采取闭源代码。\nOdoo EE是 Odoo CE 内核上层的一堆模块，提供一些可诱使用户升级的高级功能。Odoo EE的收入为Odoo CE及Odoo EE的开发提供资金来源。Odoo创始人及 CEO Fabien Pinckaers 反复承诺会将80%的代码放到社区版里开源，另20%放到自有的企业版中。\n任何开源项目的最大资源都是围绕其的社区。Odoo 有很多活跃的开源贡献者。对于 Odoo 这个产品，社区贡献了功能反馈、翻译、安全问题报告、bug 修复并且偶尔会对内核产品进行一些技术改进。Odoo CE 的地址为https://github.com/odoo/odoo。\n除了 Odoo 的内核产品外，社区还发布一些新功能模块。很多 Odoo 社区内的个人及公司将他们的 Git 仓库以开源证书向公众开放。他们也会在 Odoo 的官方商店 Odoo Apps 上发布应用。应用商店中可发布免费及付费模块。\nOdoo 的内核项目中不会添加这些社区模块，因此社区模块以分散的形式开发，没有共同的标准及品控。Odoo 社区联盟（OCA）的成立就是为了解决这一问题。它纳入了这些社区贡献的模块，并提供了通用代码标准、指南、品控及工作流工具。OCA 的代码仓库位于https://github.com/OCA，可以在https://odoo-community.org/shop查看这些发布的模块。\nOdoo 产品的版本 在编写本书时，Odoo 的最新稳定版是 Odoo 15，在 GitHub 上的分支为15.0。这是在全书中使用的版本。Odoo 的大版本按年发布，每年10月在 Odoo 体验大会上进行发布。\n官方支持最新的三个稳定版。发布版本15后，对13和14版本仍提供支持，但版本12就不再进行官方支持了。也就是说不再进行漏洞及安全问题修复了。\nOdoo 的大版本之间数据库是不兼容的。如果在 Odoo 15的服务端运行此前大版本中创建的数据，不会跑通。要在更新的 Odoo 版本中使用老数据库需要进行颇为费力的迁移。\n对于插件模块也是如此。通常在一个大版本中开发的 Odoo 插件在另一个大版本中无法运行。在网上下载社区模块时，请注意是否支持你所使用的 Odoo 版本。\n大版本发布（如15.0）通常会有比较频繁的升级，这大部分都是漏洞修复而非新功能的开发。这些升级确保 API 稳定，即模型数据结构和视图元素标识符保持稳定。这很重要，因为这样就不会因为上游内核模块做出不兼容修改而导致自定义模块崩溃。\nOdoo 在线 SaaS 版本可能会使用中间版，有时也称为 SaaS 版。它们也是官方支持的。当前支持的版本列表可见于https://www.odoo.com/documentation/user，在 Support 页面的 Practical Information 中。\nmaster 分支的版本会形成下一个大版本的更新，但在发布前其 API 并不稳定，不应使用它构建自定义模块。那会好比在流沙中前行，无法知道何时会出现导致自定义模块崩溃的修改。请收下这个警告。\nOdoo 的架构 了解Odoo 遵循多层架构以及我们使用的每种组件的角色会很有帮助。因此我们来学习下 Odoo 应用的架构并通过将其解构为多个组件层来帮助我们进行应用的开发。\nOdoo 应用可以解构为三层：数据层、逻辑层和展示层:\n图1.1：Odoo 应用分层\n数据层是最底端一层，负责数据存储和持久化，Odoo 借助 PostgreSQL服务端来实现。Odoo 出于设计考虑仅支持 PostgreSQL 数据库。文档附件、图片一类的二进制文件通常存储在一个称为 filestore（目录） 的文件系统中。\n小贴士： 也就是说 Odoo 实例的完整备份需包含数据库导出文件和 filestore 的拷贝。\n我们很少使用 SQL 直接与数据库引擎进行交互 ，但在特定场景可能会需要用到。\nOdoo 依赖于对象关系映射（ORM）作为应用和数据库之间的接口。ORM 提供插件模块与数据交互的应用程序接口（API）。我们使用ORM模型实现数据层。例如，用于客户或供应商数据的Partner数据实体，以模型进行表示。\n通常底层数据库应仅由这一层访问，因为它确保了安全权限控制和数据一致性。ORM 模型基于支持多个交互方法的Python对象类，如增删改查（CRUD）基本操作。具体来说CRUD操作通过create() 、search() 、write() 和unlink() 模型方法实现。\n逻辑层负责与数据层的所有交互，并由 Odoo 服务端处理。可扩展CRUD操作来实现具体的业务逻辑。例如，create() 和 write() 方法可实现默认值或其它的自动操作。可添加其它方法来强制验证规则或自动计算字段值。\n展示层用于展示数据并与用户交互，通过软件的客户端实现，负责用户交互。客户端软件使用远程过程调用（RPC）运行 ORM 引擎及业务逻辑的Odoo 服务。ORM API调用发往Odoo服务端处理读、写、验证或执行其它操作。然后将结果返回客户端做进一步处理。\nOdoo自带一个网页客户端。网页客户端支持所有业务应用所需的功能，如登录会话、导航菜单、数据列表和表单。\n有一个网站框架用于外部的开发前台。它提供一些 CMS 功能，可用于创建静态和动态网页。网站框架使用controller组件来实现具体展示逻辑的代码，与模型内部逻辑分离。页面使用QWeb作为其渲染引擎。那是一些包含HTML标记外加循环、条件或调用其它模板的特有XML QWeb标签。\nOdoo 服务端 API 非常开放，包含所有的服务端功能。官方Web 客户端使用的 API 与其它应用的 API 并无不同。因此，其它的客户端实现均可做到，并且可以在任何平台上使用任意编程语言进行实现。可以创建桌面和移动端应用来提供不同用户界面，这充分利用了 Odoo 为业务逻辑和数据持久性而生的数据和逻辑层。\n使用 Odoo SaaS试用数据库 使用Odoo最简单的方式是使用Odoo的软件即服务(SaaS)试用数据库。这样无需进行任何安装，仅需进入官网https://odoo.com/点击Try it free按钮。\n会要求选择一个应用来在新数据库中进行安装。在本章的学习中，你可以选择任何应用，读者大可自由选择。如果你实在拿不定主意，不妨使用CRM应用。\n图1.2 – Odoo SaaS试用数据库的初始应用选取\n新的SaaS数据库使用最新的Odoo SaaS版本，它是基于最近的稳定版Odoo EE，同时带有自己的小版本号。因此与Odoo最新稳定的企业版版本号并不致。\n免费数据库有效期为15天。在写本书时，Odoo SaaS版本还提供一个免费方案让你可以在到期后继续使用（要求安装一个以上的应用）。\n在工作站上安装 Odoo 使用Odoo SaaS测试库是本章的默认选项。在本书之后的章节中，我们会使用本地Odoo安装。在第二章 Odoo 15开发之开发环境准备中，会进行相应的引导。\n值得一提的是Odoo还有一些预打包的安装包。我们这里简要地进行说明，以供读者了解：\n在你的操作系统上使用预打包安装程序安装Odoo：如果是Odoo新手又希望快速获得一个本地环境的话这是一个很好的选择。预打包安装软件支持如下操作系统：Windows (EXE安装软件); Debian/Ubuntu (DEB包)和CentOS/RHEL (RPM包)。 使用 Docker 容器安装 Odoo：如果用过 Docker 并在操作系统中安装了 Docker 这会是一个好选项。如果不太了解 Docker，可以采用上一种方法，以名学习 Docker影响到正课（学习 Odoo 开发）。 可通过https://download.odoo.com下载这些安装包。包含所有稳定版的Odoo，以及与最新开发版本相对应的 master 分支。我们会在下面的小节讲解这些选项。\n有关安装Odoo的更多知识，请参见官方文档。\n使用一键安装包在 Windows 上安装 Odoo为Windows提供了一个一键安装包，包含运行Odoo所需的所有：Python 3运行时环境、PostgreSQL数据库以及安装了依赖的Odoo服务端。\n可通过https://download.odoo.com下载安装包。在首页选择相应的版本：15 (stable) - Community Edition。每日构建包位于15.0/nightly/windows，最新包在页面底部。\n安装包非常易于使用。在安装结束时Odoo会自动启动。\n还会创建开机启动的Windows服务用于自动启动Odoo和PostgreSQL。在通过其它如源码方式安装时应注意这一点，在Windows安装包安装后会占用8069端口，这样其它安装就无法使用该端口了。\n使用预打包安装包在 Linux 上安装 Odoo下载站点(https://download.odoo.com) 还提供对Debian系(含Ubuntu)和RHEL/CentOS的官方包下载仓库。\n在首页上对于有对应系统安装包(apt 或 yum) 的安装指南。请确保将命令行示例中的Odoo版本修改为对应的版本，如15.0。\n# Debian 系 wget -O - https://nightly.odoo.com/odoo.key | apt-key add - echo \u0026#34;deb http://nightly.odoo.com/15.0/nightly/deb/ ./\u0026#34; \u0026gt;\u0026gt; /etc/apt/sources.list apt-get update \u0026amp;\u0026amp; apt-get install odoo # RHEL/CentOS yum-config-manager --add-repo=https://nightly.odoo.com/15.0/nightly/rpm/odoo.repo yum update \u0026amp;\u0026amp; yum install odoo 在Linux系统中安装Odoo 15之前，应当先安装好PostgreSQL数据库。这样Odoo就可以创建并配置其用户了。\n使用 Docker 容器安装 Odoo Docker为在运行应用提供了一个便利的多平台解决方案。可用于在Windows、Linux和macOS上运行应用。相比于传统的虚拟机容器技术使用简单、资源利用率高。\n首先需要在操作系统中安装Docker。Docker Desktop是社区版的，免费使用。可通过https://www.docker.com进行下载。安装最新版本 Docker时最好参照该网站。Docker依赖于虚拟硬件技术，请确保在基本输出输出系统 (BIOS)中启用该功能。\n有关安装和运行Docker的通用指南请见https://docs.docker.com/engine/install。\n例如对于Ubuntu系统，详细地的安装说明位于https://docs.docker.com/engine/install/ubuntu/。\n关于安装后的重要步骤，如以非root用户运行Docker，请参见https://docs.docker.com/engine/install/linux-postinstall/。\nWindows系统中的Docker桌面需要使用Hyper-V，仅在Windows 10的企业版和教育版中才有。最新安装详情请见https://docs.docker.com/desktop/windows/install/。\nMac上的Docker桌面需要使用macOS 10.14或更新版本。最新的详情请见https://docs.docker.com/desktop/mac/install/。\n注： 在Windows和macOS版本中曾经可使用Docker Toolbox作为替代，但这一发行版已被废弃。Docker Toolbox打包了VirtualBox，提供了预配置的shell用于在命令行操作Docker容器。参见https://docs.docker.com/toolbox/获取更多详情。\nOdoo 在Docker Hub上的官方Docker镜像位于https://hub.docker.com/_/odoo。这里我们可以看到使用Odoo Docker镜像的基本指南。运行Odoo时会创建两个Docker容器：一个用于PostgreSQL数据库，另一个用于Odoo服务端。\n安装及操作均通过命令行实现。通过如下命令启动PostgreSQL的Docker容器：\n$ docker run -d -e POSTGRES_USER=odoo -e POSTGRES_PASSWORD=odoo -e POSTGRES_DB=postgres --name db postgres:13 这样会通过互联网下载最新的PostgreSQL镜像并启动一个以后台任务运行的容器。\n接着，安装、运行Odoo服务端容器，联结刚刚启动的PostgreSQL容器，对外暴露端口8069：\n$ docker run -t -p 8069:8069 --name odoo --link db:db odoo:15.0 -d odoo15 此时便可在终端窗口看到实时的 Odoo 服务器日志，在浏览器中访问http://localhost:8069即可打开 Odoo 实例。\n注： 如果8069端口被占用了，则Odoo 服务启动会失败。比如端口可能被正在运行的 Odoo 服务端所占用。此时我们需要查找停止占用该端口的服务（比如查找运行中的服务列表）或者使用-p 参数指定其它端口来运行 Odoo。如修改为8070端口(-p 8070:8069)。还可通过-d \u0026lt;dbname\u0026gt; 参数修改实例所需使用的数据库名称。\n以下Docker 的几个基本命令会有助于管理容器：\ndocker stop \u0026lt;name\u0026gt;：停止容器 docker start \u0026lt;name\u0026gt;：启动容器 docker start -a \u0026lt;name\u0026gt;：启动容器并附带输出，如在命令终端中输出的服务器日志 docker attach \u0026lt;name\u0026gt;：重新添加容器输出至当前终端窗口 docker ps：列出当前 Docker 容器 以上就是操作 Docker 容器的基本命令。\n万一在运行容器时出现问题，可以执行如下命令重新来过：\n$ docker container stop db $ docker container rm db $ docker container stop odoo $ docker container rm odoo Docker 技术的应用非常广泛，学习起来也很有趣。Docker官网上有不错的文档可供学习，可先通过https://www.docker.com/get-started开始学习。\n启用开发者工具 要实现我们的项目，这里需要用到Odoo开发者工具。通过开启开发者模式即可使用这些工具。\n开发者模式对于查看和修改当前Odoo的配置很有用。可直接通过用户界面自定义Odoo应用并快速添加、修改功能。可用它做些小修改，比如创建带有自己菜单、视图及底层数据模型的应用。\n注意：开发者暴露了Odoo应用的大量内部配置，可对其进行修改。但能力越大，责任真大，所以应谨慎修改。在线上系统中请保持在拷贝数据库中进行这些修改。如果出现问题，还有机会通过升级所影响的应用（或是base模块）在解决问题，但不是100%保证。\n这种通过开发者工具的自定义开发相对于在后续章节讲到的编程工具而言存在其局限性。如它无法添加或扩展默认的 ORM 方法。\n借助于开者模式（通过Odoo Studio应用）的自定义开发不易于集成到结构性开发流，如版本控制、自动化测试及质量测试、预发布和生产环境改进的工作流。\n本文我们主要使用开发者模式来介绍在 Odoo 框架中应用配置数据是如何进行组织的，以及如何在开发者模式下完成简单的自定义或原型解决方案。\n开启开发者模式 从Odoo 13开始，通过Settings \u0026gt; General Settings页面开启开发者模式。在接近底部的地方会发现一个Developer Tools的版块。在这里可以找到Activate the developer mode链接。点击该链接就会在当前浏览器窗口中开启开发者模式功能：\n图1.3 – Settings页面中的开发者工具选项\n注意需要至少安装了一个应用后才会出现General Settings菜单。如果找不到该菜单，请安装一个应用，如Contacts或CRM等任一应用。\nOdoo 13中的变化：Odoo 10到12版本，开发者模式都是通过Settings \u0026gt; Dashboard页面右下角处开启。而对于Odoo 9及之前的版本，开发者模式是在网页右上角中的User菜单的About对话窗口中激活，\n启用了开发者模式后，会出现如下的菜单：\n菜单栏中，右上角聊天和活动图标左侧会新增一个开发者工具的小虫子图标。 在Settings应用中，顶栏中会出现Technical和Translations菜单项。 图1.4 – 开启了开发者模式后的设置页面\n开启开发者模式后在网页视图上会出现一些额外信息，即在将鼠标悬停在字段上，会有一个提示框显示相关的技术信息。\n注： 我们也可以通过修改当前的 URL 来进入开发者模式，这样就无需进入 Settings 页面。仅需修改链接中的\u0026hellip;/web#\u0026hellip;为\u0026hellip;/web?debug=1#\u0026hellip;。比如修改http:///localhost:8069/web#home为http://localhost_8069/web?debug#home。\n使用带资源的开发者模式 为了加载更快，网页客户端对JavaScript和CSS资源进行了最小化压缩。这会给调试带来困难。\nActivate the developer mode (with assets) 选项会阻止这种最小化压缩，让每个资源单独加载。对于在网页客户端中进行调试这很有用处，但也会因开销开让页面的浏览变慢。\n小贴士：Firefox和Chrome浏览器都有插件可提供一个按钮，方便开启及禁用Odoo中的开发者模式。请在插件商店中搜索Odoo Debug。\n说说 Odoo Studio 值得一提的是Odoo企业版和SaaS版都提供了Odoo Studio应用，这是一个交互的应用构造器。我们不会使用到它，因为本书的示例均使用 Odoo 社区版，社区版中没有这一功能。\nOdoo Studio提供了一套用户友好的界面，用于完成本章中讲解的交互式开发功能及一些其它功能，比如可以将自定义功能导出到文件中。\n这里我们会使用开发者模式（有时也被称为debug模型）及Technical菜单，这两者在Odoo所有的版本中都可用。Odoo Studio中所构建的大部分功能通过这两个工具也可完成，不过对于非开发者来说确实也难些。\n对模型添加自定义字段 向已有表单添加自定义字段是一种很觉的自定义，无需创建自定义模块通过用户界面就可实现。\n我们的to-do清单应用中，希望选择一组人共同操作to-do清单项。可以在他们的partner表单设置一个标记来进行指定。我们将通过向Contact模型添加一个Is Work Team? 标记来实现。\nContact模型是Odoo内核自带的，即使未安装任何应用也可以使用。但这样就没有菜单选项来访问它了。\n如果在主菜单中没有Contacts应用的话，请进行安装。打开顶级菜单的Apps项，搜索该应用进行安装。\n图1.5 – Apps菜单中添加Contacts应用\n安装完成后即可在顶级菜单中找到 Contacts 项。\n对模型添加字段 我们先在数据模型中添加自定义字段。\n点击Contacts应用菜单项查看联系人主视图。点击开发者工具小虫图标并选择View Fields选项。\nODOO 12中的变化\n开发者菜单中的View Fields选项是在Odoo 12中新增的，可通过Settings \u0026gt;Technical \u0026gt;Database Structure菜单添加、编辑字段。可以使用Models或Fields选项。\n此时会看到当前模型Contact所有已有字段的列表。点击左上角的Create按钮、填入新字段的以下详情：\nField Name: x_is_work_team Field Label: Is Work Team? Field Type: boolean 图1.6 – 创建Is Work Team?字段\n字段名（Field Name）必须以 x_开头。这是通过开发者工具创建模型和字段强制要求的（否则保存时会提示Custom fields must have a name that starts with \u0026lsquo;x_\u0026rsquo; !）。通过插件模块的自定义开发没有这一限制。\n点击Save，就会在字段列表中新增这个字段。默认，列表视图显示80条记录，因此需要点击右上角的右键浏览下一页查看新字段，或者也可以编辑箭头旁的记录数。\n对表单视图添加字段 现在Contact模型中就有一个新字段（前面也提到过也称为Partner模型）。但在用户界面中仍不可见。需要为其给定一个视图。我们会添加一个联系人表单视图。\n回到Contacts的列表并打开表单视图，可通过选择已有的联系人或点击Create按钮。\n现在需要决定在表单的哪里添加这个字段。例如，我们应在Tags标签后进行添加。这会是使用的扩展点。\n将鼠标悬浮在字段上，会显示其技术信息，如下图所示：\n图1.7 – 带有技术详情提示信息的Tags字段\n接下，我们需要找到该字段的技术名称。可通过将鼠标悬停在字段标签之上。这样我们可以看到该字段的名称为category_id。\n现在可以扩展表单视图添加字段。点击开发者工具小虫图标，选取Edit View: Form选项。这会打开表单定义的容器。\n图1.8 – 表单视图编辑窗口\n在Architecture标签页下，可以看到基础视图的XML。可以直接进行编辑，但这不是个好做法，因为在模块升级时修改会丢失。正确的方式是通过创建一个扩展视图来对其编辑。\n安装额外的模型可以对基础视图添加更多的字段及视觉元素。这是通过使用扩展视图完成的，并且可在Inherited Views标签页下查看。我们会在这里为联系人表单视图添加我们的扩展。\n在Inherited Views列表中，点击底部的Add a line ，使用如下的值创建扩展视图：\nView Name: 添加一些短描述，如Contacts Form extensions for To-do App。 Architecture: 这会要求一个指定扩展点及所添加内容的XML片断。使用 \u0026lt;field name=\u0026quot;category_id\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt;\u0026lt;field name=\u0026quot;x_is_work_team\u0026quot;/\u0026gt;\u0026lt;/field\u0026gt; 。 扩展视图应当像下图这样：\n图1.9 – 创建扩展视图来添加x_is_work_team字段\n现在点击Save \u0026amp; Close，如果所填XML没有错误，会加到Inherited Views列表，其中会包含我们添加的扩展。点击Save按钮完成对表单视图的修改，通过点击右上角的x关闭Edit Form: View窗口。\n修改已完成，但需要重新加载表单才能看到修改。重新加载页面，现在Tags字段下面应该会出Is Work Team? 字段，如下图所示：\n图1.10 – 带有Is Work Team? 字段的联系人表单视图\n这样就完成了在表单视图中添加自定义字段的步骤。表单只是这些视图类型中的一种。下一节中详细讨论视图的类型。\n了解视图类型 我们刚刚操作了一种视图类型，表单视图。但用户界面中还使用了其它的视图类型。\nContacts的初始视图类型为看板视图，以数据卡片显示一些字段。看视图还可以按列组织卡片。例如，CRM应用以这种初始视图形式显示，称为管道视图。在看板视图中，开发者菜单中显示Edit View: Kanban选项。\n列表视图（有时也称为树状视图）以列表显示记录。在列表视图中，开发者菜单会显示Edit View: List选项。\n最后，搜索视图控制看板视图及列表视图右上角搜索框的行为，以及其下的按钮：Filters和Group By。在搜索框可见时，开发者菜单会显示一个Edit View: ControlPanelView选项。\n视图类型并不仅限于这些，还有其它的类型，我们会在第十章 Odoo 15开发之后台视图 - 设计用户界面中进行探讨。\n可通过Settings \u0026gt; Technical \u0026gt; User Interface \u0026gt; Views菜单项查看所有的视图定义。\n一种更详细的方式是使用Settings \u0026gt; Technical \u0026gt; Database Structure \u0026gt; Models来所要的模型（本例为res.partner，也称之为Contact），并打开Views标签。\n图1.11 – Contact模型的数据库结构\n这里，我们可以看到所选模型的所有视图定义。可以通过View Type列看到不同类型视图的记录，以及基础视图及它们的扩展。修改或新增视图记录会即刻生效，在下次重新加载视图时即可看到修改。\n按视图类型排序有助于查看同一视图类型的所有扩展。\n基础视图是Inherited View字段，有些为空。视图类型并不仅限于一种基础视图。例如，Contact模型(res.partner)的表单视图有多个基础视图，如base.view_partner_form和base.view_partner_simple_form。\n视图还有一个Sequence字段。Sequence序号最小的基础视图为默认显示的视图。在查看表单视图定义时，会看到这个Sequence值。窗口动作用于菜单项，可指定具体使用的基础视图。我们提到，如果未定义某个视图，会使用序号最小的那个。\n新建模型 模型是构建应用的基本组件，包含了所需使用到的数据结构和存储。接下来我们就为 To-do 清单应用添加模型，有三个字段：\nDescription文本 Is done? 标记 Work team（即在清单中相互协作的用户列表） 模型名应使用单数形式，因此新模型的名称应为To-do Item。模型技术名称必须为有效的数据库对象标识符，因此我们应使用字母和下划线，避免使用其它符号。因为通过Technical菜单创建的模型必须带有x_ 前缀，这个新模型的技术名称使用x_todo_item。\n通过菜单Settings \u0026gt; Technical \u0026gt; Database Structure \u0026gt; Models进入模型定义页面。\n点击Models列表中的Create按钮创建新模型：\n填入基本定义值：在Model Description字段中输入To-do Item，Model字段输入x_todo_item。\n默认，模型会在字段列表中包含x_name字段。这是在列表中显示记录或在其它记录引用它时显示的标题。可用作To-do Item的标题，因此编辑修改相应的Field Label列（改为 Title）。\n接下来添加Is Done? 字段。这应当很明确。在Fields列表中，点击底部的Add a line打开新的视图表单，输入如下值：\nField Name: x_is_done Field Label: Is Done? Field Type: boolean 然后点击Save \u0026amp; Close按钮，再点击模型表单中的Save。\n图1.12 – 新建字段表单\n接下来的Work Team字段应该会更有挑战性了。不仅是因为这是一个引用Contact (res.partner)模型中记录的关联字段，而且它还是一个多值选择字段。\n所幸的是Odoo支持多对多关联。本例正是如此，因为每条任务清单可关联多个联系人，而每个联系人又可关联多条任务清单。\n在Fields列表中添加Work Team字段，需要再次点击表单的Edit按钮，接着点击Add a line打开新增字段表单。然后输入如下值：\nField Name: x_work_team_ids Field Label: Work Team Field Type: many2many Related Model: res.partner Domain: [(\u0026lsquo;x_is_work_team\u0026rsquo;, \u0026lsquo;=\u0026rsquo;, True)] 多对多字段有一些专有的基础属性：Relation Table, Column 1和Column 2。这些会自动进行填写，通常使用默认值即可。在第六章 Odoo 15开发之模型 - 结构化应用数据中会详细讨论到这些属性。\nDomain属性是可选的，它为所展示的记录定义了一个过滤器。我们使用它来将联系人限定为勾选了Is Work Team? 标记的人。否则会在选项中出现所有联系人。\nDomain 表达式遵循Odoo 独有的语法 - 一个包含三个值的可迭代对象，每个对象是一个过滤条件，表示待过滤的字段名、过滤运算符及过滤所使用的值。详细的解释参见第七章 Odoo 15开发之记录集 - 使用模型数据。\n小贴士： Odoo有一个交互式的 domain 过滤向导可帮助生成作用域表达式。访问Settings \u0026gt; Technical \u0026gt; User Interface \u0026gt; User-defined Filters菜单。在表单中选中目标模型后，Domain字段会显示一个 + Add filter按钮用于添加过滤条件。下面的文本框会动态地显示作用域表达式代码。\n在完成后，点击模型表单的Save。创建好新模型后，会自动添加一些字段。ORM引擎在所有模型中添加了它们，在进行审计时会很有帮助：\n图1.13 – To-do清单模型的数据库结构\n现在to-do列表应用的底层模型就绪了，但用户还是无法访问。为此，需要配置访问权限。在下一节中我们进行学习。\n创建菜单项和动作 现在已经有了存储任务清单的模型，我们希望在用户界面中添加它。可在UI中添加菜单项实现。\n我们会创建一个直接打开任务列表的顶级菜单。一些应用（如Contacts）正是这样，而另一些则是顶栏下的子菜单。\n菜单的定义位于Settings应用的Technical \u0026gt; User Interface \u0026gt; Menu Items 中：\n图1.14 – Technical菜单中的Menu Items选项\n我们执行如下步骤创建菜单项：\n进行上图的页面，点击Create，输入如下值：\nMenu: To-do Parent Menu: 留空 Action: 选择 ir.actions.act_window 在Action字段旁的选择框中输入To-do Items, 在下拉列表中选择Create and Edit\u0026hellip; ，这时会打开Create: Action 表单弹窗。 在Create: Action表单中，设置如下值：\nAction Name: To-do Items External ID Object: x_todo_item (目标模型的技术名称)。 此时，动作定义应该是下面这样： 图1.15 – Create: Action表单\n点击Create: Action 表单中的Save。然后在Menu Items表单中点击Save，然后to-do列表应用的菜单项就差不多可以使用了。\n菜单的修改要求对整个页面重新加载才可以看到。大多数浏览器可通过F5快捷键来重新加载。但如果现在刷新页面的话，是看不到To-do菜单的。为什么呢？我们现在还看不到菜单的原因是还没有给用户授权访问。\n在对用户展示菜单项之前需要配置访问权限。我们在本章中会进行处理，但在那之前，有必要更深入地讨论一下窗口动作。\n了解窗口动作 本例中，对不带有子菜单项的顶级菜单项直接添加了一个动作。但菜单可以是包含父子关系的树状菜单项。枝叶菜单项拥有一个关联动作，定义选中后的行为。动作名就是在展示视图中使用的标题。\n有好多种动作类型，最重要的有窗口、报表和服务端动作。窗口（window）动作是最常用到的，用于在客户端中展示视图。报表（report）动作用于运行报表，而服务端（server）动作用于定义自动化任务\n这里我们关注的是用于显示视图的窗口动作。刚刚创建的to-do清单菜单项使用了一个直接通过Menu Item表单创建的窗口动作。我们也可以通过Settings \u0026gt; Technical \u0026gt; Actions菜单项查看、编辑这个窗口动作。本例中我们感兴趣的是窗口动作菜单选项。\n小贴士： 很多情况下，使用开发者工具菜单中的Edit Action选项会更为方案，它提供了编辑当前视图窗口动作的快捷方式。\n配置访问控制权限 Odoo自带有权限控制机制，用户仅能使用已授权的功能。这就意味着我们创建的任务清单模型用户是访问不到的。。\nOdoo 12中的变化\n****admin用户现在也像其它用户一样受权限控制所限制。在此前的 Odoo 版本中，admin 都作为特权用户不受权限规则控制。这一情况发生了变化，admin必须要获得授权才能访问模型数据。\n访问权限通过用户组定义。组有时也称为访问控制列表(ACL)，定义访问模型的权限。用户隶属于组。因此，每个用户的权限依赖于其所属组。\n对这个项目，我们会创建一个to-do组，将其分配给访问该项功能的用户。\n此外，我们还可以定义记录规则（有时称作行级权限），用于限制每个用户可访问哪些记录。\n本项目中 to-do 项为每个用户私有，所以用户仅能访问自己创建的记录。\n安全组 访问控制基于组。通过安全组对模型设置权限，控制组内用户所能使用的菜单项。要做更精细化的控制，我们可以通过记录规则对指定菜单项、视图、字段甚至是数据记录进行权限控制，在下一小节中会进行讲解。\n安全组还可以对应用进行管理，通常每个应用有两个组：用户组(User)可执行日常操作、管理员组(Manager)可对应用执行所有配置。\n下面我们为to-do清单应用新建一个安全组。\n在Settings顶级菜单中，导航至Users \u0026amp; Companies \u0026gt; Groups，使用如下值新建一条记录：\nApplication: 留空 Name: To-do User Inherited 标签下: 添加一行，选择User types / Internal User 效果如下：\n图1.16 – To-Do User安全组\n我们的安全组继承了 Internal User组。组的继承表示该组的成员也是所继承组的成员，并对所有的用户累加授权的权限。Internal User 是基础权限组，通常应用的安全组都继承它。\n在 Application 下拉列表中还没有to-do 应用，所以我们直接通过组表单来添加。我们还，那么这个组的成员也会自动（递归）成为所继承组的成员，以获取他们原有的权限。\n**Odoo 12中的变化\n**在 Odoo 12之前，Internal User组称作雇员(Employee)，这只是表面上的修改，代码中标识符(XML id)仍然和此前版本相同：base.group_user。\n安全访问控制列表 现在我们可以将组To-do User授权给指定模型了。\n最简单的方式是使用Groups表单中的Access Rights标签。使用如下值添加一行：\nName: To-do Item User Access Object: 在列表中选择To-do Item 勾选Read Access, Write Access, Create Access和Delete Access：勾选所有这些复选框来授予对应的权限。 模型权限也可通过Settings \u0026gt; Technical \u0026gt; Security \u0026gt; Access Rights菜单进行管理。\n我们无需单独向 Contact 模型添加权限，因为我们的组继承了Internal User组，已经获取了相应权限。\n对用户分配安全组 现在可以将 admin 用户添加到新建权限组来测试新增的权限设置：\n在菜单中点击Users \u0026amp; Companies \u0026gt; Users，打开Mitchell Admin用户的表单，点击Edit。 在Access Rights标签下的 Other 版块，会发现一个名为 To-do User 的复选框用于将用户加入权限组。勾选后点击 Save 保存表单。 图1.17 – Mitchel Admin用户表单\n如果一切操作都正确的话，我们就可以看到 To-do 应用顶级菜单。应该需要重新加载浏览器页面强制刷新菜单项。\n我们还没有为其创建任何视图，但优秀的Odoo框架自动为我们生成一些基本视图：\n图1.18 – 任务清单默认表单视图\n安全记录规则 在对模型赋予访问权限时，默认用户可以访问到它的所有记录。但有时我们要限制每个用户所能访问的记录。通过记录规则可以实现这一点。\n记录规则通过对模型定义 domain 过滤器来对读和写操作进行控制。\n比如我们这里的 to-do 清单应用，任务项应为每个用户私有的，我们不希望其他用户看到自己的记录。需要添加记录规则来过滤出创建者自己的记录，考虑如下几点：\n框架会自动添加create_uid字段，并存储创建记录的用户。因此可使用它来知道每条记录的创建者。 域运行上下文包含一个user变量，其中含有当前用户的浏览器记录。因此我们可以使用点号运算符访问其属性，如user.id的值。 我们可在作用域表达式中使用如下来实现目标：\n[('create_uid', '=', user.id)]\n通过菜单中的Settings \u0026gt; Technical \u0026gt; Security \u0026gt; Record Rules 或开发者菜单的View Record Rules选项进入记录规则设置页。进行页面后使用如下值新建记录规则：\nName: 一个描述性的标题，如 To-do Own Items Model: 在下拉列表中选择模型，此处为To-do Item Access Rights: 规则所授予的操作，这里保留全部勾选 Rule Definition (Domain Filter) : 填写 [(\u0026lsquo;create_uid\u0026rsquo;, \u0026lsquo;=\u0026rsquo;, user.id)] Groups: 这部分包含所应用的安全组。点击Add a line 、选择To-do User组 此时记录规则的定义如下：\n图1.19 – To-do User Own Items记录规则\n此时就完成了记录规则的设定。现在可以试试用 Admin 和 Demo 用户（需提前将 Demo 用户加入到安全组）分别创建几个任务项。各自应该只能看到自己创建的任务了。\n了解超级用户账号 Odoo包含一个内置的像root那样的超级用户，它拥有特殊权限、可不受权限控制的限制。它用于那些需忽略权限控制的内部操作或动作。这个超级用户名为OdooBot，在数据库创建时自动创建，在数据库中的ID为1。\nOdoo 12中的变化\n在Odoo 12之前。用于系统配置的默认admin用户也是超级用户。因此，admin用户默认不受权限控制。在Odoo 12中进行了调整。现在，默认的admin用户是一个普通用户，但默认它被设为所有Odoo应用的管理员。\n超级用户没有登录密码，但可以激活该账号。在通过Admin \\ Setting组用户登录时，开发者菜单中会有一个Become Superuser选项。\n也可以直接在登录界面进行超级用户模式。这时需要通过修改URL添加 ?debug=1来开启开发者模式（如http://localhost:8069/web/login?debug=1）。然后中在Login按钮下方就会出现Login as superuser选项。\n在启用了超级用户后，右上角的当前用户显示为 OdooBot，该区域会变成黄黑相间的条状，以清晰地告知用户开启了超级用户。\n注意：\n仅在绝对必要时才应使用超级用户。超级用户不受权限控制这点会导致数据的不一致性，比如在多公司场景下，所以应尽量避免。\n创建视图 我们创建了To-do Item模型，并且通过菜单项可在用户界面中访问到它。下面我们为其创建两个基本的视图：列表视图和表单视图。\n列表视图中用户浏览已有记录的最基本方式。有时，可在列表视图中直接编辑记录，但更常见的是点击记录访问表单视图来编辑记录数据。\n创建列表视图 我们可在Settings \u0026gt; Technical \u0026gt; User Interface \u0026gt; Views中管理视图。在该页面点击Create按钮，输入如下值：\nView Name: To-do List View\nView Type: Tree\nModel: x_todo_item\nArchitecture：这个标签应包含视图结构的XML。使用如下XML代码：\n\u0026lt;tree\u0026gt; \u0026lt;field name=\u0026#34;x_name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;x_is_done\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; 这时视图的定义如下所示：\n图1.20 – 任务清单列表视图定义\n列表视图的基本结构相当简单，它包含一个 \u0026lt;tree\u0026gt; 元素，内部含有一个或多个对应视图中所显示字段的 \u0026lt;field\u0026gt; 元素。\n在列表视图中还可以做其它有趣的操作，我们会在第十章 Odoo 15开发之后台视图 - 设计用户界面中进行更详细的探讨。\n创建表单视图 表单视图也可以通过Settings \u0026gt; Technical \u0026gt; User Interface \u0026gt; Views创建。通过点击Create创建另一条视图记录，填入如下值：\nView Name: To-do Form View\nView Type: Form\nModel: x_todo_item\nArchitecture：在该标签内，输入如下XML 代码:\n\u0026lt;form\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;x_name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;x_is_done\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;x_work_team_ids\u0026#34; widget=\u0026#34;many2many_tags\u0026#34; context=\u0026#34;{\u0026#39;default_x_is_work_team\u0026#39;: True}\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/form\u0026gt; 注： 如果不指定 View Type,将会通过视图定义代码来自动识别。\n表单视图结构根节点为\u0026lt;form\u0026gt;元素，包含\u0026lt;field\u0026gt;等元素。其它相关元素将在第十章 Odoo 15开发之后台视图 - 设计用户界面中进行学习。对x_work_team_ids工作组字段，我们使用了一个指定的微件many2many_tags，它会以按扭行标签的形式代替普通列表显示关联记录。\n还可以看到在x_work_team_ids工作组字段中使用了一个context属性。默认，关联字段允许我们直接新建关联中使用的记录。因此，用户可以通过Work Team字段直接新建Partner记录。因为只有标记为Is Work Team? 的联系可供选择，我们希望默认创建的联系人都启用该标记。这就是default_x_is_work_team上下文键干的事，为通过该字段创建的记录设置默认值。\n这样我们就新建好了表单视图。如果现在使用To-Do 菜单项新建清单任务或打开列表中已有的记录，会看到刚刚所添加的表单视图。\n创建搜索视图 我们可以在Odoo的视图界面左上角中看到一个搜索框。搜索框让我们可以在指定的字段中进行搜索。在搜索框下面有Filters和Group By 按钮，提供了一些预定义选项。\n搜索视图是一种控制这些行为的UI元素。它定义了在搜索框中输入时所做的搜索以及Filters和Group By按钮内的选项。\n视图可以通过Settings \u0026gt; Technical \u0026gt; User Interface菜单或Odoo 13起开发者菜单的Edit ControlPanelView选项进行编辑，更早的版本中使用Edit Search View。\n当前任务清单模型还未定义过搜索视图，所以我们应当新建一个。我们为过滤菜单添加一个选项来过滤出未完成的清单。\n在新增View表单中填入如下值并点击Save：\nView Name: To-do Search View\nView Type: Search\nModel: x_todo_item\nArchitecture: 在该标签下添加如下XML 代码:\n``` \u0026lt;search\u0026gt; \u0026lt;filter name=\u0026quot;item_not_done\u0026quot; string=\u0026quot;Not Done\u0026quot; domain=\u0026quot;[('x_is_done', '=', False)]\u0026quot; /\u0026gt; \u0026lt;/search\u0026gt; ``` 此后，重新打开或加载任务清单视图时，在Filters的选项列表中就会出现Not Done选项。\n对视图启用默认过滤器 默认就开启这个过滤器会比较好，在不需要时删除。\n在点击To-do菜单项时，它运行一个窗口动作打开To-do列表视图。窗口动作的context对象可用于设置默认过滤器，类似于对字段设置默认值。\n我们使用如下步骤：\n打开To-do菜单进入任务清单列表视图 打开开发者工具菜单并选择Edit Action。这时将弹出一个用于打开当前视图的窗口动作表单。在General Settings标签栏的Filters版块中，有一个Context Value和Domain Value字段。 在Context Value字段中，输入 {\u0026lsquo;search_default_item_not_done\u0026rsquo;: True} search_default_ 前缀指示默认选取一个具体的过滤器，这里为item_not_done。现在如果点击To-do菜单项，会看到在搜索框中默认启用了Not Done，并且用户可以自由取消选择。\nDomain Value字段也可用户对显示的记录设置过滤器，但设置的过滤器用户无法移除。\n小结 在本章中，我们不仅总览了 Odoo 的组件，还利用开发者模式深入到 Odoo 内部来理解这些组件如何共同协作创建应用。\n我们还使用这些工具创建了一个简易的应用，包含模型、视图和对应的菜单。并且学习了如何通过开发者工具查看已有应用或在用户界面中直接进行快速自定义操作。\n下一章中我们将学习如何通过源码安装Odoo，以及准备Odoo模块开发所使用的开发环境。\n"
},
{
	"uri": "/odoo/2/",
	"title": "第二章 Odoo 15开发之开发环境准备",
	"tags": [],
	"description": "",
	"content": "在更深入学习 Odoo 开发之前，我们需要配置好开发环境并学习相关的基础管理任务。\n本章中，我们将学习如何配置构建 Odoo 应用所需的环境。我们会配置一个Ubuntu 系统来托管开发服务端实例。可以使用云服务器、本地服务器或者Windows 10上的子系统。\n学习完本章后，读者可以掌握如何准备开发环境、通过源码运行Odoo以及在同一台机器上拥有多个Odoo项目和多个Odoo版本。读者还会学习Odoo的服务端是如何运行的，以及在开发过程中如何使用它们。\n本文章主要讲解如下内容：\n为Odoo服务端配置主机 使用源码安装 Odoo 管理 Odoo 数据库 配置 Odoo 服务端参数 查找、安装社区插件 使用服务端开发模式 本章的第一步为检查是否满足本章的技术要求以及配置主机稍后安装Odoo。\n开发准备 本章中，我们在Ubuntu 20.04操作系统上使用源码安装 Odoo。只需要使用终端环境，无需Ubuntu的图形化用户界面。\n如果读者手上没有Ubuntu 20.04系统，也可以使用Windows 10主机。我们可以使用Windows 的Linux 子系统，在Windows系统中获取到Ubuntu环境。\n本章的相关代码参见配套的GitHub仓库的ch02/ 目录中。\n设置 Odoo 服务宿主机 推荐使用Debian/Ubuntu来运行 Odoo 服务，这也是参考部署平台。Odoo 自己的 SaaS 平台也运行在 Debian 之上，这也是社区中最主流的选择。也就是说使用Debian 或 Ubuntu 会更容易寻求到帮助或建议。\n注：开发、运行Odoo还可以选择Odoo.sh服务。它提供了基于Git的开发工作流并提供了需用于运行生产系统的所有补充服务，如发送、接收邮件。如果读者对此感兴趣，Odoo官方文档中有很完善的介绍。\n如果已有Ubuntu 20.04，就可以开始学习了。只需要确定是否进行了提权以执行必要的安装步骤。在终端中运行如下命令进行检查。如若成功，即可进入后面的学习：\n$ sudo apt list 如果使用的是Windows，最简单的方案是使用WSL。在下一节我们会进行讲解。\n如果这个方案对你不可用，还可以使用虚拟机。我们不会详细讲解，但下面两点会有帮助：\nVirtualBox是一个免费跨平台的虚拟化软件，访问https://www.virtualbox.org。 Ubuntu服务器ISO镜像可通过https://www.ubuntu.com/server下载。推荐使用最新的长期支持(LTS)版本。 TurnKey Linux提供了几种平台上易于使用的预安装镜像，包含ISO。ISO格式可用于所有的虚拟化软件，甚至可用在裸机上。LAPP镜象是一个不错的选择，它包含Python和PostgreSQL。可访问http://www.turnkeylinux.org/lapp。\n使用 Windows 子系统安装 Linux 2020年3月，自Windows 10的2004版本起就支持了更具鲁棒性的Linux子系统(WSL2 - Windows Subsystem for Linux2)。通过子系统，我们可以在 Windows 内运行 Ubuntu 系统，足以应对 Odoo 开发所需的一切。更多 WSL2 相关知识请参考官网。\nWSL 是Windows 10中的一个可选功能，使用前需要先启用。具体如何操作参见官方帮助文档。\n然后应该就能安装Ubuntu Windows应用了。打开Windows应用商店搜索Ubuntu。在写本书时，最新的Ubuntu LTS(长期支持版本)为20.04。根据安装流程进行操作，设置用户账号及相应的密码。\n运行Ubuntu应用会打开Linux命令行窗口，在其中可输入Ubuntu命令。记录下在安装Ubuntu时配置的用户名和密码，因为在使用sudo进行提取操作时都会要求输入密码信息。\n现在就有了可使用的Debian系操作系统，我们可以开始安装Odoo和依赖了，还有PostgreSQL数据库。\n源码安装 Odoo Odoo使用Python 编程语言，数据存储使用 PostgreSQL数据库。通过源码运行Odoo，我们需要安装其所依赖的Python库。然后在GitHub上下载Odoo源代码。使用Git仓库的方案优于下载源代码ZIP或tar文件。使用Git我们可以控制代码版本，对于发布流程它也是一个很好的工具。\n注：具体依赖的安装根据操作系统和安装的 Odoo 版本可能会不同。如果在上述步骤中出现问题，请参考官方文档。可切换版本查看其它版本的操作步骤。\n安装 PostgreSQL 数据库 Odoo 要使用到 PostgreSQL服务，典型的开发设置是使用安装 Odoo 的同一台机器安装PostgreSQL。\n运行如下命令在Debian/Ubuntu系统中安装PostgreSQL数据库：\nsudo apt update sudo apt install postgresql -y # 安装PostgreSQL sudo su -c \u0026#34;createuser -s $USER\u0026#34; postgres # 创建数据库超级用户 最后这条命令为当前系统用户创建一个PostgreSQL用户，用于 Odoo 实例创建或删除数据库时使用。\n如果在 WSL内运行 Ubuntu，注意系统服务不会自动启动。也就是说运行任何需要数据库连接的命令（如createuser或启动 Odoo 服务）时都要手动开启PostgreSQL服务。手动启动PostgreSQL服务执行如下命令：\n$ sudo service postgresql start 安装 Odoo 系统依赖 运行 Odoo需要一些系统库。获取版本控制的源码应安装 Git，安装运行Odoo 15要求 Python 3.7或之后的版本。以下为所需要的基本系统依赖：\n$ sudo apt update $ sudo apt upgrade $ sudo apt install git # 安装Git $ sudo apt install python3-dev python3-pip python3-wheel \\ python3-venv # 开发环境的Python 3 $ sudo apt install build-essential libpq-dev libxslt-dev \\ libzip-dev libldap2-dev libsasl2-dev libssl-dev Odoo 12中的变化\nCSS预处理器由less 改成了 Sass。也就是说运行Odoo不再需要使用less。Odoo 9-11版需要使用less预处理器。\n如果需要使用11及之前版本，则还需要安装less：\nsudo apt install npm # 安装Node.js和包管理器 sudo ln -s /usr/bin/nodejs /usr/bin/node # 通过node运行Node.js sudo npm install -g less less-plugin-clean-css # 安装less 源码安装 Odoo 为便于管理，我们将在家目录下创建一个/work15目录作为工作目录。在本系列文章中我们均预设 Odoo 代码安装在该目录下。\nOdoo 15 使用的是 Python 3（3.6或之后的版本），也即在命令行中我们不使用python和pip，而是用python3和 pip3。\nOdoo 11的修改\n从版本11开始，Odoo 运行在 Python 3之上，Odoo 11依然支持 Python 2.7，但 Odoo 12仅能运行在Python 3.5+的环境中。Odoo 10及之前的版本仅可运行在Python 2.7中。\n要通过源码安装 Odoo，我们首先要从 GitHub 上直接克隆一套 Odoo 源代码：\nmkdir ~/work15 # 创建工作目录 cd ~/work15 # 进入工作目录 git clone https://github.com/odoo/odoo.git -b 15.0 --depth=1 # 获取 Odoo 源码 ~符号是用户家目录的简写，比如/home/alan。如果使用Windows 10的WSL子系统，可通过在文件浏览器中打开\\wsl$ 找到该目录。该工作目录的完整路径类似于**\\wsl$\\Ubuntu-20.04\\home\\daniel\\work15。**\nGit命令中的-b 15.0明确表明要下载 Odoo 15.0分支。在写本文时，这显得有些多余，因为这正是当前默认的分支，但以后会变化。\n--depth=1告诉Git下载最近的修订版本，而不是所有的历史修改，这会使下载更快、内容更少。\n小贴士： 如需在获取下载后提交的内容，可以运行git fetch \u0026ndash;unshallow。可以只获取近期的更新。git fetch \u0026ndash;depth=100会下载最新100个提交，而git fetch \u0026ndash;shallow-since=2020-01-01会获取所有2020年1月1日之后的所有提交。\n接下来，我们应当安装在requirements.txt中所声明的 Python 依赖。推荐在Python虚拟环境中进行安装。这样会保护Odoo环境不受系统级Python库更新的影响。另一个好处是可以根据所需操作的具体项目保留多个虚拟环境，比如我们使用更老的Odoo版本。下面就开始实操吧：\n执行如下命令新建虚拟环境：\\\n$ python3 -m venv ~/work15/env15 这会在~/work15/env15目录中创建一个Python环境。\n我们希望使用~/work15/env15/bin/python运行所有Python代码。以下命令可显示所安装的Python版本以进行确认：\\\n$ ~/work15/env15/bin/python -V Python 3.8.10 如若将其设为当前默认Python解释器使用势必更轻松。可通过如下命令启用虚拟环境：\\\n$ source ~/work15/env15/bin/activate 一旦我们启用了虚拟环境，命令行会发生变化，包含所启用环境的信息。本例中会由$变为(env15) $。\n可运行which命令来确定所使用的为正确的Python解释器：\n(env15) $ which python /home/alan/work15/env15/bin/python 仅需运行deactivate来禁用掉虚拟环境；此时Python解释器就会变回系统默认：\n$ deactivate $ which python3 /usr/bin/python3 在执行下述命令前请重新启用虚拟环境。\n启用虚拟环境后，可以运行如下命令来安装Python依赖：\n$ source ~/work15/env15/bin/activate (env15) $ pip install -U pip # 更新pip (env15) $ pip install -r ~/work15/odoo/requirements.txt 注：在虚拟环境中，直接使用python和pip命令即可指向正确的版本。在操作系统默认环境中则并非如此，pip指向Python 2，而pip3指向Python 3。如需在系统层面运行这些命令，请将pip替换为pip3，因为Odoo使用Python 3。\n一些Python库要求安装系统二进制文件。如无法安装一些库，请确认已按照本章中安装 Odoo 系统依赖一节安装系统依赖。\n现在已安装了Python依赖库。但仍需要安装Odoo自己。可使用pip来安装：\n(env15) $ pip install -e ~/work15/odoo -e选项用于进行Python可编辑安装。这样 ~/work15/odoo目录中的源码文件可用于运行Odoo。若不添加这一选项，安装流程会将源码目录中的代码文件拷贝至site-packages/ 目录中，然后运行这些拷贝，这样源码的修改或更新均无法体现出来。\n运行Odoo 运行 Odoo 首先要启用相应的虚拟环境：\n$ source ~/work15/env15/bin/activate 在虚拟环境内，只需要运行Odoo来启动实例：\n(env15) $ odoo --version Odoo Server 15.0 odoo命令是简便的快捷方式，在本书中会经常使用到。同时了解一下还可以通过调用相应的可执行命令来启动Odoo：\n(env15) $ ~/work15/odoo/odoo-bin --version 要进行更完整的控制，可以使用指定的Python可执行路径来运行Odoo，这时就无需激活虚拟环境了：\n$ ~/work15/env15/bin/python ~/work15/odoo/odoo-bin –-version 运行Odoo时如果不添加--version选项，就会一直运行，等待客户端调用。\nOdoo默认监听的端口是8069。应使用http://localhost:8069在浏览器中访问Odoo服务。\n如需停止服务并返回命令行，按快捷键Ctrl + C。\n通过web客户端新建数据库 首次访问Odoo时，因为还没有数据库，我们会在辅助页面中新建数据库。默认配置下，通过http://localhost:8069:访问Odoo：\n图2.1：数据库创建表单\n数据库创建表单中要求填写的信息如下：\n主控密码（Master Password）是数据库的管理密码，存储于Odoo配置文件。最新的几个版本会自动生成该密码，参见上图。 数据库名（Database Name）是数据库的标识名称。同一台数据库服务器上可托管多个Odoo数据库，使用独立的标识名称。 Email是默认管理员用户的登录用户名。并不一定要是email邮箱。默认值为admin。 密码（Password）是管理员登录所使用的密码。 语言（Language）是数据库使用的默认语言。 国家（Country）是用于默认设置的国家。这是个可选项，与某些应用的本地化特性相关，如发票和会计应用。 默认为空数据库，但勾选演示数据（Demo data）后会安装演示数据。开发、测试环境建议勾选。 注意：\n管理员（admin）密码和主控（master）密码是不同的概念。主控密码用于管理数据库，可进行备份、还原及拷贝Odoo数据库。管理员密码是默认管理员登录的密码，具有配置Odoo数据库和管理用户的权限。\n在点击创建数据库（Create database）按扭后，会新建数据库并进行初始化，这会花费一些时间。准备就绪后，会重定向至登录界面。\n可通过登录页面底部的管理数据库（Manage databases）进入数据库管理页面。这个管理页面显示当前的数据库列表，并可对其备份、拷贝或删除，同时也可新建数据库。\n也可直接访问http://localhost:8069/web/database/manager.进入数据库管理页面。\n注：\n数据库管理页面可进行一些高权限的管理操作，默认启用且没有密码保护。虽然方便，但这是一个安全威胁。请考虑使用一个复杂的主控密码或最好关闭这一功能。主控密码在Odoo配置文件中进行设置，内容为admin_passwd = \u0026lt;your-complex-password\u0026gt; 。可在配置文件中添加list_db = False禁用数据库管理页。参见配置Odoo 服务端参数一节了解有关配置文件的详情。\n通过命令行新建数据库 我们作为开发者，会需要使用到多个数据库。通过命令行创建会更为便捷。\n如果终端窗口中运行着Odoo，请按下Ctrl + C 进行停止回到命令行。\n加选项-d选项运行Odoo服务可创建并初始化Odoo数据库：\n(env15) $ odoo -d 15-demo --stop-after-init 初始化15-demo数据库需要些时间，完成后会回到命令行。\n如果省去--stop-after-init选项，在数据库就绪后Odoo服务会保持为运行状态。这时仔细看下日志消息里的带有Modules loaded的INFO日志行。这表示已完成数据库的启动，可接受客户端的调用了。注意这可能不是最后一条日志消息，大概会在最后的3到4行之中。\n默认，数据库初始化时会带有演示数据，这有助于进行开发。与在用户界面新建数据库时勾选Load demonstration data的效果一致。\n可在odoo命令后添加--without-demo=all初始化不带演示数据的空数据库。\n要新建数据库，运行Odoo的用户必须是PostgreSQL的超级用户。如果不是，请查看使用源码安装 Odoo一节。\n小贴士：\n在开发环境中使用数据库超级用户来运行Odoo实例没什么问题。但在线上环境中，Odoo安全最佳实践要求使用非数据库超级用户运行Odoo服务。\n现在可运行的实例和数据库都已就位。在浏览器中打开http://localhost:8069，应该就可以进入到Odoo登录页面了。\n如果不确定URL中该使用什么主机名和端口，可查看Odoo服务日志消息。在启动日志的前几行应该会包含这一信息。类似于：\nINFO ? odoo.service.server: HTTP service (werkzeug) running on MYMACHINE:8069 Linux中也可以使用hostname命令来查找主机名，或使用ifconfig命令来查找IP地址。\nOdoo的默认管理员账号为admin，密码也是admin。登录后如果尚未在数据库中安装应用，会看到Apps菜单，显示可进行安装的应用。\n可在运行Odoo服务端的终端窗口按下Ctrl + C 停止实例，返回命令行。按向上键会出现刚刚使用的shell命令，这样可快速使用相同选项两次启动Odoo。按下Ctrl + C ，再按向上键和Enter，这是在开发时重启Odoo服务的常用组合键。\n至此，Odoo已在系统中成功安装、等待使用，Odoo实例的数据库也已准备好。接下来，我们学习如何管理数据库，新建数据库并删除那些不再需要的数据库。\n管理 Odoo 数据库 前面我们学习了如何通过命令行新建和初始化 Odoo 数据库。管理数据库还有更多的命令值得我们学习。\n虽然 Odoo 服务可以自动新建PostgreSQL数据库，我们还是可以使用如下命令来手动创建 PostgreSQL 数据库：\n$ createdb MyDBName 这一命令配合--template 参数可拷贝已有数据库。被拷贝的数据库不能处于连接状态，所以在进行这一操作时要确保 Odoo 实例已停止。\n小贴士：\n在WSL中运行PostgreSQL时，有些操作可能会显示类似WARNING: could not flush dirty data: Function not implemented.的消息。可通过修改PostgreSQL配置文件绕过这一问题。对于PostgreSQL 12，配置文件位于 /etc/postgresql/12/main/postgresql.conf。编辑该文件添加两行，fsync = off 和 data_sync_retry = true。然后使用sudo server posgresql restart重启PostgreSQL服务。\n使用如下命令将MyDBName原始拷贝至MyDBCopy：\n$ createdb --template=MyDBName MyDBCopy 使用PostgreSQL的psql工具添加-l参数查看已有数据库：\n$ psql -l 这会列出截至目前所创建的数据库。如果执行了前面的命令，应该会列出MyDBName和MyDBCopy。这个列表还会包含每个数据库的编码。默认为UTF-8，这也正是Odoo数据库所需要的编码格式。\n如需删除不再使用（或希望重建）的数据库，执行dropdb命令：\n$ dropdb MyDBCopy 现在我们已学习了数据库的基本知识。要了解更多 PostgreSQL的知识，请参见官方文档及psql文档页面。\n警告： dropdb命令进行的数据删除不可撤销。在对重要数据库执行该命令时请务必备份数据库。\n至此我们的Odoo成功运行并且也已知道如何管理项目的数据库或进行试验。但还需要学习最相关的一些Odoo服务端配置参数，以及如何便利地在配置文件中进行存储。\n配置 Odoo 服务端参数 Odoo 服务还支持一些其它参数，可通过--help 来查看所有可用参数：\n(env15) $ odoo --help 我们在下面的部分将会学习一些重要参数。首先我们先学习如何使用配置文件。\nOdoo 服务端配置文件 大多数的参数都可以保存到配置文件中。默认 Odoo 使用.odoorc文件。Linux 系统中缺省的路径是在家目录（$HOME）中，而在 Windows 中则和运行 Odoo 的可执行文件放在同一个目录中。\n注： 在老版本的 Odoo/OpenERP 中，默认的配置文件为.openerp-serverrc。为保持向后兼容，存在该文件且没有.odoorc的情况下会使用该文件。\n全新的安装中不会自动创建.odoorc配置文件，我们应使用--save参数来存储当前实例的配置，如果配置文件不存在则会创建默认配置文件：\n(env15) $ odoo --save --stop-after-init 这里使用的--stop-after-init参数在执行结束后停止服务。\n注：命令行参数可以缩短到保持不引起混淆的程度，如--stop-after-init可缩写为--stop。\n现在可以通过如下命令来查看配置文件中的默认内容：\n$ cat ~/.odoorc # 显示配置文件 以上命令会显示所有配置项及默认值。参数的编辑在下一次启动 Odoo 实例后生效。输入 q 退出，回到命令行。\n使用--conf=\u0026lt;filepath\u0026gt; 或等效的-c \u0026lt;filepath\u0026gt; 短标记参数来指定配置文件。\n例如，如下命令在 ~/work15目录中新建一个配置文件15-demo.conf：\n(env15) $ odoo -c ~/work15/15-demo.conf --save --stop 如下命令使用该配置文件启动Odoo服务：\n(env15) $ odoo -c ~/work15/15-demo.conf 修改监听端口 Odoo服务端默认使用8069端口。要使用其它端口，可以使用--http-port=\u0026lt;port\u0026gt; 参数或使用其简短形式-p \u0026lt;port\u0026gt; 。在同一台机器上同时运行多个实例这会很有帮助。\nOdoo 11的修改： 在 Odoo 11中引入--http-port参数以替代此前版本使用的--xmlrpc-port\n下面就可以做个尝试。打开两个终端，第一个中输入命令：\n$ source ~/work15/env15/bin/activate (env15) $ odoo --http-port=8070 第二个中输入命令：\n$ source ~/work15/env15/bin/activate (env15) $ odoo --http-port=8071 此时就在同一台机器上使用不同端口运行了两个 Odoo 实例，这两个实例可以使用同一个数据库或不同数据库，这取决于我们使用的配置参数，并且两个端口上也可以运行相同或不同版本的 Odoo。\n小贴士： 不同 Odoo 版本必须使用不同的数据库。尝试在不同版本上使用相同数据库将无法正常运行，因为各大版本采用了不兼容的数据库模式。\n过滤可访问的数据库列表 --database或-d参数设置Odoo服务端实例使用的数据库。对该服务端的所有调用都会使用这个数据库，并且对其它数据库的调用都会被拒绝。这种情况发生于Odoo服务端重启使用另一个数据库，而网页窗口中打开的页面还在使用前一个数据库的会话。\n同一个Odoo服务端可以使用多个数据库。这是未选取数据库时的默认行为（在命令行、配置文件及默认配置 ~/.odoorc中均未设置--database参数）。这时新的浏览器会话会打开数据库管理页面，让我们选取想要使用的数据库。\n如果未指定使用的数据库，那么所有的数据库均会出现。使用--db-filter参数会限定Odoo服务端可使用的数据库。\n--db-filter的值可以是一个逗号分隔的数据库名列表或常规表达式。例如，过滤出15-demo名称的表达式为：\n下面是一些常用正则表达式的示例：\n过滤出以某些文本开头的名称，使用 ^ 前缀。如 ^15 过滤出所有以15起始的名称。 过滤出以某些文本结尾的名称，使用 $ 后缀。如demo$ 过滤出所有以demo结束的名称。 使用 ^ 前缀与 $ 后缀的组合可做精准匹配过滤。例如 ^15-demo$ 只能匹配数据库名15-demo 。 使用 . 过滤一个可选单个字符。如 ^15-demo.$ 可匹配15-demo, 15-demo1, 15-demo2等。 使用 .* 过滤可选的字符序列（即任意多个字符）。例如 ^15.demo$ 可匹配15-emo*, 15-demo 或 15-this-is-a-demo等。 管理服务端日志消息 默认Odoo在标准输出中打印服务端日志消息，因而在终端窗口中打印。\n下面是一行日志的示例：\n2021-11-08 08:06:57,786 18592 INFO 15-demo odoo.modules.loading: Modules loaded. 每行日志遵循一个包含如下列的结构：\n2021-11-08 08:06:57,786：日志消息的日期和时间戳，使用的是UTC，而非本地时间。 18592:：PID，系统的进程 ID。 INFO：消息的日志级别。 15-demo：数据库名。对于并非在特写数据库上下文中执行的操作显示为 ? 。 werkzeug：输出消息的Odoo模块。例如odoo.modules.loading用作模块加载操作。 剩下的文本记录消息的内容。\nHTTP请求的消息文本有一个特定的结构，由werkzeug模块处理。如下例：\n2021-11-08 08:06:57,786 18592 INFO 15-demo werkzeug: 127.0.0.1 - - [08/Apr/2020 08:06:57] \u0026#34;POST /web/dataset/call_kw/res.partner/read HTTP/1.1\u0026#34; 200 - 213 0.135 0.092 这里我们可以看出做出HTTP请示的详情，包含源IP地址、调用的端点以及HTTP状态码。\n还可以看到性能信息，位于文本消息的最后：最后面的3个数字。上例中为213 0.135 0.092。这些性能数字的含义为：\n查询数，即执行的SQL查询数量 运行SQL查询耗费的时间 SQL之外所花费的时间（主要来自于Python代码） 对于日志，我们可以控制两个配置：日志在哪里输出以及日志的信息量。\n--log-level用于控制日志的信息量。默认设置为info级别。\n减少日志信息量，可以将日志级别设置为如下的一种：\nwarn仅显示警告和错误 error仅显示错误 critical仅显示妨碍服务端正常运行的错误 提升日志级别有助于了解服务端的一些问题。还有如下信息量更大的日志级别：\ndebug启用调试级别的信息 debug_sql显示所执行的SQL查询 debug_rpc显示所接收到的RPC请示的详情 debug_rpc_answer显示发回到客户端的RPC应答详情 通过对服务启动命令添加参数在测试不同的日志级别，如下例所示：\n(env15) $ odoo --log-level=debug_sql 然后，浏览网页端的一些页面，查看服务端日志中有何不同。\n--log-handler让我们可以更精细地对具体模块设置日志级别。使用的格式为--log-handler=MODULE1:LEVEL,MODULE2:LEVEL,... 。一种找到、确定应使用的模块名称的方式是查看已写入日志中的消息。日志级别可为DEBUG, INFO, WARN, ERROR或CRITICAL（均为大写）。\n例如，将加载模块日志消息提升为debug，使用如下命令：\n(env15) $ odoo --log-handler=odoo.modules:DEBUG 降低HTTP请求处理的日志信息量，使用如下命令：\n(env15) $ odoo --log-handler=werkzeug:WARN 有关日志输出的位置，默认重定向至标准输出（终端界面），但也可定向至日志文件。可使用--logfile=\u0026lt;filepath\u0026gt; 实现，如下：\n(env15) $ odoo –logfile=~/work15/odoo.log 注: Linux系统中，日志文件一般放在 /var/log目录中。因此Odoo的日志文件通常位于var/log/odoo/ 。\n现在我们知道了如何控制Odoo实例以及重要的服务端参数，意味着我们可以做一些更深度的操作了。社区提供的Odoo模块可以让我们受益良多，因为一个关键的技能是学会如何在Odoo实例中使用这些模块。\n查找、安装社区插件 Odoo生态有一个丰富的社区，具有大量的模块。在Odoo实例中安装新模块通常让初学者困扰。但完全不必如此。\n查找社区模块 Odoo应用商店是一个模块目录，可以下载模块并安装到系统中。\n另一个重要的资源是Odoo 社区联盟(OCA - Odoo Community Association)，托管社区维护的模块。这些模块托管在 GitHub 上，地址为https://github.com/OCA。https://odoo-community.org/shop提供了一个可搜索的索引。\nOCA 是一个协调社区贡献、提升软件质量、推广最佳开发实践和开源价值观的非营利组织。可通过https://odoo-community.org进下了解OCA。\n为 Odoo 添加模块，仅需将其拷贝到官方插件所在的 addons 文件夹中即可。前例中插件目录位于 ~/work15/odoo/addons/ 。但这不是一个好的实践。我们安装的 Odoo 是由 Git 版本控制的代码仓库，我们希望它与上游 GitHub 仓库保持同步，在其中混入外部插件会不利于管理。\n避免这一问题，我们可以选取其它目录存放这些模块，让 Odoo 服务也会从这些目录中查找模块。我们不仅可以把自定义模块放在一个不同的目录下不与官方的混在一起，还可以通过不同目录组织这些模块。\n我们可以通过下载系统课程的代码来准备供 Odoo 安装的插件模块，获取 GitHub 上的源码，执行如下命令：\n$ cd ~/work15 $ git clone https://github.com/PacktPublishing/Odoo-15-Development-Essentials.git library 这会将工作目录切换至 ~/work15，将本书GitHub仓库中的代码下载至library/ 子目录。接下来需要告知Odoo新模块所在的目录。\n配置插件(add-ons)路径 Odoo的addons_path配置参数列出服务端查找模块的目录。默认，它指向两个目录：一个是包含base模块的服务端内部代码，另一个是插件目录，其中包含标准模块和应用。对于本文接下来的配置，应为 /work15/odoo/odoo/addons,/work15/odoo/addons。\n我们使用包含新模块目录的插件路径启用服务端：\n$ cd ~/work15 $ source env15/bin/activate (env15) $ odoo -d 15-library --addons-path=\u0026#34;./library,./odoo/addons\u0026#34; 以上命令确保我们位于工作目录中，且激活了Python虚拟环境。然后，Odoo使用了两个选项进行启动：Odoo所使用的数据库名15-library，以及所使用的插件路径。为简化信息，这里使用了相对路径。\n服务启动后，仔细看下日志的前几行。应当会有一条日志消息报告所使用的插件路径，类似于INFO ? odoo: addons paths: [\u0026hellip;] 。确认其中包含 library/ 目录；\n图2.2：包含所使用插件路径的 Odoo启动序列日志消息\n现在学习了如何对Odoo实例添加第三方模块，并期望能开发自己的模块。有几个Odoo服务端参数可以助力开发。在开始编码前进行了解会很有益。\n使用服务端开发模式 Odoo还提供了服务端开发模式，可使用--dev=all参数启用。\n开发模式开启了几个加速开发周期的特性：\n在代码文件保存时自动重新加载Python代码，无需手动重启服务。 对视图定义的修改立即生效，无需手动升级模块（注意仍需重新加载浏览器中的页面）。 --dev=all参数在抛出异常时会调出pdb Python 调试器。有助于对服务端错误进行后期分析。有关Python调试命令的更详细内容参见https://docs.python.org/3/library/pdb.html#debugger-commands。\n--dev参数可接收一个逗号分隔的参数列表，虽然all参数在大部分情况下都适用。默认使用的Python调试器为pdb。这个调试器略有点简洁，还有其它的调试器可用。支持的外部调试器有pdb, pudb和wpdb。\n要在监测到代码文件修改后进行自动重新加载，必须要安装watchdog Python包：\n(env15) $ pip install watchdog 有关调试器的使用会在第八章 Odoo 15开发之业务逻辑 - 业务流程的支持中讨论。\nOdoo 命令行快查手册 以下是最重要的Odoo命令的快查手册：\n-c,--conf=my.conf：设置所使用的配置文件。\n--save：保存配置文件。\n--stop,--stop-after-init: ：在加载完模块后停止服务。\n-d,--database=mydb：使用此数据库。\n--db-filter=^mydb$ ：使用正则表达式过滤可用的数据库。\n-p,--http-port=8069：HTTP服务所使用的端口。\n-i,--init=MODULES：安装逗号分隔列表中的模块。\n-u,--update=MODULES：更新逗号分隔列表中的模块。\n--log-level=debug：日志级别。包含 debug, debug_sql, debug_rpc, debug_rpc_answer和warn。调试指定核心模块的可选项有：\n--log-sql：调试SQL 调用 --log-request：调试HTTP请求调用 --log-response： 调试HTTP调用的响应 --log-web：调用=HTTP请求响应 --log-handler=MODULE:LEVEL：设置指定模块的日志级别。示例如下：\n--log-handler=werkzeug:WARN --log-handler=odoo.addons:DEBUG --logfile=\u0026lt;filepath\u0026gt; ： 将日志发送至文件。\n--dev=OPTIONS：选项包含 all, [pudb|wdb|ipdb|pdb], reload, qweb, werkzeug和 xml.\n小结 本章中，我们学习了如何配置Ubuntu系统来托管Odoo，以及通过GitHub源码安装 Odoo。我们还学习了如何创建Odoo数据库及运行Odoo实例。\n学完本单本章读者应当有一个运行正常的Odoo环境，并且能管理数据库及Odoo实例。\n至此，我们可以上正菜了。下一章中，我们会从头创建第一个Odoo模块，并掌握其包含的主要元素。\n"
},
{
	"uri": "/odoo/3/",
	"title": "第三章 Odoo 15开发之创建第一个 Odoo 应用",
	"tags": [],
	"description": "",
	"content": "Odoo 开发通常都需要创建自己的插件模块。本文中我们通过创建首个Odoo应用，学习在 Odoo 中显示、安装应用的步骤。\n我们将从开发工作流的基础学起，即创建、安装新模块，然后升级开发迭代中更新的代码。\nOdoo 采用类 MVC(Model-View-Controller)的架构，我们会深入到各层来实现一个图书应用。\n本文主要包含以下内容：\n图书项目总览 步骤1：新建插件模块 步骤2：新建应用 步骤3：添加自动化测试 步骤4：实现模型层 步骤5：配置访问权限 步骤6：实现后台视图层 步骤7：实现业务逻辑层 步骤8：实现网站用户界面(UI) 通过这种方法，我们会渐进学习组成应用的基本组成，并体验从零构建Odoo模块的迭代流程。\n技术准备 学习本文需安装 Odoo 服务端，并可通过命令行启动服务来进行模块安装和运行测试之类的操作。如果还没有可用的Odoo开发环境，请参照第二章 Odoo 15开发之开发环境准备。\n本章中我们从零开始创建第一个 Odoo 应用，无需任务初始代码。\n本章的代码可通过 GitHub 仓库的ch03目录进行查看。\n注： 本章示例代码中使用的数据库名为 library，如你使用了其它数据库名称，请自行修改\n图书项目总览 为更好地讲解本章知识点，我们通过案例进行学习。一起来创建一个管理图书的 Odoo 应用。该项目会在后续章节中持续使用，每篇文章都会进行一次迭代，对应用添加新的功能。本文中创建图书应用的第一个版本。\n实现的第一个功能是图书目录。目录让我们可以在图书馆中保存图书的记录和图书详情。我们希望这个目录是可以对外访问的，可以查到可借阅的图书。\n图书应包含如下数据：\n标题 作者 出版社 出版日期 封面图 ISBN（国际标准书号）：包含ISBN的有效性检查 上架标记；标识图书是否可公开发布 按Odoo基本应用的惯例，图书应用有两个用户有组：图书用户和图书管理员。用户可执行日常操作，管理员还可以编辑应用的配置。\n图书目录部分中，我们把图书记录编辑的功能预留给管理员。如下：\n图书管理员可编辑图书 图书用户和网站访客仅能浏览图书 这一简单的项目包含构建Odoo应用的所有主要组件。第一步是要创建一个模块目录，用于放置应用的代码和组件。\n步骤1：新建插件模块 插件模块是包含实现Odoo功能文件的目录。可以新增功能或修改已有的功能。插件目录必须含有一个声明或描述文件__manifest__.py。\n一部分模块插件在 Odoo 中以应用（app）的形式出现。应用是Odoo功能区中的那些顶级模块，我们希望这一模块出现在Apps菜单的顶级。Odoo的基本应用有CRM、Project和 HR。非应用模块插件一般依赖于某个应用，为其添加或扩展功能。\n如果新模块为 Odoo 添加新的或重要的功能，一般应归类为应用。而如果模块仅修改已有应用的功能，那就是一个普通的插件模块。\n开发新模块，我们需要：\n确保操作的目录在 Odoo 的 addons 路径中 创建模块的目录，并包含声明文件 如打算对外发布，为模块选择一个证书 添加模块描述信息 为模块添加一个图标，此为可选 然后我们就可以安装模块了，确定模块在 Odoo 服务中可见并正确安装。\n准备 addons 路径 一个插件模块是一个含有 Odoo 声明文件的目录，它创建一个新应用或为已有应用添加功能。addons目录中可包含多个插件模块。addons路径是Odoo的一项配置，包含一系列目录，Odoo服务端可在其中查找插件。\n默认addons路径包含odoo/addons，其中存放 Odoo 自带的官方应用，以及odoo/odoo/addons目录，其中为提供核心功能的 base 模块。通常修改addons添加一个或多个目录，用于有些话自定义开发的及所希望使用的社区模块\n图书应用包含多个模块。这是一种良好实践，因其采用更小更精细的模块，降低了复杂度。我们为项目模块创建一个插件目录。\n读者如果学习了第二章 Odoo 15开发之开发环境准备，Odoo服务端代码应该存放于 ~/work15/odoo/ 。自定义插件模块就放在自己的目录中，独立于Odoo代码之外 。\n我们为图书应用创建一个 ~/work15/library 目录，将该目录添加至添加路径中。可通过直接编辑配置文件或Odoo的命令行来实现。操作如下：\n$ mkdir ~/work15/library $ source ~/work15/env15/bin/activate (env15) $ odoo \\ --addons-path=\u0026#34;~/work15/library,~/work15/odoo/addons\u0026#34; \\ -d library -c ~/work15/library.conf --save --stop 这时Odoo命令行会返回这样的错误：odoo: error: option \u0026ndash;addons-path: no such directory: \u0026lsquo;/home/daniel/work15/library\u0026rsquo; 。这是因为该目录仍是空的，Odoo无法在其中查找到插件模块。在搭建好首个图书应用模块的骨架后就不会存在这一问题了。\n下面是关于Odoo命令行参数的说明：\n--addons-path参数设置所有Odoo模块所在的目录。 -d或--database参数设置所使用的数据库名。如果数据库不存在，会使用Odoo的基本数据库模块创建并初始化。 -c或--config参数设置使用的配置文件。 --save参数配合-c参数使用将参数保存到配置文件中。 --stop是--stop-after-init的短格式，它会在所有启动序列中的操作完成后停止Odoo服务，回到命令行。 如果插件路径参数使用的是相对路径，Odoo会将其转化为绝对路径再存储到配置文件中。\nODOO 15中的变化\n所创建的配置文件会使用默认配置作为模板。在Linux系统中，默认配置文件为 ~/.odoorc。\nOdoo 自带一个scaffold命令可快速创建新的模块骨架。可以使用它为图书插件目录填充有效的模块。执行如下命令初始化library_app模块目录：\n(env15) $ odoo scaffold library_app ~/work15/library scaffold命令需要两个参数：模块目录名及创建位置的路径。有关scaffold命令的详情比较偏，可以执行odoo scaffold --help查看。\n现在再次执行保存配置文件的命令，带上插件目录 ~/work15/library/ ，就可以成功运行了。\n启动序列的前几行日志消息包含所使用的配置。其中包含INFO ? odoo: Using configuration file at\u0026hellip; 用于标识所使用的配置文件，以及INFO ? odoo: addons paths: [\u0026hellip;] 列出所使用的插件目录。在排查Odoo为什么没能找到自定义模块时首先应该查这里。\n创建模块目录 接上一节，我们有 ~/work15/library目录用于存放Odoo模块，将其添加到了插件路径中，这样Odoo服务就可以找到其中的模块了。\n上一节中我们还使用了Odoo的 scaffold 命令自动为library_app模块目录创建了一个骨架结构，其中包含了基础的结构。scaffold命令的用法为：odoo scaffold \u0026lt;module\u0026gt; \u0026lt;addons-directory\u0026gt; 。所创建的模块目录如下：\nlibrary_app/ ├── __init__.py ├── __manifest__.py ├── controllers │ ├── __init__.py │ └── controllers.py ├── demo │ └── demo.xml ├── models │ ├── __init__.py │ └── models.py ├── security │ └── ir.model.access.csv └── views ├── templates.xml └── views.xml 模块目录名是其技术名称，本例中使用library_app。技术名称应为有效 Python 标识符，即以字母开头且仅能包含字母、数字和下划线。\n它包含多个子目录，用作模块的不同组件。这种子目录结构并非强制，但普遍这样用。\n有效的Odoo插件目录并包含一个 __manifest__.py描述文件。模块还应是可导入的，因此必须包含一个 __init__.py文件。在目录树结构中可以看到这正是前两个文件。\n小贴士： 在Odoo的老版本中，模块描述文件的名称为为__openerp__.py。 这一文件已废弃但系统仍支持。\n描述文件包含一个Python字典，其中的属性对模块进行描述。脚手架所自动生成的文件如下：\n# -*- coding: utf-8 -*- { \u0026#39;name\u0026#39;: \u0026#34;library_app\u0026#34;, \u0026#39;summary\u0026#39;: \u0026#34;\u0026#34;\u0026#34; Short (1 phrase/line) summary of the module\u0026#39;s purpose, used as subtitle on modules listing or apps.openerp.com\u0026#34;\u0026#34;\u0026#34;, \u0026#39;description\u0026#39;: \u0026#34;\u0026#34;\u0026#34; Long description of module\u0026#39;s purpose \u0026#34;\u0026#34;\u0026#34;, \u0026#39;author\u0026#39;: \u0026#34;My Company\u0026#34;, \u0026#39;website\u0026#39;: \u0026#34;http://www.yourcompany.com\u0026#34;, # Categories can be used to filter modules in modules listing # Check https://github.com/odoo/odoo/blob/15.0/odoo/addons/base/data/ir_module_category_data.xml # for the full list \u0026#39;category\u0026#39;: \u0026#39;Uncategorized\u0026#39;, \u0026#39;version\u0026#39;: \u0026#39;0.1\u0026#39;, # any module necessary for this one to work correctly \u0026#39;depends\u0026#39;: [\u0026#39;base\u0026#39;], # always loaded \u0026#39;data\u0026#39;: [ # \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#39;views/views.xml\u0026#39;, \u0026#39;views/templates.xml\u0026#39;, ], # only loaded in demonstration mode \u0026#39;demo\u0026#39;: [ \u0026#39;demo/demo.xml\u0026#39;, ], } 下一节中我们会详细讨论声明文件。\n模块文件 __init__.py应触发模块所有Python文件的导入。更具体来说，它应导入模块顶层的所有Python文件以及包含Python文件的子目录。类似地，这些子目录也应包含一个 __init__.py文件，导入子目录中的Python资源。\nscaffold命令所生成的顶层 __init__.py文件内容如下：\nfrom . import controllers from . import models 在顶层中没有Python文件，只有两个包含Python文件的子目录：controllers和models。查看模块的树结构，可以看到这两个目录均包含Python文件以及 __init__.py文件。\n创建声明文件 scaffold命令所准备的声明文件可作为指南，或者我们也可以创建一个空的声明文件。\n声明文件应为一个包含字典的Python文件。不强制包含任何键，所以一个空字典 {} 就可作为文件的有效内容。实践中，我们希望为模块提供一些基本信息、声明作者并选择分发证书。\n以下可作为初始内容：\n{ \u0026#34;name\u0026#34;: \u0026#34;Library Management\u0026#34;, \u0026#34;summary\u0026#34;: \u0026#34;Manage library catalog and book lending.\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Alan Hou\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;AGPL-3\u0026#34;, \u0026#34;website\u0026#34;: \u0026#34;https://alanhou.org\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;15.0.1.0.0\u0026#34;, \u0026#34;depends\u0026#34;: [\u0026#34;base\u0026#34;], \u0026#34;application\u0026#34;: True, } 这里用到的键为应用表单的主标签中显示的信息，如下图所示：\n图3.1：图书管理模块应用表单\n我们使用了如下的描述键：\nname：模块标题 summary：对模块做的单行综述 author：版权作者姓名。本处为一个字符串，但可以是逗号分隔的一系列姓名 license:：标示作者授权模块进行分发的证书。AGPL-3和LGPL-3都是知名的开源选项。通过Odoo应用商店销售的自有模块应当使用Odoo自家的证书OPL-1。在本章的后面会对证书做更深入讨论。 website：了解模块更多信息的 URL（统一资源定位符），可以帮助人们查看更多文档或提供文件 bug 和建议的跟踪 version:：模块的版本号。应遵守版本号规则。建议在模块版本号前加上 Odoo 版本，这样有助于确定模块所针对的Odoo版本。例如，针对Odoo 15.0的1.0.0模块可使用版本号15.0.1.0.0。 depends：插件模块的依赖列表。安装模块时会触发对这些模块的安装。如果模块没有具体的依赖，通常会让其依赖base模块，但这并非强制要求。 application：一个布尔型标记，代表模块是否在应用列表中以应用展示。大多数扩展模块是对已有应用添加功能，会将此值设置为False。图书管理模块是一个新应用，因为设置为True。 对依赖列表应保持谨慎。应确保在这里显式设置所有的依赖，否则，在新数据库中安装模块时可能会失败，因为缺失依赖或由于在Odoo启动序列中所需的模块加载时间晚于当前模块产生加载错误。在其它机器上部署时这两种情况都可能出现 ，定位、解决问题会非常耗时。\n图3.1中的 \u0026lt;div class=\u0026quot;document\u0026quot;\u0026gt; 一行用于模块的长描述，目前为空。这在添加描述一节中会进行讨论。\n还有一些其它的描述键，用得不那么频繁：\ninstallable：表明模块是否可安装。默认值为True，因而无需显示设置。如果出于某种原因希望在插件目录中保留文件却禁用模块可以将其设置为False。 auto_install：可设置为True，用于胶水模块。胶水模块的安装在安装所有依赖时进行一次触发。例如，它可用于在实例中同时安装了两个应用时，自动为其提供桥接的功能。 设置模块分类 模块可进行分类，表示相关的功能区。这些分类用于插件模块的分组，以及安全组。\n如果插件未设置分类，默认使用Uncategorized。当前图书应用正是这一分类。\n我们可以在Apps菜单的左边栏中看到一些Odoo的分类。在那里可以看到模块所能使用的分类，如下图所示：\n图3.2：应用列表分类边栏\n分类可进行分组，如Project应用属于Services/Project分类。\n如果对模块使用了不存在的分类，Odoo会自动创建。我们利用这一特性为图书应用新建 一个分类：Services/Library。\n编辑 __manifest__.py文件新增category：\n\u0026#34;category\u0026#34;: \u0026#34;Services/Library\u0026#34;, 分类也可用于组织安全组，需要相应的XML ID来在XML数据文件中引用它们。\n分配给模块分类的XML ID由base.module_category_ 加上分类名自动生成。例如，Services/Library所生成的XML ID为base.module_category_services_library。\n我们可以访问相应的表单视图然后使用开发者菜单中的View Metadata选项来查看应用分类的XML ID 。\n应用分类没有菜单项，但可能过安全组表单访问分类表单，如下：\n打开Settings \u0026gt; User \u0026gt; Groups 菜单选项，新建一条测试记录。 在Application字段下拉列表中选择中选择一个选项，点击保存。操作流程如下图所示：\n图3.3：用户组表单的应用选择列表 点击Application链接打开所选的分类对应详情表单。 位于分类表单时，在开发者菜单中选择View Metadata 查看所分配的XML ID。\n此时不打算使用就可以删除测试分组了。 此外，可在Odoo的源代码中查看内置的分类及它们的XML ID。对应的GitHub链接为https://github.com/odoo/odoo/blob/15.0/odoo/addons/base/data/ir_module_category_data.xml。\n选取证书 选取模块的证书非常重要，应当仔细考虑哪个是最佳选项，以及其潜在含义。\n软件代码受版权法保护，保留作者使用和修改的权利。这通常是指你个人或你所在的公司。而其它主体如需安全使用你的代码，必须获取代码作者的证书授权。\n如果希望代码自由免费传播，需要包含一个证书，表明其他有权使用你的代码。不同的证书条款不同。\nOdoo模块最常使用的证书是LGPL-3（GNU\u0026rsquo;s Not Unix (GNU) Lesser General Public License） 及AGPL-3（Affero General Public License） 。两者都允许自由发布并进行修改，要求是应携带作者的署名以及衍生的代码要使用相同的证书。\nAGPL是一种强力的开源证书，要求使用代码的在线服务对用户共享源代码。在社区中流行这种证书是因为它强制衍生的代码也使用AGPL发布。因而开源代码无法内置到商业解决方案中，而原作者可以因其他的改进而受益。\nLGPL比AGPL更具许可性，它允许进行商业修改，而无需分享相应的源代码。网络和系统集成组件通常选择这种证书，其解决方案可能包含私有证书或与AGPL相兼容的组件。\n进一步了解GNU 证书请访问GNU官网。\n虽然可以销售GPL证书的应用，这却不是一种常用的商业模式，因为其他人可以自由拷贝、发布该代码。因此，Odoo应用商店中销售的很多模块使用自有证书。Odoo推荐使用其自有证书OPL-1。\n进一步了解Odoo 证书请访问https://www.odoo.com/documentation/user/legal/licenses/licenses.html。\n添加描述 描述（description）是一段展现模块功能的长文本。描述文本支持通过RST（reStructuredText） 格式生成富文本文档。\n可通过https://docutils.sourceforge.io/rst.html学习RST知识。该页面包含一个快捷手册链接，值得收藏：https://docutils.sourceforge.io/docs/user/rst/quickstart.html。\n以下是一个RST文档的简短示例：\nTitle ===== Subtitle -------- This is *emphasis*, rendered in italics. This is **strong emphasis**, rendered in bold. This is a bullet list: - Item one. - Item two. 添加描述的一种方式是在模块声明文件中使用description键。因为描述很可能会跨多行，最好在三引号 \u0026quot;\u0026quot;\u0026quot; 中添加内容，这属于Python多行字符串的语法。\n在GitHub等网站上发布的源代码应包含README文件，供访客轻松查看模块的简介。因此除了声明文件中的描述，Odoo还可以使用README.rst或README.md文件。文件应放在模块的根目录下，与 __manifest__.py文件同级。\n另一种方案是使用HTML（超文本标记语言）文档描述文件。很多Odoo应用商店中发布的模块使用这种方式，对应用功能做更丰富的视觉展示。index.html文件应放在static/description/ 模块子目录下。页面资源文件，如图片和CSS，应当放在同一目录中。\n注：对于将application设置为True的模块，只使用index.html描述，description键会遭到忽略。\n添加图标 模块可以选择一个自己的图标。对于创建为应用的模块，这尤为重要，因为应用会在Apps菜单下显示图标。\n需要对模块添加static/description/icon.png 文件进行使用。\n对于图书应用项目，我们复用已有Odoo应用Notes的图标，将其拷贝至library_app/static/description目录中。\n在命令行中使用如下命令：\n$ cd ~/work15/library/library_app $ mkdir -p ./static/description $ cp ~/work15/odoo/addons/note/static/description/icon.png ./static/description/ 安装新模块 现在我们已经有了一个精简的插件模块。尚未实现任何功能，但我们可以通过安装它来检查是否正常运行。\n安装新模块，应在启动服务时使用**-d和-i参数。-d或--database参数确保我们使用正确的Odoo数据库。-i**或--init参数接收一个待安装的逗号分隔模块列表。\nODOO 11中的变化\n安装新模块时，Odoo会自动当前配置的插件路径中更新可用模块列表。截至Odoo 10还不是如此，彼时需要在安装插件模块前手动更新模块列表。模块列表在网页客户端通过Apps列表中的菜单项更新。\n使用本章所准备的Odoo开发环境并激活Python虚拟环境，可通过如下命令安装library_app模块：\n(env15)$ odoo -c ~/work15/library.conf -d library -i library_app 我们添加了**-d** library参数来指定正确的数据库进行安装。如果在配置文件中已进行指定，这个参数就是多余的。尽管如此，出于安全保障，最好在命令行中声明安装的数据库。\n小贴士：仔细看服务端日志消息，确定可正确找到模块并安装。应该会在日志中看到odoo.addons.base.models.ir_module: ALLOW access to module.button_install并且无警告信息。\n为让模块可安装，应将模块所在的插件目录告知Odoo。可通过重启Odoo服务端，并查找启动时所打印的odoo: addons paths: 日志消息来进行确认。\n如果找不到该模块，通常是因为插件路径错误。仔细检查使用的插件路径。\n升级模块 开发模块是一个不断迭代的过程，对源代码不断地修改并在 Odoo 中应用。\n可以在图形界面(GUI) 的Apps列表中查找模块并点击 Upgrade 按钮。这会重新加载数据文件、应用所做的修改并升级数据库模式定义。但如果修改的是 Python 逻辑，点击升级还不够。需要重启Odoo服务来重新加载修改后的Python代码。有时，模块中既修改了数据文件又修改了 Python 逻辑，那么就需要同时进行如上两种操作。\n总结起来如下：\n修改模型或其字段时，需要进行升级来应用数据库模式的修改。 修改Python逻辑代码时，需要重启来重新加载代码文件。 修改XML或CSV文件时，需要进行升级来重新应用文件中的数据。 为避免修改Odoo代码时所产生的困惑和阻力，最简单的方案是在修改代码后通过升级命令重启Odoo服务。\n在服务端实例的终端中通过Ctrl + C停止服务。然后通过如下命令启动服务并升级library_app模块：\n(env15)$ odoo -c ~/work15/library.conf -d library -u library_app -u参数(或全称\u0026ndash;update)要求使用-d 参数并接收一个逗号分隔的待升级模块集。例如可以使用-u library_app,mail。模块升级后，所有依赖该模块的模块也会被升级。\n按下上方向键会调出之前使用的命令。因此大部情况下，会使用Ctrl + C、上方向键和Enter键的组合来重复这一操作。\n在近几个Odoo版本中，可使用对开发者友好的--dev=all参数，来自动化这一工作流。使用该参数后，数据文件的修改会即时体现在运行的Odoo服务中，Python代码的修改会触发Odoo代码重新加载。有关这一参数的详情，请参见第二章 Odoo 15开发之开发环境准备的使用服务端开发模式一节。\n现在模块目录已就绪，可托管实现应用的所有组件。因为这是一个应用，而非添加功能的技术模块，我们会开始添加一些应用所需的基础组件。\n步骤2：新建应用 一些 Odoo 模块创建新应用，而另一些则对已有应用添加功能或作出修改。虽然两者的技术组件基本相同，但应用通常包含一些特征性元素。我们创建的是一个图书应用，所以应在模块中包含这些元素。\n应用应包含的元素如下：\n图标：用于在应用列表中展示 顶级菜单项：其下放置应用的所有菜单项 应用安全组：通过访问权限仅对指定用户开放 应用的图标是放置在static/description/子文件夹中的icon.png文件。在添加图标一节中已经添加过了。\n下面我们来添加应用的顶级菜单。\n添加应用顶级菜单项 我们创建的是一个新应用，因此应包含主菜单项，在社区版中，位于左上角的下拉菜单中，而在企业版中，则作为附加图标显示在应用切换器主界面中。\n菜单项是使用 XML 数据文件添加的视图组件。通过创建views/library_menu.xml文件添加以下内容来定义菜单项：\n\u0026lt;odoo\u0026gt; \u0026lt;!-- Library App Menu --\u0026gt; \u0026lt;menuitem id=\u0026#34;menu_library\u0026#34; name=\u0026#34;Library\u0026#34; /\u0026gt; \u0026lt;/odoo\u0026gt; 用户界面，包含菜单项和操作，均存储于数据表中供客户端实时读取解释，\n上面的文件描述了要载入 Odoo 数据库的记录。 \u0026lt;menuitem\u0026gt; 元素指示在存储Odoo菜单项的ir.ui.menu模型上写入一条记录。\nid 属性也称作XML ID，用于唯一标识每个数据元素，以供其它元素引用。例如在添加图书子菜单时，就需要引用父级菜单项的XML ID，即menu_library。\n此处添加的菜单项非常简单，仅用到了一个属性name。其它常用的属性这里没有使用。在本章稍后的实现后台视图层部分中会深入学习。\n图书模块还不知道 XML 数据文件的存在。我们需要在声明中使用 data 属性来添加、载入到Odoo实例中。编辑 _manifest__.py文件中的字典，添加如下键：\n\u0026#39;data\u0026#39;: [ \u0026#39;views/library_menu.xml\u0026#39;, ], data声明键是一个在安装或升级模块时加载的数据文件列表。文件路径为声明文件所丰的根目录的相对路径。\n要向Odoo数据库中加载这些菜单设置，需要升级模块。此时还不会有什么显式的效果。因菜单项还不包含可操作子菜单，所以不会显示。在添加好子菜单及相应的访问权限时即可显示。\n小贴士： 菜单树中的项目仅在含有可见子菜单项时才会显示。打开视图的底层菜单项仅对拥有访问相应模型的权限的用户可见。\n添加权限组 普通用户在使用功能前需获得相应的权限。Odoo 中使用权限组来实现。权限授予组，组中再分配用户。\nOdoo 应用通常有两个组，访问权限不同：\n用户访问权限，用于执行日常操作的用户 管理员访问权限，包含配置等所有功能的访问权限 图书应用也包含这两个权限组。下面我们会实现。\n访问权限相关的文件通常放在security/ 模块子目录中，因此我们需要创建一个security/library_security.xml文件用于权限定义。\n权限组以插件模块使用的相同分类进行分组。需要找到相应的XML ID来为权限组设置分类。查找XML ID的方法在本章的设置模块分类一节中已进行过讨论。通过那部分的学习，我们知道Services/Library的XML ID 为base.module_category_services_library.。\n下面我们就来添加这图书用户权限组。它属于前面所定义的Library分类，XML ID为module_library_category，还会继承内部用户权限，在其基础上实现。如若在用户组表单中打开开发菜单的View Metadata选项，会看到其XML ID为base.group_user。\n现在对security/library_security.xml文件添加如下XML：\n\u0026lt;odoo\u0026gt; \u0026lt;data\u0026gt; \u0026lt;!-- Library User Group --\u0026gt; \u0026lt;record id=\u0026#34;library_group_user\u0026#34; model=\u0026#34;res.groups\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;User\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;category_id\u0026#34; ref=\u0026#34;base.module_category_services_library\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;implied_ids\u0026#34; eval=\u0026#34;[(4, ref(\u0026#39;base.group_user\u0026#39;))]\u0026#34; /\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt; 这里的知识量比较大，所以我们慢慢讲解下每个元素。这段XML是对组模型es.groups添加一条记录。记录有三个字段，分别是：\nname： 组名。这是一个普通的字符串。 category_id： 关联应用，这是一个关联字段，因此使用了 ref 属性来通过 XML ID 连接此前创建的分类。 implied_ids： 这是一个一对多（one-to-many）关联字段，包含一个组列表来涵盖对组内的用户。对多字段使用了一个特殊语法，在本书第五章 Odoo 15开发之导入、导出以及模块数据中会进行介绍。我们使用了编号4来连接已有的内部用户组XML ID，base.group_user。 ODOO 12中的变化\nUser表单拥有一个User Type版块，仅在开启了开发者模式才能看到。这样我们可以选择互斥选项中的一个：Internal User、Portal (外部用户，如客户)和Public (网站匿名访客)。这一修改是为了避免此前版本中存在的错误配置，那时内部用户可能不小心加入到Portal和Public组中，从而降低了访问权限。\n接下来我们创建管理员组。授予用户组的所有权限以并为应用管理员保留其它的权限。因此我们要继承图书用户library_group_user。\n编辑security/library_security.xml文件，在 **\u0026lt;odoo\u0026gt; **元素中添加如下XML：\n\u0026lt;!-- Library Manager Group --\u0026gt; \u0026lt;record id=\u0026#34;library_group_manager\u0026#34; model=\u0026#34;res.groups\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Manager\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;category_id\u0026#34; ref=\u0026#34;base.module_category_services_library\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;implied_ids\u0026#34; eval=\u0026#34;[(4, ref(\u0026#39;library_group_user\u0026#39;))]\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;users\u0026#34; eval=\u0026#34;[(4, ref(\u0026#39;base.user_root\u0026#39;)), (4, ref(\u0026#39;base.user_admin\u0026#39;))]\u0026#34; /\u0026gt; 这里也像之前一样出现了name, category_id, and implied_ids字段。implied_ids字段设置为链接向图书用户组，继承其权限。\n同时还设置了users字段。将该授权给了管理员（admin）和Odoobot用户。\nODOO 12中的变化\nOdoo 12开始，有了系统root用户，在用户列表中不显示，由框架在需要提权操作（sudo）时在内部使用。admin可以登入系统并应拥有所有功能的访问权限，但不再像系统 root 用户那样可以绕过访问限制。在Odoo 11及之前的版本中，admin用户同时也是内部root超级用户。\n同样需要在声明文件中添加该 XML 文件：\n\u0026#34;data\u0026#34;: [ \u0026#34;security/library_security.xml\u0026#34;, \u0026#34;views/library_menu.xml\u0026#34;, ], 注意library_security.xml 加在library_menu.xml文件之前。数据文件的加载顺序非常重要，因为我们只能引用已经定义过的标识符。菜单项经常引用到安全组，所以建议将安全组定义文件放到菜单和视图文件之前。\n下一步是添加定义应用模型的Python代码。但在那之前我们按照测试驱动开发(TDD)的理论先添加一些测试用例。\n步骤3：添加自动化测试 编程的最佳实践包含代码的自动化测试，对于像 Python 这样的动态语言尤为重要，因为它没有编译这一步，只有在解释器实际运行代码时才会报语法错误。好的编辑器可以让我们提前发现问题，但无法像自动化测试这样帮助我们确定代码是否可如预期运行。\nTDD理论让我们先写测试，检查错误，然后开发代码直至通过测试。受此方法启示，在添加实际功能前我们先添加模块测试：\nOdoo支持基于Python内置unittest库的自动化测试。这里我们快速介绍下自动化测试，在第八章 Odoo 15开发之业务逻辑 - 业务流程的支持有更为详尽的讲解。\nOdoo 12中的变化\n截至Odoo 11，测试可使用YAML（YAML Ain\u0026rsquo;t Markup Language）文件来进行表述。但 Odoo 12中移除了对YAML文件的支持，所以不能再使用这种方法。\n测试需要满足一条件才能被发现，并由测试运行器执行，条件如下：\n测试放在tests/ 子目录中。不同于常规的Python代码，这一目录不需要在顶层的 __init__.py中导入。测试引擎会查找模块中的测试目录，然后运行。 测试代码文件名应以test_开头，并通过tests/__init__.py导入。测试代码放在Odoo框架几个可用测试对象派生出的类中，由odoo.tests.common导入。最常用的测试类为TransactionCase。测试对象使用setUp() 方法初始化测试用例所使用的数据。 每个测试用例都是以test_ 打头的方法。对于TrasactionCase测试对象，每个测试都是独立的事务，开始时运行setup步骤，结束时回滚。因此，下面的步骤不会知道前一个测试所做的修改。 小贴士： 测试可使用演示数据更简便地完成配置阶段，但不是一种良好实践，因为那样测试用例只能在安装了演示数据的数据库中运行。如果在测试配置中准备所有测试数据，那么该测试可在任意数据库中运行，包括空数据库或线上数据库的备份库中。\n我们计划在应用中添加 library.book模型。下面添加一个简单测试，用于确定新书是否正确创建。\n添加测试用例 我们添加一个简单测试，检测书的创建。这要求添加一些配置数据并添加一个测试用例。测试用例仅用于确定active字段的值是否为预期的默认值True。\n按照如下步骤操作：\n在tests/__init__.py中添加如下代码：\\\nfrom . import test_book 然后添加实际的测试代码，位于tests/test_book.py文件中，内容如下：\\\nfrom odoo.tests.common import TransactionCase class TestBook(TransactionCase): def setUp(self, *args, **kwargs): super().setUp(*args, **kwargs) self.Book = self.env[\u0026#39;library.book\u0026#39;] self.book1 = self.Book.create({ \u0026#34;name\u0026#34;: \u0026#34;Odoo Development Essentials\u0026#34;, \u0026#34;isbn\u0026#34;: \u0026#34;879-1-78439-279-6\u0026#34; }) def test_book_create(self): \u0026#34;New Books are active by default\u0026#34; self.assertEqual(self.book1.active, True) setUp() 方法获取了一个Book模型对象的指针，然后使用它新建一本书。\ntest_book_create测试用例添加了一个简单的测试，检查所创建的书active字段的默认值。完全可以在测试用例中创建这本书，但我们选择了初始化方法。原因是我们打算在其它测试用例中使用这本书，在setup中进行创建可以减少重复代码。\n运行测试用例 在安装或升级模块时使用--test-enable参数可在启动服务时运行测试，如下：\n(env15) $ odoo -c ~/work15/library.conf -u library_app --test-enable Odoo服务会在升级的模块中查找tests/ 子目录，然后运行测试。现在测试会抛出错误，可以在服务日志中看到ERROR消息与测试相关。在模块中添加图书模型后就可以解决这一问题。\n现在应对测试添加业务逻辑。理想情况下，代码的每一行都应对应至少一个测试用例。\n测试业务逻辑 测试我们打算添加检测ISBN有效性的逻辑。所以添加一个测试用例看能否正确检测出 《Odoo 开发手册第一版》ISBN的有效性。检测方法由check_isbn() 方法实现，返回值为True 或 False。\n在tests/test_book.py文件test_book_create() 方法后再加几行代码：\ndef test_check_isbn(self): \u0026#34;Check valid ISBN\u0026#34; self.assertTrue(self.book1._check_isbn) 推荐为每个需检查的操作添加一个测试用例。别忘了在使用TransactionCase测试时，每条测试都会独立运行，测试用例创建或修改的数据在测试结束时会进行回滚。\n当然，现在运行测试还是会失败，因为还没有实现所测试的功能。\n测试访问权限 也可以对访问权限进行检测，确定是否对用户进行了正确的授权。\nOdoo 中默认测试由不受权限控制的内部用户__system__执行。所以我们要改变执行测试的用户，来检测是否授予了正确的访问权限。这通过在self.env中修改执行环境来实现，只需把 user 属性修改为希望运行测试的用户即可。\n我们可以修改测试在实现。编辑tests/test_book.py中的setUp方法如下：\ndef setUp(self, *args, **kwargs): super().setUp(*args, **kwargs) user_admin = self.env.ref(\u0026#39;base.user_admin\u0026#39;) self.env = self.env(user=user_admin) self.Book = self.env[\u0026#39;library.book\u0026#39;] self.book_ode = self.Book.create({ \u0026#39;name\u0026#39;: \u0026#39;Odoo Development Essentials\u0026#39;, \u0026#39;isbn\u0026#39;: \u0026#39;879-1-78439-279-6\u0026#39;})\u0026lt;br\u0026gt; 我们在setUp方法中添加了两行。第一条使用XML ID查找到admin用户记录。第二行修改用于运行测试的环境self.env，将活跃用户修改为admin用户。\n不需要对所编写的测试做其它的修改了。运行的方式不变，但使用的是admin用户，因为更改了环境。\n图书应用现在有了两具基本测试，但运行会失败。接下来我们应添加实现功能的代码，以让测试可通过。\n步骤4：实现模型层 模型描述并存储业务对象数据，如客户关系管理(CRM) 机会、销售订单或伙伴（客户、供应商等）。模型描述一组字段，也可添加具体的业务逻辑。\n模型数据结构及关联的业务逻辑以Python代码呈献 ，使用由Odoo模板类派生出来的对象类。模型与数据表有映射关系，Odoo框架处理所有的数据库交互 ，不仅保持数据库结构与对象的同步，还将所有事务转译为数据库指令。负责的框架组件为对象关系映射 (ORM) 组件。\n我们的应用用于管理图书，所以需要一个图书目录模型。\n创建数据模型 Odoo 开发指南中提到模型的 Python 文件应放在models子目录中，每个模型有一个对应文件。因此我们在library_app模块目录下创建models/library_book.py文件。\n小贴士： Odoo 官方编码指南请见 Odoo 官网。另一相关的编码标准文档为 OCA 编码指南。\n首先应让模块使用的models/ 目录。这表示在Odoo加载模块时应由Python对其进行导入。为此，编辑模块的主__init__.py文件添加如下内容：\nfrom . import models 同样models/ 子目录应包含一个 __init__.py文件导入要使用的代码文件。添加models/init.py文件，内容如下：\nfrom . import library_book 现在我们可以创建models/library_book.py加入如下内容：\nfrom odoo import fields, models class Book(models.Model): _name = \u0026#39;library.book\u0026#39; _description = \u0026#39;Book\u0026#39; name = fields.Char(\u0026#39;Title\u0026#39;, required=True) isbn = fields.Char(\u0026#39;ISBN\u0026#39;) active = fields.Boolean(\u0026#39;Active?\u0026#39;, default=True) date_published = fields.Date() image = fields.Binary(\u0026#39;Cover\u0026#39;) publisher_id = fields.Many2one(\u0026#39;res.partner\u0026#39;, string=\u0026#39;Publisher\u0026#39;) author_ids = fields.Many2many(\u0026#39;res.partner\u0026#39;, string=\u0026#39;Authors\u0026#39;) 第一行是 Python 代码导入语句，让 Odoo 内核的models和fields对象在这里可用。\n第二行声明了新的library.book模型。这是一个继承自models.Model的类。\n接下来的几行进行了缩进，Python的代码按缩进层次进行定义，也就是这些行是对Book类的定义。类名使用驼峰式命令，这是Python一种惯例。实际使用的Python类名与Odoo框架无关。与Odoo相关的模型ID是 _name属性，在类中定义。\n接着类名的两行使用下划线开头，声明了Odoo类的属性。 _name定义了唯一ID (UID)，在Odoo中使用它来引用该模型。模型ID使用点号( . )来分隔关键词。\n小贴士： 仅有模型名使用点号(.) 来分隔关键字。其它如模块、XML 标识符、数据表名等都使用下划线(_)。\n紧接着的是 _description模型属性。这是模型记录的显示名，在涉及模型记录的用户消息中会用到。不强制有这个字段，但没有的话会在服务端日志中显示警告消息。\n最后的7行声明了模型字。我们可以看最常用的几种字段类型。标量值可以使用Char, Boolean, Date和Binary类型。关联字段可以使用Many2one 和 Many2many。\nname字段用作数据模型标题，这里为书名。\nactive 字段用于有效记录，默认仅有效的记录会显示，无效记录会隐藏。适用于需要隐藏不再使用的记录但由于历史原因又要在数据库中保留的情况。\n小贴士： name和active均为特殊字段名。默认对Odoo有特殊用途。name默认用作记录显示名，在另一个模型引用它时显示。active字段用于在用户界面中过滤掉无效记录。\npublisher_id是一个多对一关联字段，在数据库中称为外键。它存储对另一个模型记录的关联关系，本例中为res.partner模型。用于关联出版公司。通常多对一字段的名称以 _id结尾。\nauthor_ids是一个多对多关联字段。可存储其它模型一条或多条记录的关联关系。本例用于图书的作者，可关联res.partner模型中的多条记录。在数据库层面，这种数据并不是存储在一个表格字段中，而是放在一个自动创建的辅助数据表中，用于存储两张表之间的关联。通常对多字段的名称以 _ids结尾。\n图书和伙伴模型之间有两种关联。伙伴模型是Odoo框架中内置的，用于存储人、公司和地址。我们使用它来存储出版社和作者。\n现在通过升级图书应用来使用这些修改生效。以下是在library数据库中升级library_app模块的命令：\n(env15)$ odoo -c ~/work15/library.conf -d library -u library_app 现在还没访问图书模型的菜单。在本章稍后会添加。那么查看新创建的模型看是否在数据库中创建正确，可以通过Technical菜单。在Settings顶级菜单中，进入Technical \u0026gt; Database Structure \u0026gt; Models，搜索library.book模型、点击查看其定义内容，如下图所示：\n图3.4：Technical菜单下的library.book模型视图\n我们应该可以看到所列的模型，并确认它包含Python文件中所定义的字段。如果你看不到，请升级重启，仔细查看服务端日志，看有没有加载图书应用的消息，以及有没有Odoo数据库的警告消息。\n在library.book字段列表中，我们会看到一些并未声明的其它字段。这些特殊字段由Odoo自动为某个模型添加。它们是：\nid是模型中每条记录的唯一数据库标识符 create_date和create_uid分别为记录创建时间和创建者 display_name为所使用的记录提供文本显示，如其它记录引用它，它就会被计算并默认使用 name 字段中的文本 write_date和write_uid分别表示最近修改时间和修改者 __last_update是一个计算字段 ，它不在数据库中存储，用于做并发检测 现在图书模型在数据库中进行了创建，但用户仍无法访问。我们需要添加菜单，但光加菜单也不行。要显示菜单，首先需要授权新模型的访问。\n步骤5：配置访问权限 library.book模型已在数据库进行了创建，便在加载服务时，你可能会注意到输出日志中有一条警告信息：\nThe model library.book has no access rules, consider adding one. 提示消息已经很明确了，我们的新模型没有权限规则，所以没人能使用。我们已为应用添加了权限组，现在需要授权他们访问应用模型。\nODOO 12中的变化\nadmin和其它用户一样遵守访问权限规则，只有像root这样的超级用户才不受限。在访问新模型之前需要先授权。在Odoo 11及之前则并非如此。在这些较早的Odoo版本中，admin用户也是内部超级用户，不受权限规则的限制。也就说admin自动可以使用新模型。\n添加访问控制权限 要了解需要哪些信息来为模型添加权限，可访问后台Settings \u0026gt; Technical \u0026gt; Security \u0026gt; Access Rights，如下图所示：\n图3.5：Technical菜单中的访问权限列表\n这些访问权限也称称作访问控制列表（ACL）。上图中可以看到一些模型的ACL。表明权限组可以对记录执行哪些操作：读、写、创建和删除。\nOdoo 14中的变化\n用于交互向导的临时模型，现在也需要向用户组提供访问权限。此前的Odoo版本没这个要求，用户默认可访问这些模型。推荐授予读、写和创建的权限，而不给删除权限（在CSV文件中为1,1,1,0）。\n我们的图书应用会给用户组授予写、读和创建图书记录的权限，而管理员拥有所有权限，包含删除记录的权限。\n这一数据可通过模块数据文件提供，将记录加载到ir.model.access模型中。CSV数据文件的名称必须与所要加载数据的模型ID相匹配。\n所以要新增security/ir.model.access.csv文件，内容如下：\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink access_book_user,BookUser,model_library_book,library_group_user,1,1,1,0 access_book_manager,BookManager,model_library_book,library_group_manager,1,1,1,1 文件的第一行为字段名。CSV 文件中有如下列：\nid是记录的外部标识符（也称为XML ID），需在模块中唯一。 name是描述性标题。可提供信息，推荐使用唯一的名称。 model_id是授权模型的外部标识符。模型有ORM自动生成的XML ID，对于library.book，标识符为model_library_book。 group_id指明授权的权限组，我们给前文创建的权限组授权：library_group_user和library_group_manager。 perm_\u0026hellip;字段授权read读, write写, create创建, 或unlink删除操作。使用1表示yes/true，0表示no/false 别忘了在__manifest__.py的 data 属性中添加对新文件的导入。修改后如下：\n\u0026#39;data\u0026#39;: [ \u0026#39;security/library_security.xml\u0026#39;, \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#39;views/library_menu.xml\u0026#39;, ], 老规矩升级模块使修改在Odoo数据库中生效。此时警告信息就不见了。\n这时，admin用户就可以访问图书模型。所以每一条测试应该可通过。我们来运行一下：\n(env15) $ odoo -c ~/work15/library.conf -u library_app --test-enable 应该可以看到一条测试通过，一条失败。\nACL访问权限在模型层授权，但Odoo还通过记录规则支持等级访问权限。在下一小节中讲解。\n行级权限规则 权限规则定义过滤器限定权限组可访问的记录。例如，限定销售员仅能查看自己的报价，或是会计仅能查看所授权公司的会计账目。\n为展示这个功能，我们限定图书用户无法访问无效图书。虽然默认这些书是隐藏的，但通过active等于True的条件进行过滤时还是会访问这些记录。\n记录规则位于Technical菜单下，与Access Rights同级。存储于ir.rule模型中。\n定义记录规则所需的字段如下：\nname: 独特的标题，最好是唯一的。 model_id: 对应用规则的模型的引用。 groups: 对应用规则的权限组的引用。这是一个可选项，如未设置则被视为全局规则（global字段自动设置为True）。全局规则运行机制不同，其所加的限制非全局规则无法覆盖。使用特定的语法写入对多字段中。 domain_force: 用于访问限制的域过滤器，采取由Odoo所使用的域过滤表达式元组列表语法。 要对图书应用添加记录规则，需编辑security/library_security.xml文件在结束标签 \u0026lt;/odoo\u0026gt; 前再添加一段 \u0026lt;data\u0026gt; ：\n\u0026lt;data noupdate=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;record id=\u0026#34;book_user_rule\u0026#34; model=\u0026#34;ir.rule\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Book User Access\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model_id\u0026#34; ref=\u0026#34;model_library_book\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;domain_force\u0026#34;\u0026gt; [(\u0026#39;active\u0026#39;,\u0026#39;=\u0026#39;,True)] \u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;groups\u0026#34; eval=\u0026#34;[(4,ref(\u0026#39;library_group_user\u0026#39;))]\u0026#34; /\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/data\u0026gt; 记录规则位于\u0026lt;data noupdate=\u0026quot;1\u0026quot;\u0026gt;元素中，表示这些记录在安装模块时会被创建，但在模块更新时不会重写。这么做是允许对规则在后面做自定义但避免在执行模型升级时自定义内容丢失。\n小贴士： 开发过程中noupdate=\u0026ldquo;1\u0026quot;会带来麻烦，因为要修复和修改在模块升级时都不会更新。有两种处理方法。一种是在开发时临时使用noupdate=\u0026ldquo;0\u0026rdquo; ，完成后修改为noupdate=\u0026ldquo;1\u0026rdquo; 。另一种是不进行升级而是重新安装模块。在命令行中对已安装模块将**-u换成-i**即可实现。\n不会在数据库中重写数据。所以在开发时可以修改为noupdate=\u0026ldquo;0\u0026quot;来让数据达到预期结果。\ngroups字段是多对多关联，使用对多字段所需要的特定语法。它是一个元组列表，每个元组都是一条命令。本例中使用了 (4, x) ，4表示接下来引用的记录会附加到值之后。所引用的记录为library_group_user，即图书用户组。第六章 Odoo 15开发之模型 - 结构化应用数据中会讨论到对多字段写入的语法。\n作用域表达式也使用特殊的语法，一个三元的列表，每个三元元组指定一个过滤条件。第七章 Odoo 15开发之记录集 - 使用模型数据中讲解作用哉过滤器语法。\n现在用户已可访问图书模型，我们接下来添加用户界面，先从菜单开始。\n步骤6：实现后台视图层 视图层为用户界面的描述，视图用 XML 定义，由网页客户端框架生成数据可知的 HTML 视图。\n菜单项可执行窗口动作渲染视图的。比如，Users 菜单项处理一个同样名为 Users 的操作，然后使用列表和表单一个视图组合。\n有多种视图类型可供使用。3种最常用的视图为列表视图（因历史原因也称为树状视图）、表单视图以及在搜索框右上角的搜索视图。\n在接下来的小节中，我们会逐步进行改进，需要频繁地升级模块来使用修改生效，也可使用--dev=all服务端参数，这样在开发时就无需升级模块。使用该参数时，视图定义会直接从XML文件中读取，所做的修改无需升级模块即可在 Odoo 中即刻生效。在第二章 Odoo 15开发之开发环境准备中详细地讲解了--dev参数。\n小贴士： 如果因 XML 错误导致模块升级失败，不必惊慌！仔细阅读服务端日志的错误信息，就可以找到问题所在。如果觉得麻烦，注释掉最近编辑的 XML 内容或在__manifest__.py中删除该XML 文件，重新更新，服务应该就可正确启动了。\n按照Odoo的开发者指南，用户界面的XML文件应放在views/ 子目录中。\n接下来就创建我们图书应用的界面吧。\n添加菜单项 我们的应用现在有了存储图书数据的模型，接下来希望在用户界面中访问它。首先要做的就是添加相应菜单项。\n编辑views/library_menu.xml文件，添加如下的窗口动作和模块菜单项记录：\n\u0026lt;!-- 打开图书列表的动作 --\u0026gt; \u0026lt;record id=\u0026#34;action_library_book\u0026#34; model=\u0026#34;ir.actions.act_window\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Books\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;res_model\u0026#34;\u0026gt;library.book\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;view_mode\u0026#34;\u0026gt;tree,form\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;!-- 打开图书列表的菜单 --\u0026gt; \u0026lt;menuitem id=\u0026#34;menu_library_book\u0026#34; name=\u0026#34;Books\u0026#34; parent=\u0026#34;menu_library\u0026#34; action=\u0026#34;action_library_book\u0026#34; /\u0026gt; 这个数据文件包含两条添加到 Odoo 的记录：\n\u0026lt;record\u0026gt; 元素定义了一个客户端窗口动作，按顺序在打开library.book模型时启用列表视图和表单视图。 图书的 \u0026lt;menuitem\u0026gt; ，运行此前定义的action_library_book动作。 现在再次升级模块来让修改生效。可能需要刷新浏览器页面来查看新菜单。完成后就可以看到Library顶级菜单，并包含一个子菜单Books。\n虽然尚未定义界面视图，Odoo会自动生成视图，让我们马上就可以查看、编辑数据。\n点击 Library \u0026gt; Books菜单会显示一个基础列表视图，点击Create按钮会显示如下的表单视图：\n图3.6：为图书应用所自动生成的表单视图\nOdoo自动为我们生成了视图，但不够完美。我们可能希望自己着手创建视图，先从图书表单视图开始。\n创建表单视图 视图存储在数据库的ir.ui.view模型中的数据记录。因此我们需要添加数据文件，其中包含描述视图的 \u0026lt;record\u0026gt; 元素。\n新增views/book_view.xml文件来定义表单视图：\n\u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;view_form_book\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Book Form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.book\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form string=\u0026#34;Book\u0026#34;\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;author_ids\u0026#34; widget=\u0026#34;many2many_tags\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;publisher_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;date_published\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;isbn\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;active\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;image\u0026#34; widget=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; ir.ui.view记录有一个定义XML ID的记录id字段，在其它记录引用它时使用。视图记录设置了三个字段的值：name, model和 arch。\n这是library.book模型的视图，名为Book Form。这个名称仅用于提供信息。无需唯一，但应易于分辨所指向的记录。其实可以完全省略 name，那样会按模型名和视图类型来自动生成。\n最重要的字段是arch，因其包含了视图的定义，需要仔细讲解。\n其中每一个元素是 \u0026lt;form\u0026gt; 标签。它声明了所定义的视图类型，其它元素因由其包裹。\n接着，我们在表单中使用 \u0026lt;group\u0026gt; 元素定义了分组。它可包含 \u0026lt;field\u0026gt; 元素及其它元素，包括内嵌group元素。group添加一个两列的隐形风格，很适合字段，因为其占据的正是两列，一列为标签文件，另一列为输入框。\n我们的表单仅包含一个 \u0026lt;group\u0026gt; 元素，我们为每个字段添加一个 \u0026lt;field\u0026gt; 元素以进行显示。字段会自动使用相应的默认微件，比如日期字段使用日期选择微件。在某些情况下，我们可能会添加widget属性来使用指定的微件。author_ids字段就是这么做的，使用一个将作者显示为标签列表的我邮件，还有image字段，使用处理图片的相应我邮件。第十章 Odoo 15开发之后台视图 - 设计用户界面中会详细讲解视图元素。\n不要忘记在声明文件的 data 中加入新建文件，否则我们的模块将无法识别并加载该文件。代码如下：\n\u0026#39;data\u0026#39;: [ \u0026#39;security/library_security.xml\u0026#39;, \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#39;views/library_menu.xml\u0026#39;, \u0026#39;views/book_view.xml\u0026#39;, ], 视图文件通常在权限文件之后、菜单文件之前。\n要使修改载入 Odoo 数据库，就要更新模块。还需要重新加载页面来查看修改效果，可以再次点击菜单项或刷新网页（大多数浏览器中快捷键为 F5）。\n业务文档表单视图 上面的部分创建了一个基础表单视图，还可以做一些改进。对于文档模型，Odoo 有一个模拟纸张的展示样式。表单包含两个顶级元素：包含操作按钮的 \u0026lt;header\u0026gt; 元素和包含数据字段的 \u0026lt;sheet\u0026gt; 元素。\n可以使用它修改上一节中定义的基础 \u0026lt;form\u0026gt; 元素：\n\u0026lt;form string=\u0026#34;Book\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- 此处添加按钮 --\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;!-- 内容放在这里： --\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;author_ids\u0026#34; widget=\u0026#34;many2many_tags\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;publisher_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;date_published\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;isbn\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;active\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;image\u0026#34; widget=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;/form\u0026gt; 表单可包含按钮，用于执行动作。这类按钮可以运行窗口动作，通常是打开另一个表单，或运行Python的方法。按钮可以放在顶部的 \u0026lt;header\u0026gt; 区中，或是表单的其它位置。我们来学习如何做。\n添加动作按钮 我们将演示在头部添加一个按钮检测图书的ISBN是否有效。使用的代码为图书模型中的方法，名为button_check_isbn() 。\n我们尚未添加该方法，但可以先在表单中添加相应的按钮，代码如下：\n\u0026lt;header\u0026gt; \u0026lt;button name=\u0026#34;button_check_isbn\u0026#34; type=\u0026#34;object\u0026#34; string=\u0026#34;Check ISBN\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; 一个按钮的基本属性有：\nstring：定义按钮显示文本 type：执行的动作类型，object或action name：所运行动作的ID。对于object，name为方法名，而action使用动作的记录 ID class：应用 CSS 样式的可选属性，与HTML中用法相同 使用组来组织表单 \u0026lt;group\u0026gt; 标签可用于组织表单内容。 \u0026lt;group\u0026gt; 元素创建一个两栏的隐形网格。其中添加的字段元素会在垂直方向上叠加，因为每个字段占据两个单元格：一个用作标签，另一个用作输入框。在 \u0026lt;group\u0026gt; 元素内添加两个 \u0026lt;group\u0026gt; 元素会生成一个两列字段的布局。\n我们会使用它来组织图书表单。修改 \u0026lt;sheet\u0026gt; 中的内容如下：\n\u0026lt;sheet\u0026gt; \u0026lt;group name=\u0026#34;group_top\u0026#34;\u0026gt; \u0026lt;group name=\u0026#34;group_left\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;author_ids\u0026#34; widget=\u0026#34;many2many_tags\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;publisher_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;date_published\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group name=\u0026#34;group_right\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;isbn\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;active\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;image\u0026#34; widget=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/sheet\u0026gt; 这里的 \u0026lt;group\u0026gt; 元素添加了name属性，为其赋值了标识符。这不是强制的，但建议这么做，因为更易于扩展视图引用它们。\n完整的表单视图 此时图书表单视图的XML定义如下：\n\u0026lt;form\u0026gt; \u0026lt;header\u0026gt; \u0026lt;button name=\u0026#34;button_check_isbn\u0026#34; type=\u0026#34;object\u0026#34; string=\u0026#34;Check ISBN\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;group name=\u0026#34;group_top\u0026#34;\u0026gt; \u0026lt;group name=\u0026#34;group_left\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;author_ids\u0026#34; widget=\u0026#34;many2many_tags\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;publisher_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;date_published\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group name=\u0026#34;group_right\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;isbn\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;active\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;image\u0026#34; widget=\u0026#34;image\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;/form\u0026gt; 动作按钮还无法使用，因为需要添加业务逻辑。在本章的后续会添加。\n添加列表视图和搜索视图 定义列表视图使用 \u0026lt;tree\u0026gt; 视图类型。其结构非常直白。 \u0026lt;tree\u0026gt; 顶级元素应包含以列形式展示的字段。\n我们可以在book_view.xml文件中添加 \u0026lt;tree\u0026gt; 视图的定义：\n\u0026lt;record id=\u0026#34;view_tree_book\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Book List\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.book\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;tree\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;author_ids\u0026#34; widget=\u0026#34;many2many_tags\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;publisher_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;date_published\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 以上定义了一个含有四列的列表：name, author_ids, publisher_id和 date_published。\n在该列表的右上角，Odoo 显示了一个搜索框。搜索的字段和可用过滤器由 \u0026lt;search\u0026gt; 视图定义。\n同样还在book_view.xml文件中添加：\n\u0026lt;record id=\u0026#34;view_search_book\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Book Filters\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.book\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;search\u0026gt; \u0026lt;field name=\u0026#34;publisher_id\u0026#34; /\u0026gt; \u0026lt;filter name=\u0026#34;filter_active\u0026#34; string=\u0026#34;Active\u0026#34; domain=\u0026#34;[(\u0026#39;active\u0026#39;,\u0026#39;=\u0026#39;,True)]\u0026#34; /\u0026gt; \u0026lt;filter name=\u0026#34;filter_inactive\u0026#34; string=\u0026#34;Inactive\u0026#34; domain=\u0026#34;[(\u0026#39;active\u0026#39;,\u0026#39;=\u0026#39;,False)]\u0026#34; /\u0026gt; \u0026lt;/search\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 搜索视图使用了两种元素定义： \u0026lt;field\u0026gt; 和 \u0026lt;filter\u0026gt; 。\n\u0026lt;field\u0026gt; 元素定义在搜索框中输入自动搜索的字段。这里添加了publisher_id自动显示出版商字段的搜索结果。 \u0026lt;filter\u0026gt; 元素添加预定义的过滤条件，用户通过点击来切换。过滤条件使用了Odoo的作用域过滤语法。在第十章 Odoo 15开发之后台视图 - 设计用户界面中将会进一步介绍。\nOdoo 12中的变化\n\u0026lt;filter\u0026gt; 现在要求包含name=\u0026rdquo;\u0026hellip;\u0026ldquo;属性，唯一标识每个定义的过滤器。如果不写，XML验证会失败，模块将无法安装或升级。\n现在图书应用的基本组件（模型和视图层）都有了。接下我们添加业务逻辑层，添加让Check ISBN 按钮生效的代码。\n步骤7：实现业务逻辑层 业务逻辑层编写应用的业务规则，如验证和自动化操作。现在我们来为Check ISBN按钮添加逻辑。通过在library.book模型的 Python 类中编写方法来实现。\n添加业务逻辑 现代 ISBN 包含13位数字，最后一位是由前12位计算所得的检查位。如果digits包含了前12位，Python代码返回相应的检查位：\nponderations = [1, 3] * 6 terms = [a * b for a, b in zip(digits, ponderations)] remain = sum(terms) % 10 check = 10 - remain if remain != 0 else 0 return digits[-1] 对上面的代码进行些许调整，就成为验证函数的核心代码。它应该为class Book(\u0026hellip;) 对象中的一个方法。我们会添加方法检测记录的ISBN，返回True或False，如下：\ndef _check_isbn(self): self.ensure_one() isbn = self.isbn.replace(\u0026#39;-\u0026#39;, \u0026#39;\u0026#39;) # 为保持兼容性 Alan 自行添加 digits = [int(x) for x in isbn if x.isdigit()] if len(digits) == 13: ponderations = [1, 3] * 6 terms = [a * b for a,b in zip(digits[:12], ponderations)] remain = sum(terms) % 10 check = 10 - remain if remain !=0 else 0 return digits[-1] == check 注意这个方法不能直接在表单按钮中直接使用，因为它没有提供结果的视图线索。下面我们会添加另一个方法。\nODOO 13中的变化\n移除了Odoo应用程序接口(API)中的 @api.multi装饰器，无法再使用。注意在此前的Odoo版本可使用这个闭包器，但其实不必。不论加或不加效果一样。\n我们使用Odoo的ValidationError异常告知用户验证的结果，首先需要导入异常类。编辑models/library_book.py Python文件在文件顶部添加，如下：\nfrom odoo.exceptions import ValidationError 然后还是在models/library_book.py文件的Book 类中加入如下代码：\ndef button_check_isbn(self): for book in self: if not book.isbn: raise ValidationError(\u0026#39;Please provide an ISBN for %s\u0026#39; % book.name) if book.isbn and not book._check_isbn(): raise ValidationError(\u0026#39;%s is an invalid ISBN\u0026#39; % book.isbn) return True 这里的self表示一个记录集，我们可以遍历每条记录，执行检测。\n这个方法是用于表单按钮，所以理论上self为单条记录，不需要使用for循环。其实我们在辅助方法 _check_isbn() 做了类似的事。如果使用这种方法，推荐在方法的起始处添加self.ensure_one() ，在self不是单条记录时迟早报错。\n但我们选择了for循环来支持多条记录，让代码可以执行之后可能希望有的多验证功能。\n代码遍历每本选定的图书记录，如果图书的ISBN有值，会检测其有效性。如无效，则向用户抛出警告信息。\n模型方法无需返回任何值，便我们应至少让其返回True。因为并非所有实现了XML远程过程调用(RPC)的客户端都支持None/Null值，那样在方法未返回值时可能会抛出错误。\n此时可更新模块并再次运行测试，添加--test-enable参数来确定测试是否通过。也可以在线测试，进入图书表单分别使用正确和错误的 ISBN点击按钮进行测试。\n图书应用已包含所有首次迭代所需的后台功能了，我在实现了Odoo多层的组件：模型、视图和业务逻辑。但Odoo还支持创建面向外部的页面。下一节中，我们会创建首个Odoo网页。\n步骤8：实现网站用户界面(UI) Odoo 还提供了一个 web 开发框架，用于开发与后台应用深度集成的功能。第一步我们来创建一个显示有效图书列表的简单网页。\n在请求http://my-server/library/books 页面时会进行响应，所以 /library/books是用于实施的 URL端点。\nWeb控制器是负责渲染网页的组件。控制器是http.Controller派生的Python方法。该方法使用 @http.route控制器与一个或多个URL端点绑定。 访问其中任一URL时会执行控制器代码，返回向用户展示的 HTML。通常使用 QWeb 模板引擎渲染HTML。\n添加端点控制器 按惯例控制器代码放在/controllers子目录中。添加控制器，首先编辑library_app/init.py文件，导入controllers子目录如下：\nfrom . import models from . import controllers 然后添加library_app/controllers/init.py文件来让目录可被 Python 导入，并添加一条import语句导入稍后实现控制器代码的main.py Python文件，如下：\nfrom . import main 接下来创建实际的控制器文件library_app/controllers/main.py，并添加如下代码：\nfrom odoo import http class Books(http.Controller): @http.route(\u0026#39;/library/books\u0026#39;, auth=\u0026#39;user\u0026#39;) def list(self, **kwargs): Book = http.request.env[\u0026#39;library.book\u0026#39;] books = Book.search([]) return http.request.render( \u0026#39;library_app.book_list_template\u0026#39;, {\u0026#39;books\u0026#39;:books}) 第一行导入了odoo.http模块，是提供网页相关功能的核心组件。接着我们创建了一个控制器对象类，继承自http.Controller。\n我们为类及其方法选择的名称并无关联。@http.route装饰器才是重要的部分，它声明了所绑定的URL端点，本例为 /books。当前网页使用默认的权限控制，需要用户登录。\n在控制器方法内，我们可以使用http.request.env访问运行环境。我们使用它来获取目录中所有有效图书的记录集。\n最后一步是使用http.request.render() 来处理 library_app.index_template Qweb 模板并生成输出 HTML。可通过字典向模板传值，这里传递了books记录集。\n这时如果重启 Odoo 服务来重载 Python 代码，并访问 /library/books会得到一条服务端错误日志：ValueError: External ID not found in the system: library_app.book_list_template。这是因为我们还没有定义模板。下面就一起来定义模板。\n添加QWeb模板 QWeb模板和其它视图类型一并存储，相应的数据库文件通常放在/views子目录下。我们创建views/book_list_template.xml文件如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;template id=\u0026#34;book_list_template\u0026#34; name=\u0026#34;Book List\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;wrap\u0026#34; class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Books\u0026lt;/h1\u0026gt; \u0026lt;t t-foreach=\u0026#34;books\u0026#34; t-as=\u0026#34;book\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;book.name\u0026#34; /\u0026gt;, \u0026lt;span t-field=\u0026#34;book.date_published\u0026#34; /\u0026gt;, \u0026lt;span t-field=\u0026#34;book.publisher_id\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; \u0026lt;template\u0026gt; 元素用于声明 QWeb 模板，它事实上是一个存储模板的 base 模型 - ir.ui.view记录的快捷方式。模板中包含要使用的 HTML，并使用 Qweb 的特定属性。\nt-foreach用于遍历变量 books变量中的每一项，通过控制器的http.request.render() 调用来获取。t-field属性用于渲染Odoo记录字段的内容。\n和其它XML数据文件一样，QWeb模板数据文件需要在模块声明文件中进行声明，这样才会加载并被使用。因此需要编辑 __manifest__.py文件，添加如下内容：\n\u0026#34;data\u0026#34;: [ \u0026#34;security/library_security.xml\u0026#34;, \u0026#34;security/ir.model.access.csv\u0026#34;, \u0026#34;views/book_view.xml\u0026#34;, \u0026#34;views/library_menu.xml\u0026#34;, \u0026#34;views/book_list_template.xml\u0026#34;, ], 在声明文件中添加了XML文件的声明后，执行模块升级，网页应该就可用了。使用登录了的用户打开http://\u0026lt;my-server\u0026gt;:8069/library/booksURL，应该就会显示可用的图书的简易列表了，如下图所示：\n图3.7：图书列表网页\n这是对Odoo网页功能的快速总览。这些功能会在第十三章 Odoo 15开发之创建网站及门户前端功能中深入讨论。\n快速参考 这里讨论的大部分组件都会在其它章节中讨论，这里提供一个快速参考列表：\n第二章 Odoo 15开发之开发环境准备：有关命令行安装和升级模块 第五章 Odoo 15开发之导入、导出以及模块数据：有关创建XML和CSV数据文件 第六章 Odoo 15开发之模型 - 结构化应用数据：有关模型层，定义模型及字段 第七章 Odoo 15开发之记录集 - 使用模型数据：有关作用域过滤器语法和记录集的操作 第八章 Odoo 15开发之业务逻辑 - 业务流程的支持：有关Python方法业务逻辑 第十章 Odoo 15开发之后台视图 - 设计用户界面：有关视图，包含窗口动作、菜单项、表单、列表和搜索 第十三章 Odoo 15开发之创建网站及门户前端功能：有关网页控制器和QWeb语法 其它地方没讲解的是访问权限，这里我们对这些组件提供一个快速参考。\n访问权限 内部的系统模型列举如下：\nres.groups: groups相关字段： name, implied_ids, users res.users: users相关字段：name, groups_id ir.model.access: 访问控制相关字段： name, model_id, group_id, perm_read, perm_write, perm_create, perm_unlink ir.access.rule: 记录规则相关字段： name, model_id, groups, domain_force 大部分相关权限组的XML ID列举如下：\nbase.group_user: internal user—任意后台用户 base.group_system: Settings—管理员属于这个分组 base.group_no_one: technical feature, 通常用于对用户隐藏功能 base.group_public: Public, 用于让对网站匿名用户开放 由Odoo提供的默认用户的XML ID列举如下：\nbase.user_root: 系统超级用户，也称为OdooBot base.user_admin: 默认用户，默认名为Administrator base.default_user: 后台新用户使用的模板。这是一个模板并且不可使用，但可以复制它来新建用户 base.default_public user: 用于新建门户用户的模板 小结 本文中我们从0开始创建了一个新模块，了解了模块中常用的组件：模型、访问权限、菜单、三个基础视图类型（表单视图、列表视图和搜索视图）以及模型方法中的业务逻辑。我们还学习了如何使用网页控制器和QWeb模板创建网页。\n在学习过程中，我们熟悉了模块开发流程，包括模块升级和应用服务重启来使修改在 Odoo 中生效。\n不要忘记在添加模型字段时需要进行升级。修改含声明在内的 Python 文件需要重启服务。修改XML或CSV文件需进行升级；一旦不确定，同时进行重启服务和升级模块操作。\n我们已经学习创建 Odoo 应用的基本元素和步骤，但大多数情况下，我们的模块都是扩展已有应用添加功能，我们将在下一篇文章中一起学习。\n扩展阅读 本文中涉及到的所有课题在后续章节都会深入介绍。\n官方文档中的相关资源可以作为补充阅读：\n创建模块课程 Odoo 指南中的一系列编码规范和模块开发指南 Odoo 社区联盟(OCA)指南是指导 Odoo 开发最佳实践很好的资源 学习 Python 对 Odoo 开发来说也非常重要，在Packt 书录中有一些很好的 Python 图书，如Learn Python Programming – Second Edition。\n注：本博客新增精通Python自动化脚本-运维人员宝典可用于深入Python 脚本的学习。\n"
},
{
	"uri": "/odoo/4/",
	"title": "第四章 Odoo 15开发之模块继承",
	"tags": [],
	"description": "",
	"content": "Odoo 的一项强大之处是无需直接修改所扩展模块的代码即可添加功能。这都归功于与自身代码组件相独立的功能继承。对模块的扩展可通过继承机制实现，以已有对象的修改层的形式。这些修改可以发生在每个层面，包括模型、视图和业务逻辑层面。我们不是直接修改原有模块，而是新建一个模块，采用所要做的修改在已有模块上新增一层。\n上一章讲解了如何从零开始创建应用。本章中我们将学习如何创建继承自已有应用或模块的模块，并使用原有的内核或社区功能。\n为此，我们会讲解如下内容：\n学习项目-扩展图书应用 对已有模型新增字段 使用经典的in-place继承来扩展模型 其它模型继承机制 视图和数据继承 网页继承 学习完本章后，读者可以对已有Odoo应用创建继承模块。可以对应用的任一组件做出修改：模型、视图、业务逻辑代码、网页控制器和网页模板。\n开发准备 本文要求可通过命令行来启动 Odoo 服务。\n代码将在第三章 Odoo 15开发之创建第一个 Odoo 应用的基础上进行修改。通过该篇的学习我们已在插件路径添加了代码并在数据安装了library_app模块。\n本章对项目新增library_member插件模块。相应的代码请见GitHub 仓库的ch04目录。\n学习项目-扩展图书馆应用 在第三章 Odoo 15开发之创建第一个 Odoo 应用中我们创建了一个图书应用的初始模块，可供查看图书清单。现在我们要对图书应用进行扩展添加图书会员并允许他们借书。这需要创建一个扩展模块library_member。\n我们要提供如下的功能：\n图书可进行能否借阅的控制。该信息要在图书表单和网站的目录页面显示。 一些图书会员数据，以及图书会员卡号和个人数据，如姓名、地址和email。 应在借阅表单提供会员发消息和社交功能，包括计划活动微件，使协作更为流畅。 后面我们会引入一个功能让会员可从图书馆借书，但这不在当前的讨论范畴。在后面的几章中会逐步展开。\n图书 以下是要对图书所要做的技术修改的汇总：\n添加一个Is Available? 字段。目前通过手动管理，以后会自动化。 扩展 ISBN 验证逻辑来同时支持10位数的ISBN。 扩展图书目录页来标识不可借阅图书并允许用户过滤出可借图书 会员 以下是要对图书会员所要做的技术修改的汇总：\n添加一个新模型来存储姓名、卡号和 Email、地址一类的联系信息 添加社交讨论和计划活动功能 首先在library_app同级目录创建一个library_member目录作为扩展模块，并在其中添加两个文件，一个__init__.py空文件和一个包含如下内容的__manifest__.py文件：\n{ \u0026#39;name\u0026#39;: \u0026#39;Library Members\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Manage people who will be able to borrow books.\u0026#39;, \u0026#39;author\u0026#39;: \u0026#39;Alan Hou\u0026#39;, \u0026#39;depends\u0026#39;: [\u0026#39;library_app\u0026#39;], \u0026#39;application\u0026#39;: False, } 接着我们就可以开发功能了。第一个任务是常用的简单需求：对已有模型新增字段。这正好是介绍Odoo继承机制的好机会。\n对已有模型新增字段 第一步我们来为Book模型添加is_available布尔型字段。当前它只是一个简单的可编辑字段，但在之后我们会将其变成自动根据所借阅和归还的图书来赋值。\n要继承已有模型，需要在 Python 类中添加一个 _inherit 属性来标明所继承的模型。新类继承父 Odoo 模型的所有功能，仅需在其中声明要做的修改。可以认为这类继承是对已有模型的引用并在插入了一些修改。\n通过继承为模型插入新字段 继承模型是通过 Python类以及 Odoo自有的继承机制，使用 _inherit 类属性进行声明。 _inherit属性标明所继承的模型。所声明的调用抓取父 Odoo 模型的所有功能，仅需声明要做修改的部分。\n编码指南推荐为每个模型创建一个 Python 文件，因此我们添加library_member/models/library_book.py文件来继承原模型。首先创建__init__.py文件来导入该文件：\n1、添加library_member/__init__.py文件来导入 models 子文件夹\nfrom . import models 2、添加library_member/models/__init__.py文件，导入models子文件夹中中的文件：\nfrom . import library_book 3、创建library_member/models/library_book.py文件来继承library.book模型：\nfrom odoo import fields, models class Book(models.Model): _inherit = \u0026#39;library.book\u0026#39; is_available = fields.Boolean(\u0026#39;Is Available?\u0026#39;) 此处我们使用了 _inherit类属性来声明所继承模型。注意我们并没有使用到其它类属性，连 _name 也没使用。除非想要做出修改，否则不需要使用这些属性。\n小贴士： _name是模型标识符，如果修改会发生什么呢？其实你可以修改，这时它会创建所继承模型的拷贝，成为一个新模型。这叫作原型继承，本文后面通过原型拷贝模型一节会讨论。\n可以把它看成是引用了中央仓库中的一个模型定义，然后在其内进行修改。修改包含添加字段、修改已有字段、修改模型类属性或添加带有新业务逻辑的方法。\n要在数据表中添加新增模型字段，必须要先安装插件模块。如果一切顺利的话，就可以通过Technical \u0026gt; Database Structure \u0026gt; Models菜单查看到library.book模型中新增了这一字段。\n对表单视图添加字段 表单、列表和搜索视图通过XML数据结构定义。需要一种修改 XML 的方式来继承视图。也即要定位到 XML 元素然后对该处进行修改。\n所继承视图的 XML 数据记录和普通视图中相似，多了一个 inherit_id属性来引用所要继承的视图。\n下面我们继承图书视图并添加is_available字段。\n首先要查找待继承的视图的XML ID.通过Settings \u0026gt; Technical \u0026gt; User Interface \u0026gt; Views菜单来查看。图书表单的XML ID是library_app.view_form_book。\n然后还要找到要插入修改的XML元素。我们选择在ISBN字段之后添加Is Available? 字段。通常通过name 属性定位元素。此处为 \u0026lt;field name=\u0026quot;isbn\u0026quot; /\u0026gt; 。\n我们添加XML文件，即views/book_view.xml来继承 Partner 视图，内容如下：\n\u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;view_form_book_extend\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Book: add Is Available? field\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.book\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;inherit_id\u0026#34; ref=\u0026#34;library_app.view_form_book\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;isbn\u0026#34; position=\u0026#34;after\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;is_available\u0026#34; /\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 以上代码中，我们高亮显示了继承相关的元素。inherit_id记录字段通过 ref 属性指向视图的外部标识符定位所继承的视图。\narch包含所声明扩展点处使用的元素，一个带有name=\u0026ldquo;isbn\u0026rdquo; 的 \u0026lt;field\u0026gt; 元素，同时包含position=\u0026ldquo;after\u0026rdquo; 来声明位置。在扩展元素内，使用XML来添加is_available字段。\n创建完继承之后图书表单（在声明文件中添加该视图文件并升级插件）如下图：\n图4.1： 添加了Is Available?字段后的图书表单\n我们学习了继承的基础知识，对模型层和视图层新增了一个字段。接下来，我们将学习我们所使用的模型继承方法，即经典继承。\n使用经典的in-place继承来扩展模型 可以把经典模型继承看作是一个插入(in-place)扩展。在声明了具有 _inherit属性的Python类时，它获取到了对相应模型定义的引用，然后对其添加扩展。模型定义存储在Odoo模型仓库中，我们可对其做进一步的修改。\n下面我们学习如何在常用的继承用例中使用经典继承：修改已有字段的属性并扩展Python方法来添加或变更业务逻辑。\n增量修改已有字段 继承模型时，可对已有字段做出增量修改。也就是只需要定义要修改或添加的属性。\n我们对library_app模块中所创建的Book模型做两处修改：\n为isbn字段添加一条提示，说明同时支持10位数和13位数的 ISBN，稍后会实现该功能 为publisher_id字段添加数据库索引，以提升搜索效率 编辑library_member/models/library_book.py文件，并在library.book 模型中添加如下代码：\nclass Book(models.Model): ... isbn = fields.Char(help=\u0026#34;Use a valid ISBN-13 or ISBN-10.\u0026#34;) publisher_id = fields.Many2one(index=True) 这会对字段的指定属性作出修改，未指定的属性保持不变。\n升级模块，进入图书表单，将鼠标悬停在 ISBN 字段上，就可以看到所添加的提示信息了。index=True这一修改的效果不太容易发现，通过开发者工具菜单的View Fields选项或Settings \u0026gt; Technical \u0026gt; Database Structure \u0026gt; Models菜单下的字段定义中可进行查看。\n图4.2： 出版社字段启用了索引\n继承 Python 方法对业务逻辑添加功能 Python 方法中编写的业务逻辑也可以被继承。Odoo 借用了 Python 已有的父类行为的对象继承机制。\n举个实际的例子，我们将扩展图书 ISBN 的验证逻辑。在图书应用中仅能验证现代的13位ISBN，但老一些的图书可能只有10位数的 ISBN。我们继承 _check_isbn() 方法来完成这种情况的验证。\n在library_member/models/library_book.py文件中添加如下代码：\nfrom odoo import api, fields, models class Book(models.Model): ... def _check_isbn(self): self.ensure_one() isbn = self.isbn.replace(\u0026#39;-\u0026#39;, \u0026#39;\u0026#39;) digits = [int(x) for x in isbn if x.isdigit()] if len(digits) == 10: ponderators = [1, 2, 3, 4, 5, 6, 7, 8, 9] total = sum(a * b for a, b in zip(digits[:9], ponderators)) check = total % 11 return digits[-1] == check else: return super()._check_isbn() 在继承类中继承方法，我们要使用相同方法名重新定义该方法，本例中即为 _check_isbn() 。这个方法使用 super()来调用父类已实现的方法。本例中对应的代码为super()._check_isbn() 。\n在方法继承中，我们在调用父类的super() 的前添加了自己的逻辑。这个方法验证ISBN是否为10位数。若是则执行所添加的对10位ISBN的验证。否则进入原有的13位验证逻辑。\n如果想要进行测试或是书写测试用例。这里有一个10位ISBN的示例：威廉·戈尔丁所著《蝇王》的原始ISBN为0-571-05686-5。\nOdoo 11中的变化 在Odoo 11中，所使用的Python版本由2.7变为3.5 或更新版本。Python 3做出了很大的改版，不完全兼容Python 2。尤其是在Python 3中简化了super() 的语法。之前使用Python 2的Odoo版本中，super() 需要传入两个参数：类名和self；例如super(Book, self)._check_isbn() 。\n经典继承是最常用的继承机制。但Odoo还提供了其它的继承方式，用于别的场景。接下来我们一同学习。\n其它模型继承机制 前面我们介绍了经典继承，可以看成是一种原地修改的扩展。这是最常用的一种方式，但Odoo框架还支持适用其它场景下几种继承机制。\n分别是代理继承、型继承以及使用mixin：\n代理继承在继承的模型中嵌入另一个模型。例如，User记录嵌入了Partner记录，因而User记录带有Partner记录的所有字段，以及User记录自身的字段。代理继承使用 _inherits属性。 原型继承拷贝所继承模型的功能，创建一个新模型，有自己的数据表和数据。原型继承不常使用，在Odoo内置的插件模块中未有应用。使用 _inherit设置所要拷贝的模型， _name属性为新创建模型的标识符。 Mixin类是实现在其它模型中广泛复用功能的抽象模型。有点像是容器，可添加到其它模型中，但不单独使用。比如mail.thread 模型由mail插件模型所提供。它实现了一个聊天窗口和发送消功能，在Odoo的多个模型中均有使用，如Partners和销售报价。mixin类通过Models.abstract构建，而不是Models.model，通过 _inherit进行使用。 下面几节会进行深入的讲解。\n使用代理继承内嵌模型 使用代理继承无需复制数据即可在数据库中复用数据结构。它在继承模型中嵌入所代理模型实例。\n注： 从技术角度严格地说，代理继承并不是真的对象继承，而是一种对象组合，将一个对象的一些功能代理至另一个对象，或由另一个对象提供一些功能。\n关于代理继承的要点：\n创建新模型记录也会创建并链接所代理模型记录。 继承模型中不存在的代理模型字段可进行读和写操作，类似关联的计算字段。 举个例子，对于内核 User模型，每条记录包含一条 Partner 记录，因此包含 Partner 中的所有字段以及User自身的一些字段。\n在图书项目中，我们要添加一个图书会员模型。会员有会员卡并通过会员卡借阅读书。会员主数据应包含卡号，以及一些个信息，如email和地址。Partner 模型已包含联系和地址信息，所以最好是复用，而不去创建重复的数据结构。\n按如下步骤使用代理继承在图书会员模型中加入Partner字段：\n需要导入实现进程的Python文件。编辑 library_member/model/init.py添加如下高亮的代码：\nfrom . import library_book from . import library_member 然后添加描述新的图书会员模型的Python文件：library_member/models/library_member.py，其中包含如下代码：\nfrom odoo import fields, models class Member(models.Model): _name = \u0026#39;library.member\u0026#39; _description = \u0026#39;Library Member\u0026#39; card_number = fields.Char() partner_id = fields.Many2one( \u0026#39;res.partner\u0026#39;, delegate=True, ondelete=\u0026#39;cascade\u0026#39;, required=True) 通过代理继承，library.member 中嵌入了所继承的模型：res.partner，因此在新建会员记录时，会自动创建一个关联的 Partner并通过partner_id字段引用。\n透过代理机制，嵌套模型的所有字段像父模型字段一样自动可用。本例中，会员模型可使用 Partner 中的所有字段，如 name, address和 email，以及会员自身的独有字段，如card_number。底层Partner 字段存储于关联的 Partner 记录中，没有重复的数据结构。\n代理继承仅用在数据层面，不适用于逻辑层。没有继承所继承模型的任意方法。但仍可使用点号运算符来访问，也称为点号标记，用于访问对象属性。例如，会员模型中partner_id.open_parent() 运行嵌套Partner记录的open_parent() 方法。\n代理继承还有一种替代语法，使用 _inherits模型属性。这来自Odoo 8之前的老API，但仍在广泛使用。和上述代码相同效果的图书模型代码如下：\nfrom odoo import fields, models class Member(models.Model): _name = \u0026#34;library.member\u0026#34; _description = \u0026#34;Library Member\u0026#34; _inherits = {\u0026#34;res.partner\u0026#34;: \u0026#34;partner_id\u0026#34;} card_number = fields.Char() partner_id = fields.Many2one( \u0026#34;res.partner\u0026#34;, ondelete=\u0026#34;cascade\u0026#34;, required=True) 完成新模型的添加，还需要完成几步：添加权限ACL、菜单和一些视图。\n添加权限ACL，创建library_member/security/ir.model.access.csv文件并加入如下代码来：\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink access_member_user,Member User Access,model_library_member,library_app.library_group_user,1,1,1,0 access_member_manager,Member Manager Access,model_library_member,library_app.library_group_manager,1,1,1,1 添加菜单项，创建library_member/views/library_menu.xml文件并加入如下代码：\n\u0026lt;odoo\u0026gt; \u0026lt;act_window id=\u0026#34;action_library_member\u0026#34; name=\u0026#34;Library Members\u0026#34; res_model=\u0026#34;library.member\u0026#34; view_mode=\u0026#34;tree,form\u0026#34; /\u0026gt; \u0026lt;menuitem id=\u0026#34;menu_library_member\u0026#34; action=\u0026#34;action_library_member\u0026#34; parent=\u0026#34;library_app.menu_library\u0026#34; /\u0026gt; \u0026lt;/odoo\u0026gt; 添加视图，创建library_member/views/member_view.xml文件并加入如下代码：\n\u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;view_form_member\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Member Form View\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.member\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;card_number\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id=\u0026#34;view_tree_member\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Member List View\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.member\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;tree\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;card_number\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 最后，编辑manifest文件来声明这三个新文件：\n\u0026#34;data\u0026#34;: [ \u0026#34;security/ir.model.access.csv\u0026#34;, \u0026#34;views/book_view.xml\u0026#34;, \u0026#34;views/member_view.xml\u0026#34;, \u0026#34;views/library_menu.xml\u0026#34; ], 如果代码编写正确，升级模块后即可使用新的图书会员模型了。\n使用原型继承拷贝功能 经典继承使用 _inherit属性扩展模型。因其未修改 _name属性，可对该模型执行有效的原地变更。\n如果使用 _inherit的同时修改了 _name属性，就会获得一具所继承模型的副本。这时新模型就会获得仅针对其自身的功能，不会添加到父模型中。副本模型与父模型相独立，不受父模型修改的影响，它有自有的数据表和数据。官方文档将这种继承称为原型继承。\n在实际开发中，使用 _inherit进行模型拷贝没太大用处。一般会更偏好代理继承，因为不拷贝就可复用数据结构。\n在对多个父模型继承时， _inherit的值就不单个名称，而是一个模型名列表。\n这可用于将多个模型混合加入一个模型。这样我们多次使用同一模型的功能。抽象mixin类广泛使用了这种模式。在下一节中进行讨论。\n使用 mixin类复用模型功能 将 _inherit属性赋值为一个模型名列表，会继承这些模型的功能。这大多时候使用的是mixin类。\nmixin类像是一些功能的容器，可供复用。它们实现通用功能，可添加至其它模型中。一般不直接单独使用。因此mixin类是基于models.AbstractModel的抽象模型，不像models.Model那样有实际数据表。\nOdoo标准插件提供了一些有用的mixin。在代码中搜索models.AbstractModel可以找到它们。值的一提的，也可能最常用的是以下两个mixin，由讨论（Discuss：mail插件模型）应用提供：\nmail.thread提供在许多文档表单下方或右侧的消息面板功能(也称为聊天器-chatter)，以及消息和通知相关逻辑。\nmail.activity.mixin提供用于定义和规划待办任务的活动（activities）功能，也通过聊天器讨论微件对外暴露。\nOdoo 11中的变化\nactivities mixin是在Odoo 11中引入的功能，在更早版本中无法使用。\n聊天窗口和活动都是广泛使用的功能，在下一节中，我们会演示如何进行添加。\n对模型添加消息聊天窗口和计划活动 我们来为图书会员模型添加消息聊天和活动mixin。操作步骤如下：\n添加提供mixin的插件模型依赖，即mail。 继承mail.thread和mail.activity.mixin这两个mixin类 在表单视图中添加字段。 我们来详细操作以上步骤：\n编辑 __manifest__.py文件添加对mail插件的依赖：\n\u0026#34;depends\u0026#34;: [\u0026#34;library_app\u0026#34;, \u0026#34;mail\u0026#34;], 编辑library_member/models/library_member.py 文件继承mixin类，添加如下高亮的代码：\nclass Member(models.Model): _name = \u0026#39;library.member\u0026#39; _description = \u0026#39;Library Member\u0026#39; _inherit = [\u0026#34;mail.thread\u0026#34;, \u0026#34;mail.activity.mixin\u0026#34;] 通过添加这行代码，我们的模型就会包含这些 mixin 的所有字段和方法。\n小贴士：本例中，mixin添加到了新创建的模型中。如果要将它们添加到在其它模块中创建的已有模型中，那么父模型也应出现在继承列表中，如： _inherit = [\u0026ldquo;library.member\u0026rdquo;, \u0026ldquo;mail.thread\u0026rdquo;, \u0026ldquo;mail.activity.mixin\u0026rdquo;] 。\n最后要在图书会员表单视图中添加相关字段。编辑library_member/views/member_view.xml文件添加如下高亮代码：\n\u0026lt;record id=\u0026#34;view_form_member\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Member Form View\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.member\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;email\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;card_number\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;!-- mail mixin fields --\u0026gt; \u0026lt;div class=\u0026#34;oe_chatter\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;message_follower_ids\u0026#34; widget=\u0026#34;mail_followers\u0026#34;/\u0026gt; \u0026lt;field name=\u0026#34;activity_ids\u0026#34; widget=\u0026#34;mail_activity\u0026#34;/\u0026gt; \u0026lt;field name=\u0026#34;message_ids\u0026#34; widget=\u0026#34;mail_thread\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 可以看到，mail模块不仅提供了关注者、计划活动和消息的字段，还为它们提供了具体的网页客户端微件，这里都使用了。\n升级模块后，图书会员视图应当如下所示：\n图4.3： 图书会员表单视图\n注意mixin本身不会对访问权限包括记录规则造成任何修改，有内置的记录规则 ，限制每个用户访问的记录。举个例子，如果希望用户仅浏览关注的人的记录，必须明确添加这条记录规则。\nmail.thread模型包含显示关注者Partner的字段，名为message_partner_ids。实现关注者访问规则需要添加一条记录规则 ，加上类似 [(\u0026lsquo;message_partner_ids\u0026rsquo;, \u0026lsquo;in\u0026rsquo;, [user.partner_id.id])] 条件的作用域表达式。\n至此，我们学习了如何在模型和逻辑层扩展模块。下一步学习视图的继承来展示模型层的修改。\n视图和数据继承 视图和其它数据组件也可通过模块继承来修改。就视图而言，通常是添加功能。视图的展示结构通过XML定义。对XML的继承，我们需要定位到所要继承的节点，然后声明在该处执行的操作，如插入XML元素。\n其它的数据元素表现为数据库中写入的记录。继承模块对在其上写入，来修改一些值。\n视图继承 视图使用XML定义，存储在结构字段arch中。继承视图，我们需要定位到所要继承的节点，然后声明所做的修改，如添加XML元素。\nOdoo自带继承XML的简化标记，使用希望匹配的XML标签，如 \u0026lt;field\u0026gt; ，借由一个或多个独特属性进行匹配，如name。然后必须要添加position属性来声明修改的类型。\n回到本章之前在isbn字段后添加内容的例子，可以使用如下代码：\n\u0026lt;field name=\u0026#34;isbn\u0026#34; position=\u0026#34;after\u0026#34;\u0026gt; \u0026lt;!-- 此处添加修改内容 --\u0026gt; \u0026lt;/field\u0026gt; 除string 属性外的任意 XML 元素和属性均可用于选取继承点使用的节点，字符串属性会在生成视图期间翻译成用户所使用的语言，因此不能作为节点选择器。\nℹ️在9.0以前，string 属性(显示标签文本）也可作为继承定位符。在9.0之后则不再允许。这一限制主要源自这些字符串的语言翻译机制。\n使用position属性声明继承操作。可允许多种操作，如下：\ninside（默认值）：在所选节点内添加内容，这一节点应是\u0026lt;group\u0026gt;或\u0026lt;page\u0026gt;一类的容器\nafter：在选定节点之后向父节点添加内容\nbefore：在选定节点之前向父节点添加内容\nreplace：替换所选节点。若使用空内容则会删除该元素。Odoo 10开始还允许使用其它标记来包裹元素，通过在内容中使用 $0来表示被替换的元素，如 \u0026lt;field name=\u0026quot;name\u0026quot; position=\u0026quot;replace\u0026quot;\u0026gt;\u0026lt;h1\u0026gt;$0\u0026lt;/h1\u0026gt;\u0026lt;/field\u0026gt; 。\nattributes：修改匹配元素的属性值。内容中应包含带有一个或多个 \u0026lt;attribute name=\u0026quot;attr-name\u0026quot;\u0026gt;value\u0026lt;attribute\u0026gt; 元素。如\u0026lt;attribute name=\u0026quot;invisible\u0026quot;\u0026gt;True\u0026lt;/attribute\u0026gt;。若不带内容体，如\u0026lt;attribute name=\u0026quot;invisible\u0026quot; /\u0026gt;，则会从所选元素中删除属性。\n小贴士： 虽然position=\u0026ldquo;replace\u0026quot;可删除 XML 元素，但应避免这么做。这么做会其它其它依赖使用所删除节点作为扩展点插件元素产生崩溃。一个替代方案是，保留元素让其不可见。\n将XML节点迁移到其它地方 除了attributes操作，上述定位符可与带position=\u0026ldquo;move\u0026rdquo; 的子元素合并。效果是将子定位符目标节点移到父定位符的目标位置。\nOdoo 12中的变化 position=\u0026ldquo;move\u0026quot;子定位符是 Odoo 12中新增的，之前的版本中没有。\n下例为将my_field从当前位置移动到target_field之后。\n\u0026lt;field name=\u0026#34;target_field\u0026#34; position=\u0026#34;after\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;my_field\u0026#34; position=\u0026#34;move\u0026#34;/\u0026gt; \u0026lt;/field\u0026gt; 其它视图类型，如列表和搜索视图，也有 arch 字段，可以表单视图同样的方式进行继承。\n使用 XPath 选取继承点 有时可能没有带唯一值的属性来用作 XML 节点选择器。在所选元素没有 name 属性时可能出现这一情况，如\u0026lt;group\u0026gt;、\u0026lt;notebook\u0026gt;或\u0026lt;page\u0026gt;视图元素。另外就是有多个带有相同 name 属性的元素，比如在看板 QWeb 视图中相同字段可能在同一 XML 模板中被多次包含。\n在这些情况下我们就需要更高级的方式来定位待扩展 XML 元素。定位 XML 中元素的一种自然方式是 XPath 表达式。\n以上一章中定义的图书表单视图为例，定位\u0026lt;field name=\u0026quot;isbn\u0026quot;\u0026gt;元素的 XPath 表达式是 //field[@name]=\u0026lsquo;isbn\u0026rsquo; 。该表达式查找 name 属性等于 isbn 的\u0026lt;field\u0026gt;元素。\n前一部分对图书表单视图继承的 XPath 写法是：\n\u0026lt;xpath expr=\u0026#34;//field[@name=\u0026#39;isbn\u0026#39;]\u0026#34; position=\u0026#34;after\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;is_available\u0026#34; /\u0026gt; \u0026lt;/xpath\u0026gt; XPath 语法的更多知识请见 Python 官方文档。\n如果 XPath 表达式匹配到了多个元素，仅会选取第一个作为扩展目标。所以表达式应越精确越好，使用唯一属性。name 属性最易于确保找到精确元素作为扩展点。因此在创建视图 XML 元素时添加唯一标识符就非常重要。\n修改已有数据 普通数据记录也可被继承，在实际应用，通常是重写已有值。这时我们只需定位到需写入的记录，以及更新的字段和值。无需使用XPath表达式，因为我们并不是像对视图那样修改XML arch结构。\n\u0026lt;record id=\u0026quot;x\u0026quot; model=\u0026quot;y\u0026quot;\u0026gt; 数据加载元素执行对 y 模型的插入或更新操作：若不存在记录 x，则创建，否则被更新/覆盖。\n其它模块中的记录可通过\u0026lt;module\u0026gt;.\u0026lt;identifier\u0026gt;全局标识符访问，因此一个模块可以更新其它模块创建的记录。\n小贴士： 点号( . )是保留符号，用于分隔模块名和对象标识符。所以在标识符名中不能使用点号，而应使用下划线( _ ) 字符。\n举个例子，我们将 User 安全组的名称修改为 Librarian。对应修改library_app模块中创建的记录，使用的是library_app.library_group_user标识符。\n添加library_member/security/library_security.xml并加入如下代码：\n\u0026lt;odoo\u0026gt; \u0026lt;!-- 修改权限组名称 --\u0026gt; \u0026lt;record id=\u0026#34;library_app.library_group_user\u0026#34; model=\u0026#34;res.groups\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Librarian\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 这里我们使用了一个 \u0026lt;record\u0026gt; 元素，仅写了 name 字段。可以认为这是对该字段的一次写操作。\n小贴士： 使用 \u0026lt;record\u0026gt; 元素时，可以选择要执行写操作的字段，但对简写元素则并非如此，如 \u0026lt;menuitem\u0026gt; 和 \u0026lt;act_window\u0026gt; 。它们需要提供所有的属性，漏写任何一个都会将对应字段置为空值。但可使用 \u0026lt;record\u0026gt; 为原本通过简写元素创建的字段设置值。\n刻在声明文件data 中加入security/library_security.xml。然后更新模块即可看到用户组名称的修改。\n继承视图让我们可以对后台展示层做出修改。但对前台网页也可做同样的操作。在下一节中进行讲解。\n网页继承 可扩展性是Odoo框架的一个关键设计选择，Odoo的网页组件同样可进行继承。所以可对Odoo网页控制器和模板进行扩展。\n第三章 Odoo 15开发之创建第一个 Odoo 应用中所创建的图书应用中，有一个图书目录页面，可进行改进。\n我们会对其进行扩展来使用在图书会员模块中添加的图书可用性：\n在控制器端添加对查询参数的支持，访问 /library/books?available=1过滤出可借阅图书 在模板端，指定不可借阅图书 先来继承网页控制器。\n继承网页控制器 网页控制器处理网页请求并渲染页面返回响应。应关注展示逻辑，不处理业务逻辑，业务逻辑在模型方法中处理。\n支持参数或URL路由属于网页展示部分，适合用网页控制器处理。\n这里会扩展 /library/books端点来支持查询字符串参数available=1，稍后用于过滤图书目录来仅显示可借阅的图书。\n要继承已有控制器，需导入创建它的原始对象，基于它声明一个Python类，然后实现包含新增逻辑的类方法，\n在library_member/controllers/main.py文件中添加继承控制器的代码如下：\nfrom odoo import http from odoo.addons.library_app.controllers.main import Books class BookExtended(Books): @http.route() def list(self, **kwargs): response = super().list(**kwargs) if kwargs.get(\u0026#39;available\u0026#39;): Book = http.request.env[\u0026#39;library.book\u0026#39;] books = Book.search([(\u0026#39;is_available\u0026#39;, \u0026#39;=\u0026#39;, True)]) response.qcontext[\u0026#39;books\u0026#39;] = books return response 按如下步骤添加控制器代码：\n添加 library_member/controllers/main.py文件，确保其包含上面的代码。\n在控制器子目录中添加library_member/init.py文件让新增的Python文件在模块中可导入：\nfrom . import models from . import controllers 在library_member/controllers/init.py中添加如下代码：\nfrom . import main 之后，访问http://localhost:8069/library/books?available=1，应该会只展示勾选了Is Available? 字段的图书。\n下面我们来回顾控制器扩展代码，理解其实现原理。\n所要继承的控制器Books，最初在library_app模块的controllers/main.py文件中声明。因此需要导入odoo.addons.library_app.controllers.main来引用该文件。\n这与模型不同，模型有一个中央仓库可以获取任意模型类的引用，如self.env[\u0026rsquo;library.book\u0026rsquo;] ，无需知识具体实现它的文件。控制器没有这样的仓库，需要知道是哪个模块和文件实现了控制器，方可对其扩展。\n然后基于原来的Books声明了一个BooksExtended类。类名不具关联性，仅是继承和扩展原类的一个载体。\n再后我们(重)定义了一个待继承的控制器方法，本例为list() 。它至少需要一个简单的 @http.route() 装饰器来保持路由为活跃状态。如果不带参数，将会保留父类中定义的路由。但也可以为 @http.route() 装饰器添加参数，来重新定义或替换类路由。\nlist() 方法带有 ****kwargs参数，捕获所有kwargs**字典中的参数。这些是 URL 中给定的参数，如 ?available=1。\n小贴士： ****kwargs**参数纳入所有可能无需使用的给定参数，但会让我们的URL可以兼容预期外的URL参数。如若选择指定具体参数，在设置了其它参数时，在调用相应控制器时会立刻失败，返回一条内部错误。\nlist()方法的代码一开始使用了 super() 来调用相应父类方法。返回由父类方法计算的Response对象，包括待渲染的属性和模块，template，以及渲染时使用的上下文qcontext。但HTML尚待生成。仅在控制器完成运行时才生成HTML。因此在完成最终渲染前还可以修改Response属性。\n该方法检测kwargs中available键的非空值。如果找到，会过滤掉不可借阅图书，在记录集中更新qcontext。因此，在控制器处理完成时，HTML会使用更新后的图书记录进行渲染，仅包含可借阅图书。\n继承 QWeb 模板 网页模板为XML文档，和其它Odoo视图类型一样可以使用选择器表达式，像我们在其实视图类型如表单中使用那样。QWeb模板通常更为复杂，因糨会包含更多的HTML元素，因此大多数据时候会使用更多样的XPath表达式。\n要修改网页的实际展示，就需要继承所使用的 QWeb 模板。我们将继承library_app.book_list_template来展示更多有关不可借阅图书的信息。\nQWeb继承是一个 \u0026lt;template\u0026gt; 元素，使用额外inherit_id属性来标识待继承的QWeb模板。本例中为library_app.book_list_template。\n执行如下步骤：\n添加library_member/views/book_list_template.xml文件并加入如下代码：\n\u0026lt;odoo\u0026gt; \u0026lt;template id=\u0026#34;book_list_extended\u0026#34; name=\u0026#34;Extended Book List\u0026#34; inherit_id=\u0026#34;library_app.book_list_template\u0026#34;\u0026gt; \u0026lt;xpath expr=\u0026#34;//span[@t-field=\u0026#39;book.publisher_id\u0026#39;]\u0026#34; position=\u0026#34;after\u0026#34;\u0026gt; \u0026lt;t t-if=\u0026#34;not book.is_available\u0026#34;\u0026gt; \u0026lt;b\u0026gt;(Not Available)\u0026lt;/b\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; 以下的示例使用了xpath标记。注意在本例我们也可以使用等效的简化标记，即 \u0026lt;span t-field=\u0026quot;book.publisher_id\u0026quot; position=after\u0026gt;\n在插件声明文件(即library_member/manifest.py)中声明新增的数据文件：\n\u0026#34;data\u0026#34;: [ \u0026#34;security/library_security.xml\u0026#34;, \u0026#34;security/ir.model.access.csv\u0026#34;, \u0026#34;views/book_view.xml\u0026#34;, \u0026#34;views/member_view.xml\u0026#34;, \u0026#34;views/library_menu.xml\u0026#34;, \u0026#34;views/book_list_template.xml\u0026#34;, ], 此时访问http://localhost:8069/library/books应该会对不可借阅图书显示额外的视觉信息(not available)。网页长下面这样：\n图4.4： 包含可借阅信息的图书列表网页\n至此完结了如何继承从数据模型至用户界面元素各种类型Odoo组件的回顾。\n小结 扩展性是 Odoo 框架的一个重要功能。我们可以构建插件模块，对Odoo中需要在不同层实现功能的已有插件修改或添加功能。通过继承，我们的项目可以按整洁、模块化的方式复用和扩展第三方插件模块。\n模型层中，我们使用 _inherit模型属性来引用已有模型，然后在原处执行修改。模型内的字段对象还支持增量定义，这样可对已有字段重新声明，仅修改属性。\n其它的模型继承机制允许我们复用数据结构和业务逻辑。代理继承通过多对一关联字段上的delegate=True属性（或老式的 inherits 模型属性），来让关联模型的所有字段可用，并复用它们的数据结构。原型继承使用 _inherit属性加其它模型，来复制这些模型的功能（数据结构定义和方法），并可使用抽象 mixin 类，提供一系列像文档讨论消息和关注者的可复用功能。\n视图层中，视图结构通过 XML 定义，（使用 XPath 或 Odoo 简化语法）定位 XML 元素来进行继承及添加 XML代码段。其它由模块创建的记录也可由继承模块修改，仅需引用对应的完整 XML ID 并在相应的字段上执行写操作。\n业务逻辑层中，可使用模型继承相同的机制来进行继承，以及重新声明要继承的方法。在方法内，Python 的super() 函数可用于调用所继承方法的代码，添加代码可在其之前或之后运行。\n对于前端网页，控制器中的展示逻辑继承方式和模型方法相似，网页模板也是包含 XML 结构的视图，因此可以像其它视图类型一样的被继承。\n下一章中，我们将更深入学习模型，探索模型提供给我们的所有功能。\n扩展阅读 以下是官方文档的其它参考，可对模块扩展和继承机制的知识进行补充：\n模型继承 视图继承 网页控制器 "
},
{
	"uri": "/odoo/5/",
	"title": "第五章 Odoo 15开发之导入、导出以及模块数据",
	"tags": [],
	"description": "",
	"content": "大多数Odoo 模块的定义，如用户界面和权限规则，实际是存储在对应数据表中的数据记录。模块中的 XML 和 CSV 文件不是 Odoo 应用运行时使用，而是将这些定义加载到数据表的手段。\n正是因为这个原因，Odoo 模块的一个重要部分是在文件中放入数据以便插件安装时将其加入数据库。\n此外，掌握Odoo的数据展现的格式对于在项目实施时导入、导出业务数据也很重要。\n本章的主要内容有：\n理解外部标识符的概念 导入导出数据文件 使用 CSV 文件 添加模块数据 使用 XML 数据文件 学完本章，读者可以执行数据导入导出，将初始数据加入到数据库中，并可对所创建模块自动创建默认及演示数据。\n开发准备 本章要求读者可以运行Odoo 服务并已安装前面我们此前开发的图书应用。\n相关代码请见GitHub 仓库的ch05/ 目录。其中包含第三章 Odoo 15开发之创建第一个 Odoo 应用中的library_app，以及本章中所新增的代码。\n理解外部标识符的概念 外部标识符，也称为XML ID，是用于唯一标识 Odoo 中特定记录的易于阅读的字符串标识符。在Odoo 中加载数据时它们就很重要了，这样可以对已有数据记录进行修改或在其它数据记录中引用它。\n首先我们将讨论外部标识符的工作原理以及如何检查外部标识符。然后我们会学习如何使用网页客户端来查找指定数据记录的外部标识符，在创建插件模块或扩展已有功能时需要经常用到。\n外部标识符的工作原理 我们先从标识部的原理开始。记录在数据库中的真实标识符是自动分配的序列号，在安装模块时无法预先知道将要分配的具体ID。外部标识符让我们无需知道真实分配的数据库 ID便可以引用一条相关记录。XML ID 为数据库 ID 提供了一个方便的别名，借此我们可以在任何时刻引用某一指定记录。\nOdoo 模块数据文件中使用XML ID来定义记录。其中一个原因是避免在升级模块时创建重复的记录，在升级时会再次将数据文件加载到数据库中。我们要检测已有记录来进行更新，而不是重复创建记录。\n使用XML ID的另一个原因是支持交叉数据：即需引用其它数据记录的数据记录。因为我们无法知道真实数据库 ID，使用XML ID来由 Odoo 框架处理透明的转换。\nOdoo 处理由外部标识符对所分配的真实数据库 ID 的转换。背后的机制相当简单：Odoo 维护一张外部标识符和对应数据库数字 ID 的映射表：ir.model.data模型。\n我们需启用开发者模式才能访问下文中的菜单。可通过在右上角头像左侧查看是否有调试图标，如果没有需在 Settings菜单页启用，具体方法可参照第一章 使用开发者模式快速入门 Odoo 15中的内容。\n通过菜单访问Settings \u0026gt; Technical \u0026gt; Sequences \u0026amp; Identifiers \u0026gt; External Identifiers可查看已有映射。例如访问外部标识符列表并过滤出library_app模块，将可以看到该模块生成的外部标识符，如下图所示：\n图5.1：由library_app生成的外部标识符\n可以看到外部标识符有Complete ID标签。注意其组成部分为：模块名+.+标识符名，如library_app.action_library_book。\n外部标识符仅需在 Odoo 模块内唯一，两个模块中使用相同标识符不会产生冲突。全局唯一标识符是由模块名和外部标识符共同组成的，在上图Complete ID字段中可以看到。\n在数据文件中使用外部标识符时，我们可以选择完整的标识符或仅外部标识符部分。通常仅使用外部标识符会更简单，但使用完整标识符时我们可以引用其它模块中的数据记录。做引用时不要忘记在模块依赖中加入这些模块以确保在我们的记录之前加载这些记录。\n有时即便引用相同模块中的XML ID也需使用完整标识符。\n在上图列表最上方可以看到library_app.action_library_book完整标识符。这是我们在模块中创建的菜单动作，在相应的菜单项中引用。点击进入表单视图查看详情。图中可以看出library_app模块中的action_library_book外部标识符映射到ir.actions.act_window模型中的记录 ID，此处为90。\n点击该记录行，可以看到如下图所示的表单视图：\n图5.2：外部标识符的表单视图\n除了用于由记录引用其它记录外，外部标识符还可以避免重复导入带来的重复数据。一旦外部标识符已存在，则会在原有记录上更新，避免了重复数据的新建。\n查找外部标识符 在为我们的模块写入数据记录时，经常需要查找已有外部标识符来作引用。因此了解如何找到这些标识符就很重要了。\n一种方式是访问菜单Settings \u0026gt; Technical \u0026gt; Sequences \u0026amp; Identifiers \u0026gt; External Identifiers，前面的图5.1已经演示过。另一种方法是使用开发者菜单。在第一章 使用开发者模式快速入门 Odoo 15介绍了如何在面板Settings右下角激开发者模式。\n要查找一条数据记录的外部标识符，我们应打开对应的表单视图，选择Developer菜单，然后选择View Metadata选项。此时会显示一个带有记录数据库 ID 和外部标识符（也称作XML ID）的对话框。\n比如要查看 demo 用户 ID，需通过 Settings \u0026gt; Users \u0026amp; Companies \u0026gt; Users 打开demo用户表单视图，然后点击开发者工具菜单中的View Metadata选项。此时可以看到XML ID是base.user_demo，数据库 ID 是6：\n图5.3：View Metadata对话框窗口\n查看表单、列表、搜索或 action 视图元素中的外部标识符，都可以使用开发者菜单。下面我们通过Edit View选项来打开相应视图的详情表单。此时可以查看到External ID字段，其值即为外部标识符。\n例如在下图中，可以看到用户表单视图的外部标识符为base.view_users_form：\n图5.4：Edit View窗口显示表单视图的外部标识符\n以上就学习了外部标识符以及如何将其用作引用数据库记录的别名。我们还了解了几种查找XML ID的方式，在数据文件中引用记录时会使用到。接下来我们学习如何创建数据文件，会用到这些XML ID。\n导入导出 CSV 数据文件 生成数据文件并查看文件结构的简易方式是使用内置的导出功能。\n通过所生成的CSV 文件，我们可以了解手动导入系统所需的数据格式，编辑该文件执行批量导入，甚至是使用它生成我们插件模块的演示数据。\n下面我们一起来学习从 Odoo 用户界面导入和导出数据的基础知识。\n导出数据 数据导出是列表视图中的标准功能。要使用该功能， 需要勾选左侧的复选框来选择需导出的行，然后在上方的 Action 菜单中点击 Export 选项。\n首先我们要在图书应用中添加一些带有出版商和作者的图书。下例中我使用此前添加的书籍。\n我们还需要安装 Contacts 应用，这样可以看到 Partner 的列表视图，可从该处导出记录。注意其默认视图为联系人卡片看板视图，需要先切换为列表视图：\n图5.5：动作菜单的导出选项\n可通过勾选列头的复选框来选择所有匹配当前搜索条件的记录。\nOdoo 9中的变化\n在 Odoo 更早的版本中，只有屏幕上显示（当页）的记录能被导出。Odoo 9做出了修改，勾选列头的复选框可导出当前过滤的所有匹配记录，而不仅仅是当前显示。这对导出屏幕上无法展示全的大量记录非常有用。\n点击 Export 选项进入Export Data 对话表单，可选择导出内容和方式。我们比较关注的是导出方式可以让我们稍后通过手动或插件模块来导入该文件：\n图5.6：导出数据对话框窗口\nI want to update data (import-compatible export) ：勾选这一复选框导出的数据对于后期导入格式友好。 Export format：可选择CSV或XLSX。我们将选择 CSV 格式更好理解原始导出格式，在很多表单应用中都能读取。 下一步选取要导出的列，本例中简化操作，仅选择Name字段。我们点击Export按钮，就会下载带有导出数据的文件。最终导出的 CSV文件是这样的：\n\u0026#34;id\u0026#34;,\u0026#34;name\u0026#34; \u0026#34;__export__.res_partner_42_6fcf3f5d\u0026#34;,\u0026#34;Daniel Reis\u0026#34; \u0026#34;__export__.res_partner_43_7ac40720\u0026#34;,\u0026#34;William Golding\u0026#34; 补充： 伸手党请注意这里及后续的 ID 字段都与导出的系统有关，不应直接使用\n第一行中包含字段名，导入时会使用它们自动匹配目录列。\n第一行中有选中的name列， 这不意外。自动添加了初始ID列，因为选中的是兼容导入的导出。\n自动添加的id列有为每条记录分配的外部ID。这样可对导出的数据进行编辑，稍后导入更新记录，而不会重复创建数据。\n缺失的外部标识符使用 **__export__ **前缀自动生成，参见上面的导出示例。\n小贴士： 由于会自动生成记录标识符，导出或导入功能可用于批量编辑 Odoo 数据：将数据导出至 CSV，使用表单软件批量编辑数据，再导入 Odoo。\n导入数据 准备好格式正确的数据，就可以导入Odoo了。我们学习如何通过网页用户界面进行导入。\n首先应确认开启了导入功能，默认是开启的。如果没有，进入Settings \u0026gt; General Settings，在 Permissions 版块下勾选Import \u0026amp; Export选项即可。\n启用该选项后，列表视图搜索微件Filters和Group By菜单旁的Favorites菜单中会显示一个Import records选项。\n上方 Create 按钮旁就会显示一个 Import按钮。\n注：Import \u0026amp; Export 设置安装base_import模块，该模块用于提供这一功能。\n下面我们尝试批量编辑Contact或Partner数据。使用电子表单或文本编辑器打开刚下载的CSV并修改几个值。也可以新增几行，将 id 栏留空即可。\n前文已经提到第一列 id 是每行的唯一标识符，这样可更新已有记录，不会因重新导入Odoo重复创建数据。我们在导出文件中编辑任意字段在导入时对应记录就会被更新。\n对于要加入 CSV 文件的新行，我们可以自己添加外部标识符或将 id 列留空。两种方式都会创建新的记录。作为示例，我们添加一行id 留空、name 为Phillip K. Dick，在数据库中新建这一记录：\n,Phillip K. Dick 保存 CSV文件后，点击Favorites菜单的Import选项。出现的页面中可以上传数据文件。然后就会出现导入助手：\n图5.7：导入文件助手\n期间需在本地磁盘中选取CSV文件，点击左上角的Test按钮测试其正确性。\n因为所导入的文件来自Odoo的导出文件，大概率格式有效并且各列会与数据表进行相应的映射。根据编辑数据文件的应用不同，可能需要调整分隔符和编码选项达到最佳结果。\n此时，点击Import，所做的修改以及新记录就会加载到Odoo中。\nCSV 数据文件中的关联记录 前面的示例非常简单，一旦我们开始用关联多张表记录的关联字段时，数据文件就会变得更为复杂。\n以上我们处理过图书中的 Partner 记录。下面就看一下如何在图书 CSV 文件中表示对这些 Partner 的引用。具体来说，有一个出版商(publisher_id字段)的多对一(或外键)关联，以及一个作者(author_ids字段)的多对多关联。\nCSV 文件的表头行中关联列应在名称后添加一个 /id。它将使用外部标识符来引用关联记录。本例中，我们将在publisher_id/id字段中加载图书出版商，使用关联 Partner 的外部 ID 作为其值。\n可使用 /.id来进行替代，这样可使用数据库中的真实 ID（自动分配的数字 id），但极少使用到。除非有特别原因，否则请使用外部 ID 而非数据库ID。同时要记住数据库 ID 针对具体的Odoo数据库，所以如果导入到非原始数据库中通常会失败。\nCSV 数据文件中也可导入多对多字段。这和添加带双引号并由逗号分隔的外部 ID 列表一样简单。例如，要载入图书作者，需要一个author_ids/id列，并使用一个关联 Partner外部 ID 的逗号分隔列表作为其值。以下是对多字段在CSV中的一示例：\nid, name, author_ids/id book_odc11, \u0026#34;Odoo 11 Development Cookbook\u0026#34;,\u0026#34;__export__.res_partner_42_6fcf3f5d,__export__.res_partner_43_7ac40720\u0026#34; 一对多字段通常是表头和行或父子关系，对于这类关系有特别的支持方式：同一条父记录可以有多个关联行。\n此处我们在 Partner 模型中有一个一对多字段的例子：公司可有多个子联系人。如果从 Partner 模型中导出数据并包含Contacts/Name 字段，就可以看到要导入此类型数据的格式(Contacts 中选择Azure Interior：默认应为第一条，并执行前述的导出步骤)：\nid name child_ids/id child_ids/name base.res_partner_12 Azure Interior base.res_partner_address_15 Brandon Freeman base.res_partner_address_28 Colleen Diaz base.res_partner_address_16 Nicole Ford 图5.8：导出对多关联字段数据文件示例\nid和 name 列为父记录的，child_ids两列为子记录的。注意第一行记录以下父记录部分留空。\n上表中CSV 文件形式显示为：\n\u0026#34;id\u0026#34;,\u0026#34;name\u0026#34;,\u0026#34;child_ids/id\u0026#34;,\u0026#34;child_ids/name\u0026#34; \u0026#34;base.res_partner_12\u0026#34;,\u0026#34;Azure Interior\u0026#34;,\u0026#34;base.res_partner_address_15\u0026#34;,\u0026#34;Brandon Freeman\u0026#34; \u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;base.res_partner_address_28\u0026#34;,\u0026#34;Colleen Diaz\u0026#34; \u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;base.res_partner_address_16\u0026#34;,\u0026#34;Nicole Ford\u0026#34; 可以看到id和name这两列第一行有值，后两行都为空。其中的父记录为联系人的公司信息。\n另两行的前缀都是child_ids/ 并且在三行中都有数据。这些是父公司的联系人信息。第一行包含公司和第一个联系人，其余行仅包含子联系人列的数据。\n添加模块数据 模块使用数据文件来加载默认数据、演示数据、用户界面定义和其它需存入数据库的配置。可以选择使用 CSV 或 XML 文件。\nOdoo 12中的变化\nOdoo 11及之前版本支持YAML格式文件，但在 Odoo 12移除了相关支持。相关使用示例可参考 Odoo 11官方模块l10n_be，更多YAML格式相关信息，可访问http://yaml.org/。\n模块所使用的 CSV 和我们前述使用导入功能时用的文件是一样的。在模块中使用这些文件时，文件名须与要导入数据的模型名一致。例如，导入library.book模型的 CSV 数据文件名应为library.book.csv。\nCSV 数据文件经常用作导入ir.model.access模型来获取权限定义，通常放在security/ 子目录下并命名为ir.model.access.csv。\n演示数据 Odoo插件模块可安装演示数据，这是一种良好实践。为模块提示使用示例和测试用的数据集会非常有用。模块的演示数据通过__manifest__.py文件中的 demo 属性来声明。和 data 属性一样，后接一个包含模块相对路径的文件名列表。\n我们应为library.book模块添加一些演示数据，一种简易方式是从安装了模块的开发数据库中导出数据。\n按惯例数据文件放在data/ 子目录下，应以data/library.book.csv保存在library_app模块下。因这个数据为模块所有，应在导出的数据中将标识符的前缀__export__去除。\n例如res.partner.csv文件可能长这样：\nid,name res_partner_alexandre,\u0026#34;Alexandre Fayolle\u0026#34; res_partner_daniel,\u0026#34;Daniel Reis\u0026#34; res_partner_holger,\u0026#34;Holger Brunn\u0026#34; res_partner_packt,\u0026#34;Packt Publishing\u0026#34; 那么图书演示数据文件library.book.csv就应该是这样的：\n\u0026#34;id\u0026#34;,\u0026#34;name\u0026#34;,\u0026#34;date_published\u0026#34;,\u0026#34;publisher_id/id\u0026#34;,\u0026#34;author_ids/id\u0026#34; library_book_ode11,\u0026#34;Odoo Development Essentials 11\u0026#34;,\u0026#34;2018-03-01\u0026#34;,res_partner_packt,res_partner_daniel library_book_odc11,\u0026#34;Odoo 11 Development Cookbook\u0026#34;,\u0026#34;2018-01-01\u0026#34;,res_partner_packt,\u0026#34;res_partner_alexandre,res_partner _holger\u0026#34; 还应记得在__manifest__.py的 demo 属性中声明数据文件：\n\u0026#39;demo\u0026#39;: [ \u0026#39;data/res.partner.csv\u0026#39;, \u0026#39;data/library.book.csv\u0026#39;, ], 文件会以声明的顺序来加载，这个很重要，因为文件的记录无法引用尚未创建的记录。\n只要启用了安装演示数据，在下次更新模块时，就会导入文件中的内容。\n注： 数据文件会在模块升级时重新导入，但演示文件则并非如此，它们仅在安装时导入。\n当然 XML 文件也可用于加载或初始化数据，还可使用普通 CSV 文件所不具备的功能。下一节中我们就来讨论使用XML格式的数据文件。\n使用 XML 数据文件 CSV 文件是一种展示数据方便简洁的格式，但 XML 文件更为强大，可在加载过程中提供更多的控制。比如，其文件名无需与所导入到的模型名称一致。因为XML格式通过文件内的XML元素可以提供更丰富的信息、更多的内容。\n在前面的文章中我们已经使用过XML数据文件。视图和菜单项这类用户界面组件实际上都是存储在系统模型中的记录。模块中的XML文件用于将这些记录加载到实例数据库中。\n我们将在library_app模块中再添加一个数据文件data/book_demo.xml来进行展示，文件内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo noupdate=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;!-- Data to load --\u0026gt; \u0026lt;record model=\u0026#34;res.partner\u0026#34; id=\u0026#34;res_partner_huxley\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Aldous Huxley\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record model=\u0026#34;library.book\u0026#34; id=\u0026#34;library_book_bnw\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Brave New World\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;author_ids\u0026#34; eval=\u0026#34;[(4, ref(\u0026#39;res_partner_huxley\u0026#39;))]\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;date_published\u0026#34;\u0026gt;1932-01-01\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 老规矩，新的数据文件应在__manifest__.py中声明：\n\u0026#34;demo\u0026#34;: [ \u0026#34;data/res.partner.csv\u0026#34;, \u0026#34;data/library.book.csv\u0026#34;, \u0026#34;data/book_demo.xml\u0026#34;, ], 类似上一节的 CSV 数据文件，该文件也会将数据加载到图书模型中。\nXML文件包含一个外层 \u0026lt;odoo\u0026gt; 顶级元素，内部可包含多个 \u0026lt;record\u0026gt; 元素，对应 CSV 的数据行。\n注： 数据文件中的外层 \u0026lt;odoo\u0026gt; 元素在9.0中才引入用于替换此前的 \u0026lt;openerp\u0026gt; 标签。现在仍支持外层元素内的 \u0026lt;data\u0026gt; 标签，为可选项。事实上现在 \u0026lt;odoo\u0026gt; 和 \u0026lt;data\u0026gt; 是等价的，我们可以在XML数据文件中使用任意一个作为外层元素。\n\u0026lt;record\u0026gt; 元素有两个强制属性： model 和作为记录外部标识符的 id，每个字段使用一个 \u0026lt;field\u0026gt; 标签来进行写入。\n注意此处字段名内不可使用斜杠标记，如不可使用 \u0026lt;field name=\u0026quot;publisher_id/id\u0026quot;\u0026gt; 。应使用 ref 属性来引用外部标识符。一会儿就会讨论到关联对多字段的值。\n你可能注意到在 \u0026lt;odoo\u0026gt; 外层元素中使用了noupdate=\u0026ldquo;1\u0026rdquo; 属性。这防止了在模块升级时数据记录的载入，不至于丢失后续编辑的数据。\nnoupdate 数据属性 升级模块时，会重新加载数据并重写模块记录。要谨记这可能意味着在升级模块时会重写任何对模块数据的手动更改。\n小贴士： 值得注意的是，手动对视图所做的自定义修改会在下一次模块升级时丢失。避免这一问题正确的方法是创建继承视图来引入要做的修改。\n这种重写行为是默认的，但可以修改让有些数据仅在安装时导入，后续模块更新时则予以忽略，这正是通过 \u0026lt;odoo\u0026gt; 或 \u0026lt;data\u0026gt; 元素中的noupdate=\u0026ldquo;1\u0026rdquo; 来实现的。\n这对于需初始化配置且预期需自定义的数据来说非常有用，因为这些手动修改在模块更新时是安全的。例如在记录权限规则中经常使用，可以适配具体的实施需求。\n在同一 XML 文件中可以有多个 \u0026lt;data\u0026gt; 版块。可通过noupdate=\u0026ldquo;1\u0026quot;来分离出仅需导入一次的数据，以及需在每次更新时重新导入的数据（noupdate=\u0026ldquo;0\u0026rdquo; ）。noupdate=\u0026ldquo;0\u0026rdquo; 是默认值，所以可以省略不写。注意还必须要有一个外层 XML 元素，就这个例子而言，使用两个 \u0026lt;data\u0026gt; 标签，并在外层包裹一个 \u0026lt;odoo\u0026gt; 或 \u0026lt;data\u0026gt; 元素。\n小贴士：noupdate属性在开发模块时可能会引起不适，因为会忽略后续修改。一个解决方案是，使用**-i** 参数重新安装模块而不是使用**-u** 参数进行更新。命令行中使用**-i** 参数重新安装会忽略数据记录中的noupdate标记。\nnoupdate标记存储在每条记录的外部标识符信息中。可通过 Technical 菜单中的External Identifiers表单手动编辑，勾选Non Updatable 复选框即可。\nOdoo 12中的变化\n点击开发者菜单中的View Metadata时，在弹出的对话框中 XML ID 下面还会显示No Update标记的值。并且在该处可通过点击来修改该标记的值（仅适用于导入数据）。\n在 XML 中定义记录 在 XML 数据文件中，每个 \u0026lt;record\u0026gt; 元素有两个基本属性：id 和 model，并包含为对应列设置值的 \u0026lt;field\u0026gt; 元素。 id 属性对应记录外部标识符，model 对应目标模型。 \u0026lt;field\u0026gt; 元素有几种赋值的方法，下面一起来看看。\n直接为字段设置值 \u0026lt;field\u0026gt; 元素的 name 属性标识要写入的字段。\n写入的值是元素内容：字段开、闭标签之间的文本。对于日期和日期，可使用带返回 date 或 datetime 对象表达式的 eval 属性设置。返回的 \u0026ldquo;YYYY-mm-dd\u0026rdquo; 和 \u0026ldquo;YYYY-mm-dd HH:MM:SS\u0026rdquo; 字符串会进行对应转化。对于布尔字段， \u0026ldquo;0\u0026rdquo; and \u0026ldquo;False\u0026rdquo; 都会转换成 False，而任意非空值都会转换成 True。\nOdoo 10中的变化\nOdoo 10中改进了从数据文件中读取布尔值 False的方式。在老版本中，包含 \u0026ldquo;0\u0026rdquo; 和 \u0026ldquo;False\u0026rdquo; 在内的非空值都会转换成 True。直至 Odoo 9，布尔值仍需使用 eval 属性进行设置，如 eval=\u0026ldquo;False\u0026rdquo; 。\n通过表达式设置值 设置字段值更复杂的方式是通过 eval 属性。它会运行 Python 表达式并将结果赋值给字段。\n表达式通过 Python 内置的以及一些其它可创建表达式标识符的上下文求值。\n可使用如下 Python 模块来处理日期：time、datetime、 timedelta和relativedelta。通过它们可以计算日期值，在演示和测试数据经常会用到，以让日期和模块安装日期接近。关于 Python 模块更多这类知识，请参考官方文档。\n比如，把值设为前一天，可使用如下代码：\n\u0026lt;field name=\u0026#34;date_published\u0026#34; eval=\u0026#34;(datetime.now() + timedelta(-1))\u0026#34; /\u0026gt; 求值上下文还可使用ref() 函数，用于将外部标识符转换为对应的数据库 ID。这可用于为关联字段设置值。比如，可以使用它为publisher_id设置值：\n\u0026lt;field name=\u0026#34;publisher_id\u0026#34; eval=\u0026#34;ref(\u0026#39;res_partner_packt\u0026#39;)\u0026#34; /\u0026gt; 在多对一关联字段上设置值 对于多对一关联字段，要写入的是关联记录的数据库 ID。在 XML 文件中，我们一般会知道记录的XML ID，然后就需要把它转换成实际的数据库 ID。\n一种方式是像前文那样使用带有 ref() 函数的 eval 属性。\n更简单的替代方式是在 \u0026lt;field\u0026gt; 元素中使用的ref 属性，例如：\n\u0026lt;field name=\u0026#34;publisher_id\u0026#34; ref=\u0026#34;res_partner_packt\u0026#34; /\u0026gt; 上例为publisher_id多对一字段设置值，引用XML ID为res_partner_packt的数据库记录。\n在对多关联字段上设置值 对于一对多和多对多字段，设置的不是单个 ID，而是一组关联 ID。并且还进行几种操作：我们可能需要将当前的关联记录列表替换成另外一个，或为其添加几条记录，甚至是删除其中的一些记录。\n要让对多字段支持写操作，我们要在 eval 属性中使用一种特殊的语法。我们使用三元元组列表来写入对多字段。每个元组有三个元素，构成一条写入命令，根据第一个元素中的代码进行对应操作。\n重写图书作者列表，会使用如下代码：\n\u0026lt;field name = \u0026#34;author_ids\u0026#34; eval = \u0026#34;[(6, 0, [ref(\u0026#39;res_partner_alexandre\u0026#39;), ref(\u0026#39;res_partner_holger\u0026#39;)] )]\u0026#34; /\u0026gt; 往当前图书作者列表追加关联记录，需要添加如下代码：\n\u0026lt;field name=\u0026#34;author_ids\u0026#34; eval=\u0026#34;[(4, ref(\u0026#39;res_partner_daniel\u0026#39;))]\u0026#34; /\u0026gt; 上述的例子非常常见。都仅使用了一个命令，但在外层列表中可以串联多条命令。追加(4)和 替换(6)是最常用的命令。在进行添加(4)时，不需要使用最后一个元素，因此在以上代码中省略了。\n完整的对多写入命令如下：\n(0, _ , {\u0026lsquo;field\u0026rsquo;: value}) 新建一条记录并将其与之关联 (1, id, {\u0026lsquo;field\u0026rsquo;: value}) 更新已关联记录的值 (2, id, _) 移除关联并删除 id 关联的记录 (3, id, _) 移除关联但不删除 id 关联的记录。通常使用它来删除多对多字段的关联记录 (4, id, _) 关联已存在记录，仅适用于多对多字段 (5, _, _) 删除所有关联，但不删除关联记录 (6, _, [ids]) 替换已关联记录列表为此处的列表 上述下划线_字符代表非相关值，通常填入 0 或 False。\n小贴士： 后面的非关联值可以放心地省略掉，如(4, id, _) 可使用(4, id)\n本小节中，我们学习了如何使用 \u0026lt;record\u0026gt; 标签来将记录加载到数据库中。还有一些简写标签可用于支付替换常规的 \u0026lt;record\u0026gt; 标签。我们在下一小节中介绍。\n常用模型的简写 如果回到第三章 Odoo 15开发之创建第一个 Odoo 应用，我们在 XML文件中还发现有 \u0026lt;record\u0026gt; 之外的元素，如 \u0026lt;menuitem\u0026gt; 。\n这些是常用模型的简写方式，是比常用的 \u0026lt;record\u0026gt; 更为简练的符号。它们用于向 base 模型加载数据、组成用户界面，在第十章 Odoo 15开发之后台视图 - 设计用户界面会做更详细的探讨。\n为便于查看，以下是可用的简写元素以及加载数据的对应模型：\n\u0026lt;menuitem\u0026gt; 对应菜单项模型ir.ui.menu \u0026lt;template\u0026gt; 用于存储在ir.ui.view模型中的 QWeb 模板 Odoo 14中的修改\nOdoo此前的版本还支持其它简短标签，现在不再支持。有用于窗口动作模型ir.actions.act_window的 \u0026lt;act_window\u0026gt; ，和用于报告动作模型ir.actions.report.xml的 \u0026lt;report\u0026gt; 。\n应当注意在用于修改已有记录时，简写元素会覆盖所有字段。这与仅写入所提供字段的 \u0026lt;record\u0026gt; 基础元素不同。因此在需修改用户界面元素指定字段时，应使用 \u0026lt;record\u0026gt; 元素。\nXML 文件中的其它操作 截至目前我们了解了如何使用 XML 文件添加或更新数据。但也可以通过 XML 文件删除数据以及执行指定模型方法。对更复杂的数据场景会非常有用。下面的小节中我们学习如何删除及使用函数调用XML功能。\n删除记录 我们可以使用 \u0026lt;delete\u0026gt; 元素删除数据记录，使用 ID 或搜索作用域来定位要删除的记录。\n例如，使用搜索作用域查找记录并删除：\n\u0026lt;delete model=\u0026#34;res.partner\u0026#34; search=\u0026#34;[(\u0026#39;id\u0026#39;,\u0026#39;=\u0026#39;,ref(\u0026#39;library_app.res_partner_daniel\u0026#39;))]\u0026#34; /\u0026gt; 如果知道要删除记录的具体 ID，也可使用 id 属性。上例正是这样，还可以写成这样：\n\u0026lt;delete model=\u0026#34;res.partner\u0026#34; id=\u0026#34;library_app.res_partner_daniel\u0026#34; /\u0026gt; 它与前面的例子效果相同。因为我们知道要查找的ID，无需使用带有作用域表达式的search属性，直接通过XML ID使用id属性即可。\n调用模型方法 XML 文件还可以通过 \u0026lt;function\u0026gt; 元素在加载过程中执行任意方法。这可用于设定演示和测试数据。\n比如 Odoo 捆绑的 Notes 应用，使用它来设定演示数据：\n\u0026lt;data noupdate=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;function model=\u0026#34;res.users\u0026#34; name=\u0026#34;_init_data_user_note_stages\u0026#34; eval=\u0026#34;[]\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; 这会调用res.users模型中的 _init_data_user_note_stages方法，不传任何参数。参数列表通过eval属性传递，此处为空列表。\n至此学完了XML数据文件的有关知识。我们对 \u0026lt;data\u0026gt; 和noupdate标记进行了综述。然后学习了如何使用 \u0026lt;record\u0026gt; 元素加载数据文件，以及如何对关联字段设置值。同时学习了记录的简写，如 \u0026lt;menuitem\u0026gt; 和 \u0026lt;template\u0026gt; 。最后，我们学习了如何通过 \u0026lt;delete\u0026gt; 和 \u0026lt;function\u0026gt; 删除记录及进行指定函数的调用。\n学习完这些，读者应该可以按项目的数据需求准备所需要的XML数据文件了。\n总结 本章中我们学习了如何用文本文件展示数据。可用作手动向 Odoo 导入数据，或放在插件模块中作为默认或演示数据。\n通过学习我们可以通过网页界面导出并导入 CSV 数据文件了，以及通过外部标识符来检测并更新数据库中已有的记录。也可用作批量编辑数据，只需编辑导出的 CSV 文件再重新导入即可。\n我们还详细学习了 XML 数据文件的结构以及其所提供所有功能。不仅可以为字段设置值，还可以执行删除记录和调用方法一类的操作。\n下一章中，我们将集中学习如何使用记录来与模型中所含数据协作。这些工具可供我们实现应用的业务逻辑和规则。\n扩展阅读 Odoo 官方文档中提供了有关数据文件的更多资料。\n"
},
{
	"uri": "/odoo/6/",
	"title": "第六章 Odoo 15开发之模型 - 结构化应用数据",
	"tags": [],
	"description": "",
	"content": "本章我们更进一步学习模型层，以及如何使用模型来设计支撑应用的数据结构。我们会探讨可用的模型类型，以及在使用这些类型时如何定义强制进行数据验证的约束。\n模型由支持不同数据类型的数据字段组成，一些字段类型支持定义模型间的关联。对于字段更高级的使用包含使用具体的业务逻辑自动计算的值。\n本文的主要内容有：\n学习项目 - 优化图书应用 创建模型 创建字段 模型间的关联 计算字段 模型约束 Odoo的 base 模型总览 通过这些内容，我们将学习如何为Odoo项目创建大型数据结构。在学完本章后，读者对于架构数据模型相关的功能应该会有清晰的认知。\n开发准备 本文代码基于第三章 Odoo 15开发之创建第一个 Odoo 应用中所创建的代码。相关代码参见 GitHub 仓库的ch06/ 目录。\n请将其添加至插件路径中，并安装好library_app模块。\n学习项目 - 优化图书应用 在第三章 Odoo 15开发之创建第一个 Odoo 应用中，我们创建了一个library_app插件模块，实现了一个简单的library.book模型用于展示图书目录。本章中，我们将回到该模块来丰富存储的图书数据。\n我们使用如下结构添加一个分类层级，用于图书分类：\nName：分类标题 Parent：所属父级分类 Subcategories：将此作为父级分类的子分类 Featured book或author: 此分类中所选图书或作者 我们会添加一些字段来展示 Odoo中字段的数据类型。我们还会为图书模型添加一些验证约束：\n标题和出版日期应唯一 输入的ISBN应为有效 下面我们就更深度地学习Odoo模型，学习可以使用的所有选项。\n创建模型 模型是 Odoo 框架的核心。它们描述应用的数据结构，是服务端应用和数据库存储之间的桥梁。可围绕模型实现业务逻辑来为应用添加功能，用户界面所提供的用户体验也建立在模型之上。\n下面几节我们将学习模型的通用属性，用于影响行为，以及几种模型类型：普通(regular)模型、临时(transient)模型和抽象(abstract)模型。\n模型属性 模型类可以使用控制行为的一些其它属性。以下是最常用的属性：\n_name： 它是我们创建的 Odoo 模型的内部标识符，新建模型时为必填。 _description： 它是对用户友好的标题，指向单个模型记录，如Book。可选但推荐添加。如未设置，在加载过程中服务端日志会显示警告。 _order： 设置浏览模型记录时或列表视图的默认排序。其值为 SQL 语句中 order by 使用的字符串，所以可以传入符合 SQL 语法的任意值，它有智能模式并支持可翻译字段及多对一字段名。 我们的图书模型中已使用了 _name 和 _description属性。可以添加一个 _order属性来默认以图书名排序，然后按出版日期倒序排（新出版在前）。\nclass Book(models.Model): _name = \u0026#39;library.book\u0026#39; _description = \u0026#39;Book\u0026#39; _order = \u0026#39;name, date_published desc\u0026#39; 在高级用例中还会用到如下属性：\n_rec_name： 设置记录显示名的字段。默认为name字段，因此我们通常选择它作为记录标题。 _table： 是模型对应的数据表名。通常由ORM自动设置，替换模型名称中的点为下划线，但是我们可以通过该属性指定表名。 _log_access=False： 用于设置不自动创建审计追踪字段，也即create_uid、create_date、write_uid和write_date。 _auto=False： 用于设置不自动创建模型对应的数据表。这时应使用init() 方法来编写创建数据库对象、数据表或视图的具体逻辑。通常用于支持只读报表的视图。 例如，以下代码为 library.book模型设置了一些默认值：\n_recname = \u0026#34;name\u0026#34; _table = \u0026#34;library_book\u0026#34; _log_access = True _auto = True 注：还有用于继承模块的_inherit和_inherits属性，在本文后续会深入学习。在第四章 Odoo 15开发之模块继承中已详细讲解过。\n在使用 _auto = False时，我们是在重载创建数据库对象的过程，所以应编写相应逻辑。常用的场景是报表 ，基于收集报表所需数据的数据库视图。\n以下是从sale内核模块中抽取的示例，来自sale/report/sale_report.py文件：\ndef init(self): tools.drop_view_if_exists(self.env.cr, self._table) self.env.cr.execute( \u0026#34;CREATE or REPLACE VIEW %s as (%s)\u0026#34; % (self._table, self._query()) ) 以上代码使用了Python模块tools，需要使用from odoo import tools导入。\n模型和 Python 类 Odoo 模型使用Python类，在前面的代码中，有一个继承了 models.Model类的 Python 类：Book，用于定义名为library.book的Odoo模型。\nOdoo的模型保存在中央注册表(central registry)中，可通过环境对象获取，通常为self.env。中央注册表保存对所有模型的引用，过使用类字典语法访问。\n例如，可在方法内使用self.env[\u0026rsquo;library.book\u0026rsquo;] 或****self.env.get([\u0026ldquo;library.book\u0026rdquo;])** **来获对图书模型的引用。\n可以看出模型名非常重要，它是访问模型注册表的关键。\n模型名必须全局唯一。因此使用模块所属应用的每个单词作为模型名称的第一个单词是一种良好实践。就Library应用而言，所有的模型名应使用library前缀。内核模型的其它例子有project、crm或sale。\n小贴士： 模型名应使用单数形式library.book，不应使用library.books。规范是以点号连接一组小写的单词。第一个单词标识所属主应用，如library.book或library.book.category。例如官方插件中有project.project、project.task和project.task.type。\n此外，Python类名为Python文件本地所有，声明与Odoo框架没有关联。所用的名称仅在该文件中具有意义，关联度不高。Python有关类名按照PEP8的规范是使用驼峰命名（CamelCase）。\n存在几种模型类型。最常用的一种是models.Model类，用于数据库持久化存储模型。接下来我们学习其它几种模型类型。\n临时(Transient)模型和抽象模型 大多数据 Odoo 模型中的类会继承models.Model类。这类模型在数据库中持久化存储，会为模型创建数据表并存储记录直至删除。一般使用它就够了。\n但有时我们并不需要持久化的数据库存储，这时就可以使用下面两类模型：\n临时模型继承models.TransientModel类，用于向导式的用户交互。这类数据会存储在数据库中，但仅是临时性的。会定时运行清空 job 来清除这些表中的老数据。比如Settings \u0026gt; Translations \u0026gt; Import Translation 菜单打开一个对框窗口，使用临时模型存储用户选项并实现向导逻辑。在第八章 Odoo 15开发之业务逻辑 - 业务流程的支持中会有讨论临时模型的示例。 抽象模型继承models.AbstractModel类，它不含数据存储。抽象模型用作可复用的功能集，与使用 Odoo 继承功能的其它模型相配合。例如mail.thread是 Discuss 应用中的一个抽象模型，用于为其它模型添加消息和关注功能。使用抽象模型的 mixin 类以及前述的 mail.thread示例在第四章 Odoo 15开发之模块继承中进行了讨论。 查看已有模型 通过 Python 类创建的模型和字段可通过用户界面查看。启用开发者模式，访问菜单Settings \u0026gt; Technical \u0026gt; Database Structure \u0026gt; Models，这里有数据库中的所有模型。\n点击列表中的模型会打开详情表单，如下图所示：\n图6.1：通过Technical菜单查看图书模型\n这是一个查看模型结构很好的工具，因为在这里可以看到不同模块所有的修改结果。表单视图右上角 In Apps字段中可以看到对其施加影响的模块列表。本例中library.book模型受library_app和library_member两个模块的影响。\n小贴士： 如第一章 使用开发者模式快速入门 Odoo 15中所见，模型表单是可编辑的。通过这里是可以创建并修改模型、字段和视图的。可在此处创建原型然后在插件模块中实现。\n下方区域中还有几个包含其它信息的标签：\nFields显示模型的字段 Access Rights显示授予不同权限组的访问控制规则 Record Rules显示用于记录过滤器的记录规则 Notes是模型定义文档字符串 Views显示模型所带的视图 我们可以通过开发者菜单下的View Metadata选项查看模型的外部标识符或XML ID。模型的外部标识符由 ORM 自动生成，遵循一套简单规则：将模型名的点号替换为下划线，加前缀model_ 。如为library.book模型生成的外部标识符，由library_app模块创建，为library_app.model_library_book。定义权限ACL的CSV文件通常需要这些XML ID。\n读者已熟悉了定义模型的那些选项。下一步就来了解几种字段类型以及它们的配置选项。\n创建字段 创建新模型后的第一步是添加字段。Odoo 支持你能想到的所有基本数据类型，如文本字符串、整型、浮点型、布尔型、日期、时间以及图片或二进制数据。\n下面就来看看 Odoo 中的一些字段类型吧。\n基本字段类型 我们将为图书模型添加几种可用的字段类型。\n编辑library_app/models/library_book.py文件的Book类，将当前的字段定义换成以下这样：\nclass Book(models.Model): _name = \u0026#34;library.book\u0026#34; _description = \u0026#34;Book\u0026#34; # String fields name = fields.Char(\u0026#39;Title\u0026#39;, required=True) isbn = fields.Char(\u0026#39;ISBN\u0026#39;) book_type = fields.Selection( [(\u0026#39;paper\u0026#39;, \u0026#39;Paperback\u0026#39;), (\u0026#39;hard\u0026#39;, \u0026#39;Hardcover\u0026#39;), (\u0026#39;electronic\u0026#39;, \u0026#39;Electronic\u0026#39;), (\u0026#39;other\u0026#39;, \u0026#39;Other\u0026#39;)], \u0026#39;Type\u0026#39;) notes = fields.Text(\u0026#39;Internal Notes\u0026#39;) desc = fields.Html(\u0026#39;Description\u0026#39;) # Numeric fields: copies = fields.Integer(default=1) avg_rating = fields.Float(\u0026#39;Average Rating\u0026#39;, (3,2)) price = fields.Monetary(\u0026#39;Price\u0026#39;, \u0026#39;currency_id\u0026#39;) currency_id = fields.Many2one(\u0026#39;res.currency\u0026#39;) # price helper # Date and time fields date_published = fields.Date() last_borrow_date = fields.Datetime( \u0026#39;Last Borrowed On\u0026#39;, default=lambda self: fields.Datetime.now()) # Other fields active = fields.Boolean(\u0026#39;Active?\u0026#39;, default=True) image = fields.Binary(\u0026#39;Cover\u0026#39;) # Relational Fields publisher_id = fields.Many2one(\u0026#39;res.partner\u0026#39;, string=\u0026#39;Publisher\u0026#39;) author_ids = fields.Many2many(\u0026#39;res.partner\u0026#39;, string=\u0026#39;Authors\u0026#39;) 这些Odoo中的非关联字段类型的示例，每个还可以接收一些位置参数。接下来我们就讲解所有这些类型及其选项。\n小贴士：\nPython 中有两类参数：位置参数和关键字参数。\n位置参数需按指定顺序使用。例如，f(x, y) 应以f(1, 2) 方式调用。\n关键字参数通过参数名传递。如同一个例子，可使用f(x=1, y=2) 甚至是f(1, y=2) 两种传参方式混用。\n但请注意位置参数必须要放在关键字参数之前，f(x=1, 2) 是不允许的。更多有关关键字参数知识参见 Python 官方文档。\n一般来说，第一个位置参数是字段标题，与string关键字参数相对应。例外情况是Selection字段及所有关联字段。\nstring标签用于用户界面标签的默认文本。如未传string属性，会根据字段名将下划线替换为空格并将单词首字母大写来自动生成。例如，date_published的默认标签为Date Published。\n作为参考，以下是所有非关联字段类型及它们的位置参数：\nChar(string) 是简单文本字段，唯一位置参数是字段标签。 Text(string) 是多行文本字段，唯一位置参数是string字段标签。 Selection(selection, string) 是下拉选择列表。选项位置参数是一个 [(\u0026ldquo;value\u0026rdquo;, \u0026ldquo;Description\u0026rdquo;),] 元组列表。元组第一个元素是存储在数据库中的值，第二个元素是展示在用户界面中的描述。该列表可由其它模块使用selection_add关键字参数扩展。 Html(string) 存储为文本字段，但有针对用户界面 HTML 内容展示的特殊处理。出于安全考虑，该字段会被清洗，但清洗行为可使用sanitize=False重载。 Integer(string) 为整型数字，仅需字段标签字符串参数。 Float(string, digits) 存储浮点数字，第二个可选参数为使用的精度。这是一个 (n, d) 元组，n为总位数，d为小数位数。 Monetary(string, currency_field) 与浮点字段类似，但包含货币值的特殊处理。第二个参数currency_field为货币字段的名称。默认设置为currency_field=\u0026ldquo;currency_id\u0026rdquo; 。 Date(string) 和Datetime(string) 为日期和日期时间值。只需一个标签文本作为位置参数。 Boolean(string) 存储True 或False值。只需一个标签文本作为位置参数。 Binary(string) 存储包括图片在内的二进制数据。只需一个字符串标签位置参数。 这些字段定义包夜了常用的基本参数。注意这些并不是必填，在没填写时Odoo会补充合适的默认值。\nOdoo 12中的变化\nDate和Datetime字段在 ORM 中以Python日期对象进行处理。此前的版本中按文本字符串处理。因此在进行操作时需显式转化为Python 日期对象，之后还要再转化为文本字符串。\n文本字符串，包括Char、Text和Html有一些特有属性：\nsize (仅用于Char字段)设置最大允许尺寸。无特殊原因建议不要使用，例如可用于具有最大允许长度的社保账号。 translate=True使得字段内容可翻译，带有针对不同语言的不同值。 trim默认值为 True，在网页客户端中自动去除周围的空格。可通过设置trim=false来取消。 Odoo 12中的变化\ntrim字段属性在 Odoo 12中引入。此前版本中文本字段保存前后的空格。\n除这些以外，还有在后面会介绍到的关联字段。这在本单后面的模型间的关联一节中进行讲解。\n不过， 我们还要先在下一小节中了解下有关基础字段类型属性的其它知识。\n常用字段属性 至此，我们学习了几种基本字段类型的基础位置参数。但还有一些其它属性。\n以下是所有字段类型中可以使用的关键字参数：\nstring是字段的默认标签，在用户界面中使用。除Selection和关联字段外，它都是第一个位置参数，所以大多数情况都以关键字参数使用。如未传入，将由字段名自动生成。 default设置字段默认值。可以是具体值（如 active字段中的default=True），或是可调用指针，有名函数指针或lambda匿名函数均可。 help提供 UI 中鼠标悬停字段向用户显示的提示文本。 readonly=True会使用户界面中的字段默认不可编辑。在 API 层面并没有强制，模型方法中的代码仍然可以向其写入，视图定义要可进行重载。仅针对用户界面设置。 required=True使得在用户界面中字段默认必填。这通过在数据库层面为字段添加NOT NULL 约束来实现。 index=True为字段添加数据库索引，让搜索更快速，但同时也会部分占用更大的磁盘空间、降低写操作速度。 copy=False让字段在使用 ORM copy() 方法复制记录时忽略该字段。除对多关联字段默认不复制，其它字段值默认会被复制。 deprecated=True将字段标记为弃用。字段仍可正常使用，但每次访问会在服务端日志中写入警告消息。 groups可限制字段仅对一些组可访问、可见。值为逗号分隔的权限组XML ID列表，如groups=\u0026ldquo;base.group_user,base.group_system\u0026rdquo; 。 states传入依赖 state字段值的 UI 属性字典映射值。可用属性有readonly、required和invisible，例如states={\u0026lsquo;done\u0026rsquo;:[(\u0026lsquo;readonly\u0026rsquo;,True)]} 。 小贴士：注意states 字段等价于视图中的 attrs 属性。同时注意视图也支持 states 属性，但用途不同，传入逗号分隔的状态列表来控制元素什么时候可见。\n以下为使用了所有字段属性关键字参数的name字段示例：\nname = fields.Char( \u0026#34;Title\u0026#34;, default=None, help=\u0026#34;Book cover title.\u0026#34;, readonly=False, required=True, index=True, copy=False, deprecated=True, groups=\u0026#34;\u0026#34;, states={}, ) 此前的Odoo版本支持oldname=\u0026ldquo;field\u0026rdquo; 属性，用于在新版本中重命名字段。将旧字段的数据在模块升级过程中自动拷贝到新字段。\nOdoo 13中的变化\n移除了oldname字段属性，不再可用。替代方式是使用迁移脚本。\n以上是通用的字段属性，可用于所有字段类型。接下来我们要学习对字段设置默认值。\n设置默认值 如前所述，default 属性可带有固定值，或引用函数来动态计算默认值。\n对于简单运算，可使用 lambda 函数来避免过重的有名函数或方法的创建。以下是一个计算当前日期和时间默认值的常用示例：\nlast_borrow_date = fields.Datetime( \u0026#39;Last Borrowed On\u0026#39;, default=lambda self: fields.Datetime.now(), ) default的值也可以是一个函数引用。可以是名称引用或函数名字符串。\n下例中使用了对 _default_last_borrow_date函数方法的名称引用：\n或待定义函数名字符串：\ndef _default_last_borrow_date(self): return fields.Datetime.now() last_borrow_date = fields.Datetime( \u0026#39;Last Borrowed On\u0026#39;, default=_default_last_borrow_date, ) 下例的作用相同，但使用函数名称字符串：\nlast_borrow_date = fields.Datetime( \u0026#39;Last Borrowed On\u0026#39;, default=\u0026#34;_default_last_borrow_date\u0026#34;, ) def _default_last_borrow_date(self): return fields.Datetime.now() 后一种方法，函数名的解析延迟至运行时，而不是在Python文件加载的时候。因此，在第二个示例中，我们可以引用在代码中靠后声明，而第一个示例中，必须在使用前声明函数。\n然而普遍的代码规范是在字段定义之前定义默认值函数。另外使用第一个例子中的函数名引用有一个好处，如果支持静态代码分析的话代码编辑器可以监测到类型错误。\n自动字段名 一些字段名很特别，可能是因为它们出于特殊目的作为 ORM 保留字，或者是由于内置功能使用了一些默认字段名。\nid 字段保留用作标识每条记录的自增数字以及数据库主键，每个模型都会自动添加。\n以下字段只要模型中没设置 _log_access=False都会在新模型中自动创建：\ncreate_uid为创建记录的用户 create_date是记录创建的日期和时间 write_uid是最后修改记录的用户 write_date是最后修改记录的日期和时间 每条记录的这些字段信息都可通过开发者菜单下的View Metadata进行查看。\n上述的这些字段名在Odoo框架中有特殊含义。除它们之外，还有一些字段名用作Odoo某些功能的默认字段。在下一节中进行讲解。\n保留字段名 一些内置 API 功能默认需要一些指定字段名。这些是保留字段名，应避免误用。\n这些保留字段如下：\nChar类型的name或x_name：默认用作记录的显示名称。其它字段也可使用 _rec_name模型属性设置显示名称。非字符字段类型也可使用它，会强制将数据转化为文本。 布尔类型的active和x_active： 允许我们关闭记录，让记录隐藏。带有active=False的记录会自动从查询中排除掉，除非是在环境上下文中添加 {\u0026lsquo;active_test\u0026rsquo;: False} 。它可用于记录存档或假删除（soft delete）。 Selection类型的state： 表示记录生命周期的基本状态。它允许使用states字段属性动态设置为readonly、required或invisible，例如states={\u0026lsquo;draft\u0026rsquo;: [(\u0026lsquo;readonly\u0026rsquo;, False)]} 。 多对一字段的parent_id：用于定义树状层级结构，在域表达式中启用child_of和parent_of运算符。用作parent_id的字段可使用 _parent_name模型属性设置为其它字段。 Char类型的parent_path：用于在域表达式中优化child_of和parent_of运算符的使用。为正常操作，用add index=True来使用数据库索引。我们会在本章稍后的层级关联一节中进行讨论层级关联。 Many2one类型的company_id：用于标识记录所属的公司。留空表示记录在各个公司中共享。通过 _check_company函数对公司数据一致性进行内部检查。 Odoo 14中的变化\nx_active现在进行了重组，和active字段的效果一致。引用它是为了更好的支持开发者模式或Odoo Studio应用的自定义。\n到目前为止我们讨论的都是非关联字段。但应用数据结构中很大一部分是描述实体间关联的。下面就一起来学习。\n模型间的关联 中大型业务应用需要在涉及到的不同实体间的使用关联。要予以实现，需要使用关联字段。\n再来看看我们的图书应用，图书模型中有如下关联：\n每本书有一个出版社，每个出版社有多本书。从书的视角看，这是一种多对一关联。通过有数据库的一个整型字段实现，存储关联出版社记录的 ID，并放一个数据库外键来强化引用的正确性。 反过来，从出版社的角度看，是一对多关联，即出版社可以出版多本书。虽然这也是一种Odoo字段类型，但其数据库层面依赖于多对一关联。我们通过对图书查询知道了关联的出版社，过滤出出版社ID。 每本书可以有多名作者，每个作者可以写多本书。这是多对多关联。反过来还是多对多关联。在关联的数据库中，多对多关联通过一个辅助数据表来实现。Odoo会自动进行处理，当然我们希望的话也可以通过技术进行掌控。 下面的小节中我们就会分别讨论这些关联。\n具体的用例就是层级关联，即一个模型中的记录与同模型中的其它记录关联。我们将引入一个图书分类模型讲解这一情况。\n最后，Odoo 框架还支持弹性关联，即一个字段可与多个模型建立关联，这称为引用字段。\n多对一关联 多对一关联是对其它模型中记录的引用。例如在图书模型中，publisher_id表示图书出版社，是对partner记录的一个引用。\n以防忘记，如下是使用纯位置参数定义的出版社字段：\npublisher_id = fields.Many2one( \u0026#39;res.partner\u0026#39;, \u0026#39;Publisher\u0026#39;) 以上多对一字段定义使用了位置参数：\n第一个位置参数是关联模型，对应comodel关键字参数，本例中的值为res.partner。 第二个位置参数是字段标签，对应string关键字参数。但它和其它关联字段不同，所以推荐一直使用string关键字参数。 多对一模型字段在数据表中创建一个字段，并带有指向关联表的外键，其中为关联记录的数据库 ID。\n关键字参数用用于代替或补充位置参数。以下是多对一字段所支持的的关键字参数：\nondelete定义关联记录删除时执行的操作，可使用如下行为\nset null (默认值): 关联字段删除时会置为空值 restricted：抛出错误阻止删除 cascade：在关联记录删除时同时删除当前记录 context是一个数据字典，可在浏览关联时为网页客户端传递信息，比如设置默认值。第八章 Odoo 15开发之业务逻辑 - 业务流程的支持中会做深入讲解。\ndomain是一个域表达式：使用一个元组列表过滤记录来作为关联记录的选项，第八章 Odoo 15开发之业务逻辑 - 业务流程的支持中会详细讲解。\nauto_join=True在使用该关联进行搜索时允许ORM使用SQL连接。使用时会跳过访问权限规则，用户可以访问权限规则不允许其访问的关联记录，但这样 SQL 的查询会更快。\ndelegate=True 创建关联记录的代理继承。使用时还必须设置required=True和ondelete=\u0026lsquo;cascade\u0026rsquo; 。代理继承更多知识参见第四章 Odoo 15开发之模块继承。\n一对多反向关联 一对多关联是多对一关联的反向关联。它列出引用该记录的关联模型记录。\n比如在图书模型中，publisher_id字段与 parnter 模型是一个多对一关联。这说明partner与图书模型可以有一个一对多的反向关联，列出每个出版商出版的图书。\n在创建一对多关联前，应在其关联模型中创建一个多对一关联。为此，在library_app/models/res_partner.py文件中添加如下代码：\nfrom odoo import fields, models class Partner(models.Model): _inherit = \u0026#39;res.partner\u0026#39; published_book_ids = fields.One2many( \u0026#39;library.book\u0026#39;, # 关联模型 \u0026#39;publisher_id\u0026#39;, # fields for \u0026#34;this\u0026#34; on related model string=\u0026#39;Published Books\u0026#39;) 我们向模块添加了新文件，所以不要忘记在library_app/models/init.py中导入该文件：\nfrom . import library_book from . import res_partner One2many字段接收三个位置参数：\n关联模型 ，对应comodel_name关键字参数 引用该记录的模型字段 ，对应inverse_name关键字参数 字段标签 ，对应string关键字参数 其它可用的关键字参数与多对一字段相同：context、domain、auto_join和ondelete（此处作用于关联中的 many 这一方）。\n多对多关联 在两端都存在对多关联时使用多对多关联。还是以我们的图书应用为例，书和作者之间是多对多关联：一本书可以有多个作者，一个作者可以有多本书。\n图书端有的library.book模型，有如下定义：\nclass Book(models.Model): _name = \u0026#39;library.book\u0026#39; author_ids = fields.Many2many( \u0026#39;res.partner\u0026#39;, string=\u0026#39;Authors\u0026#39;) 在作者端，我们也可以为res.partner添加一个反向关联：\nclass Partner(models.Model): _inherit = \u0026#39;res.partner\u0026#39; book_ids = fields.Many2many( \u0026#39;library.book\u0026#39;, string=\u0026#39;Authored Books\u0026#39;) Many2many最小化签名要包含一个关联模型位置参数（comodel_name关键字参数），推荐使用string参数添加字段标签。\n在数据库层面上，多对多关联不会在已有表中添加任何字段。而是自动创建一个关联表来存储记录间的关联，这张特殊的表仅有两个 ID 字段，为两张关联表的外键。\n默认关联表名由两个表名中间加下划线并在最后加上 _rel 来组成。本例的图书和作者关联，表名应为library_book_res_partner_rel。\n有时我们可能需要重写这种自动生成的默认值。一种情况是关联模型名称过长，导致自动生成的关联表名的长度超出PostgreSQL数据库63个字符的上限。这时就需要手动选择一个关联表名来符合字符数的要求。\n另一种情况是我们需要在相同模型间建立第二个多对多关联。这时也需要手动提供一个关联表名来避免与已存在的第一张表名冲突。\n有两种方案来重写关联表名：位置参数或关键字参数。\n通过字段定义的位置参数的示例如下：\n# Book \u0026lt;-\u0026gt; Authors关联(使用位置参数) author_ids = fields.Many2many( \u0026#39;res.partner\u0026#39;, # 关联模型（尾款） \u0026#39;library_book_res_partner_rel\u0026#39;, # 要使用的关联表名 \u0026#39;a_id\u0026#39;, # 本记录关联表字段 \u0026#39;p_id\u0026#39;, # 关联记录关联表字段 \u0026#39;Authors\u0026#39;) # string标签文本 要使可读性更强，也可使用关键字参数：\n# Book \u0026lt;-\u0026gt; Authors关联(使用关键字参数) author_ids = fields.Many2many( comodel_name=\u0026#39;res.partner\u0026#39;, # 关联模型(必填) relation=\u0026#39;library_book_res_partner_rel\u0026#39;, # 关联表名 column1=\u0026#39;a_id\u0026#39;, # 本记录关联表字段 column2=\u0026#39;p_id\u0026#39;, # 关联记录关联表字段 string=\u0026#39;Authors\u0026#39;) # string标签文本 以下为此处使用的参数：\ncomodel_name 是关联模型的名称。 relation 是支撑关联数据的数据表名。 column1 是指向模型记录的字段名。 column2 是指向关联模型记录的字段名。 string 是用户界面中的字段标签。 与一对多关联字段相似，多对对字段还可以使用context、domain和auto_join这些关键字参数。\n小贴士：在抽象模型中，多对多字段不要使用column1和column2属性。在 ORM 设计中对抽象模型有一个限制，如果指定关联表列名，就无法再被正常继承。\n父子关联是值得深入研究的特定情况。下一节中我们进行学习。\n层级关联 父子树状关联使用同一模型中多对一关联表示，其中每条记录指向其父级。反向的一对多关联表示记录的直接子级。\nOdoo 通过域表达式所带的child_of和parent_of运算符改良了对这些层级数据结构的支持。只要这些模型有parent_id字段（或 _parent_name有效模型定义，设置替代的字段名）就可以使用这些运算符。\n通过设置 _parent_store=True模型属性和添加parent_path辅助字段可加快等级树的查询速度。该辅助字段存储用于加速查询速度的层级树结构信息。\nOdoo 12中的变化\nparent_path辅助字段在 Odoo 12中引入。此前版本中使用parent_left和parent_right整型字段来实现相同功能，但在 Odoo 12中弃用了这些字段。\n为演示层级结构，我们将为图书应用添加一个分类树，用于为图书分类。\n在library_app/models/library_book_category.py文件中添加如下代码：\nfrom odoo import api, fields, models class BookCategory(models.Model): _name = \u0026#39;library.book.category\u0026#39; _description = \u0026#39;Book Category\u0026#39; _parent_store = True name = fields.Char(translate=True, required=True) # Hierarchy fields parent_id = fields.Many2one( \u0026#39;library.book.category\u0026#39;, \u0026#39;Parent Category\u0026#39;, ondelete=\u0026#39;restrict\u0026#39;) parent_path = fields.Char(index=True) # Optional but good to have: child_ids = fields.One2many( \u0026#39;library.book.category\u0026#39;, \u0026#39;parent_id\u0026#39;, \u0026#39;Subcategories\u0026#39;) 这里定义了一个基本模型，包含指向父级记录的parent_id字段。\n为更快的树级搜索，添加了一个 _parent_store=True 模型属性。使用该属性必须还要添加parent_path字段，并为其建索引。指向父级的字段名应为parent_id，但如果声明了可选的 _parent_name模型属性，则可以使用其它字段名。\n添加字段列出直接的子非常方便。即为上述代码中的一对多反向关联。\n还有不要忘记在library_app/models/__init__.py文件中添加对以上代码的引用：\nfrom . import library_book from . import res_partner from . import library_book_category 注意这些增加的运算占用存储并且存在执行时间的消耗，所以适于读多写少的场景使用，如本例中的分类树。仅在优化多节点的深度层级时有必要使用，在小层级或浅等级场景可能会被误用。\n使用引用字段的弹性关联 普通关联字段只能指向一个固定的关联模型，但Reference字段类型不受这一限制，它支持弹性关联，因此同一字段可指向多个目标模型。\n作为示例，我们为图书分类模型来添加引用字段，来表示重点图书或作者。因此该字段可引用图书或 partne记录：\nhighlighted_id = fields.Reference( [(\u0026#39;library.book\u0026#39;, \u0026#39;Book\u0026#39;), (\u0026#39;res.partner\u0026#39;, \u0026#39;Author\u0026#39;)], \u0026#39;Category Highlight\u0026#39; ) 该字段定义与 Selection 字段相似，但这里选择列表的内容为用于该字段的模型。在用户界面中，用户会先选择列表中的模型，然后选择模型中的指定记录。\n引用字段可以字符字段存储在数据库中，包含 、 字符串。\nOdoo 12中的变化\n在此前Odoo版本中通过菜单Settings \u0026gt; Technical \u0026gt; Database Structure配置在引用字段中可用的模型。这些配置可通过在模型选择列表中添加odoo.addons.res.res_request.referenceable_models函数，在引用字段在中使用这些配置。Odoo 12中删除了这一配置。\n这样我们就学习了Odoo所支持的字段类型。字段不仅能存储用户添加的数据，还能展示计算值。在下一节中讨论这一功能。\n计算字段 字段值除普通的读取数据库中存储值外，还可自动由函数计算。计算字段的声明和普通字段相似，但有一个额外的compute参数来定义用于计算的函数。\n计算字段包含部分业务逻辑的编写。因此要完全使用这一功能，还应熟悉第八章 Odoo 15开发之业务逻辑 - 业务流程的支持中讲解的知识。此处我们将解释计算字段用法，但业务逻辑会尽量保持简单。\n我们的例子为Books模型添加计算字段，显示出版商的国家。这样会在表单视图中显示国家。\n找到该值的代码很简单：如果book表示图书记录。可使用点号标记符book.publisher_id.country_id获取出版商的国家。\n编辑library_app/models/library_book.py文件中的图书模型，代码如下：\npublisher_country_id = fields.Many2one( \u0026#39;res.country\u0026#39;, string=\u0026#39;Publisher Country\u0026#39;, compute=\u0026#39;_compute_publisher_country\u0026#39; ) @api.depends(\u0026#39;publisher_id.country_id\u0026#39;) def _compute_publisher_country(self): for book in self: book.publisher_country_id = book.publisher_id.country_id 首先，以上代码添加了一个publisher_country_id字段，和一个计算属性，包含计算其值的 _compute_publisher_country方法。\n方法以字符串参数传入字段中，但也可以传递一个可调用引用(方法标识符，不带引号)。但这时需确保Python 文件中方法在字段之前定义。\n计算方法名的代码规范是在计算字段名前加上 compute 前缀。\n_compute_publisher_country方法接收self记录集来进行运算，应当设置所有这些记录的计算字段值。要对self记录集进行遍历来设置所有记录。\n计算的值通过常规的赋值（写入）操作进行设置。本例中的计算相当简单：使用当前图书的publisher_id.country_id值对其赋值。\n小贴士： 同一计算方法可用地对两个或多个字段进行计算。此时，方法应用于所计算字段的compute属性中，计算方法应为所有这些字段赋值。\n计算方法必须要对一个或多个字段赋值。如果计算方法有 if 条件分支，确保每个分支中为计算字段赋了值。否则在未赋值的分支中将会报错。\nODOO 13中的变化\nOdoo 13引入了计算可写字段，准备在未来替换掉onchange机制。计算可写字段有一个计算逻辑，在依赖发生变化时触发，还允许用户直接设置其值。这一机制会在第八章 Odoo 15开发之业务逻辑 - 业务流程的支持中和onchange一起讲解。\n需要 @api.depends装饰器指定计算所依赖的字段。ORM使用它来知晓何时触发计算更新存储值或缓存值。可接受一个或多个字段名参数并可使用点号标记法来跟踪字段关联。本例中，在publisher_id.country_id发生变化时应当重新计算publisher_country_id字段。\n警告：\n忘记对计算字段添加 @api.depends装饰器或是没有添加计算使用的所有依赖字段，计算字段就不会按计划重新计算。这种bug很难发现。\n可通过在图书表单视图中添加publisher_country_id字段来查看效果，位于library_app/views/library_book.xml文件中。在网页中查看时要确保所查看的记录已选择了有国家的出版商。\n搜索和写入计算字段 我们刚刚创建的计算字段可读取但不可搜索或写入。默认情况下计算字段是实时计算的，值不存储在数据库中。这也是无法像普通字段那样进行搜索的原因。\n突破这种限制的一种方式是通过添加store = True属性让计算的值存储在数据库中。在任一依赖发生变化时就会重新计算。因为值进行了存储，所以就可以像普通字段那样进行搜索，无需搜索函数。\n计算字段还支持不进行存储的搜索及写入操作。可通过和计算方法一并实现特殊的方法来达成：\nsearch方法来实现搜索逻辑 inverse方法来实现写入逻辑 使用这些方法，可修改计算字段的声明如下：\npublisher_country_id = fields.Many2one( \u0026#39;res.country\u0026#39;, string=\u0026#39;Publisher Country\u0026#39;, compute=\u0026#39;_compute_publisher_country\u0026#39;， inverse=\u0026#39;_inverse_publisher_country\u0026#39;, search=\u0026#39;_search_publisher_country\u0026#39;, ) 计算字段中的写入是计算的反向(inverse)逻辑。因此处理写入操作的方法称为 inverse。\n本例中设置publisher_country_id的值会修改出版商的国家。\n注意这也会改变同一出版商所有图书中看到的值。常规的权限控制同样适用于这些写操作，因此仅在当前用户对partner模型也具有写权限时才会成功。\ninverse方法的实现使用值对计算字段进行设置，执行需让修改持久化所需的实际写操作：\ndef _inverse_publisher_country(self): for book in self: book.publisher_id.country_id = book.publisher_country_id 原始的值运算将book.publisher_id.country_id的值拷贝到book.publisher_country_id字段中。逆向运算如以上代码所示，进行了反向操作。读取book.publisher_country_id 所设置的值并写入到book.publisher_id.country_id字段中。\n要为计算字段开启搜索操作，需要实现search 方法。search方法拦截计算字段上运行的域表达式，然后用仅使用普通存储字段的替代域表达式进行替换，\n在publisher_country_id的示例中，实际的搜索是对关联的publisher_id相应记录的country_id字段进行操作。翻译为方法实现如下：\ndef _search_publisher_country(self, opearator, value): return [(\u0026#39;publisher_id.country_id\u0026#39;, operator, value)] 在模型上执行搜索时，域表达式元组是参数，提供运算符的详情以及域表达式中使用的值。\nsearch方法在域表达式的条件中存在该计算字段时触发。接收搜索所需要的运算符和值，然后转译为原始搜索元素再加到替代的搜索或表达式中。country_id字段存储在关联的partner模型中，因此我们的搜索实现仅需修改原搜索表达式为使用publisher_id.country_id字段。\n有关域表达式在第八章 Odoo 15开发之业务逻辑 - 业务流程的支持会做详细讲解。\n关联字段 前面一节我们实现的计算字段仅仅是从关联记录中将值拷贝到模型自己的字段中。通常用于在表单中显示关联记录的字段。Odoo框架为此提供了一种简写：关联字段（related field）功能。\n关联字段令关联模型中的字段在当前模型中可用，通过点号标记调用链访问。这让那些点号标记符本无法使用之处可以访问关联字段，如UI表单视图。\n要创建关联字段，需要声明所需类型的字段，还要使用related属性，通过点号标记字段链来访问目标关联字段。\n关联字段可用于达到与前述publisher_country_id计算字段相同的效果。\n使用关联字段的实现如下：\npublisher_country_id = fields.Many2one( \u0026#39;res.country\u0026#39;, string=\u0026#39;Publisher Country\u0026#39;, related=\u0026#39;publisher_id.country_id\u0026#39;, ) 本质上关联字段仅仅是快捷实现 search 和 inverse 方法的计算字段。也就是说可以直接对其进行搜索和写入。\n默认关联字段是只读的，因而反向的写操作不可用。可通过设置readonly=False字段属性来开启写操作。\nOdoo 12中的变化\n此前的Odoo版本中，关联字段默认可写，但实践证明这个默认值很危险，因为它可能在未允许的情况下修改配置或主数据。因此，从Odoo 12开始，关联字段默认为只读：readonly=True。\n值得一提的是关联字段也可以像其它计算字段一样使用store=True将值存储在数据库中。\n这样我们就学习完了Odoo字段所支持的功能，包括计算字段。另一个有关数据结构的重要元素是约束，强化数据质量和完备性。我们在下一节中讨论。\n模型约束 通常应用需保证数据完备性，并执行一些验证来保证数据是完整和正确的。\nPostgreSQL数据库管理器支持很多有用的验证：如避免重复，或检查值以符合某些简单条件。Odoo模型可以利用 PostgreSQL约束功能。\n一些检查要求更复杂的逻辑，最好是使用 Python 代码来实现。对于这些情况，我们可使用特定的模型方法来实现 Python 约束逻辑。\n我们一起来学习这两种方式。\nSQL模型约束 SQL约束加在数据表定义中，并由PostgreSQL直接执行。借由 _sql_constraints类属性来定义。\n这是一个元组组成的列表，并且每个元组的格式为 (name, sql, message) ：\nname是约束标识名 sql是约束的PostgreSQL语法 message是在约束验证未通过时向用户显示的错误消息 最常用的SQL约束，用于防止重复数据，还有CHECK约束，用于使用SQL表达式对数据进行测试。\n举个例子，我们为Book模型添加两个约束：\n确保没有带相同标题和出版日期的重复书籍。 确保出版日期不是未来的日期。 编辑library_app/models/library_book.py文件添加如下代码实现这两个约束。通常会把它放在字段声明的代码之后：\n_sql_constraints = [ (\u0026#39;library_book_name_date_uq\u0026#39;, # 约束唯一标识符 \u0026#39;UNIQUE (name, date_published)\u0026#39;, # 约束 SQL 语法 \u0026#39;Book title and publication date must be unique\u0026#39;), # 消息 (\u0026#39;library_book_check_date\u0026#39;, \u0026#39;CHECK (date_published \u0026lt;= current_date)\u0026#39;, \u0026#39;Publication date must not be in the future.\u0026#39;), ] 更多有关PostgreSQL约束语法，请参见官方文档。\nPython模型约束 Python 约束可使用自定义代码来执行验证。验证方法应添加@api.constrains装饰器，并且包含要检查的字段列表。其中任意字段被修改就会触发验证，并且在未满足条件时抛出异常，通常报的是ValidationError。\n就图书应用来说，一个明显的示例就是防止插入不正确的 ISBN 号。我们已经在 _check_isbn() 方法中编写了 ISBN 的校验逻辑。可以在模型约束中使用它来防止保存错误数据。\n编辑library_app/models/library_book.py文件，在文件顶部添加导入语句：\nfrom odoo.exceptions import ValidationError 接下来在同一个文件中为Book类添加如下代码\n@api.constrains(\u0026#39;isbn\u0026#39;) def _constrain_isbn_valid(self): for book in self: if book.isbn and not book._check_isbn(): raise ValidationError(\u0026#39;%s is an invalid ISBN\u0026#39; % book.isbn) Python约束通常放在字段声明的代码之前。\nOdoo的 base 模型总览 在前面文章中，我们一起新建了模型，如图书模型，但也使用了已有的模型，如 Odoo base模块自带的Partner 模型。下面就来介绍下这些内置模型。\nOdoo框架内核中有一个base插件模块。它提供了 Odoo 应用所需的基本功能。位于Odoo代码库的 ./odoo/addons/base子目录中。\n提供了Odoo中的官方应用和功能的标准插件模块，依赖并基于base模块构建。标准插件位于Odoo代码库的 ./addons子目录中。\nbase模块中包含两类模型：\n信息仓库(Information Repository)， ir.* 模型 资源(Resources)， res.* 模型 信息仓库用于存储 Odoo 框架所需的基础数据，如菜单、视图、模型、动作等。Technical菜单下的数据通常都存储在信息仓库模型中。\n相关的例子有：\nir.actions.act_window用于窗口动作 ir.config_parameter用于全局配置项 ir.ui.menu用于菜单项 ir.ui.view用于视图 ir.model用于模型 ir.model.fields用于模型字段 ir.model.data用于XML ID 资源模型存储所有模块所使用的基础主数据。\n以下是一些重要的资源模型：\nres.partner用于业务伙伴，如客户、供应商和地址 res.company用于公司数据 res.country用于国家 res.country.state用于国家内的州或区域 res.currency用于货币 res.groups用于应用权限组 res.users用于应用用户 这些应该有助于你在未来遇到这些模型时理解它们来自何处。\n总结 学习完本章，我们熟悉了各种模型类型，如临时模型和抽象模型，以及它们对于用户界面向导和mixin中间件的用处。其它的模型功能有Python和SQL约束，可用于防止数据词条错误。\n我们还学习了可用的字段类型，以及它们所支持的所有属性，这样可以尽可能精确的方式表示业务数据。我们也学习了关联关系字段，以及如何使用它们创建应用所需的不同实体间的关联关系。\n然后，我们了解到模型通常继承models.Model类，但也可以使用models.Abstract来创建可复用的mixin，使用models.Transient来创建向导或高级用户交互对话框。我们学习了常用的模型属性，如 _order用于排序， _rec_name指定记录展示时默认使用的字段。\n模型中的字段定义了所有要存储的数据。同时了解了非关联字段类型及它们支持的属性。我们也学习了一些关联字段类型：多对一、一对多和多对多，以及如何在模型间定义关联，包括层级父子关联。\n大部分字段在数据库中存储用户的输入，但字段也可以通过 Python 代码自动计算值。我们学习了如何实现计算字段，以及一些高级用法，如使计算字段可写及可搜索。\n模型定义还有一部分是约束，强化数据一致性和执行验证。可以通过PostgreSQL或Python代码实现。\n一旦我们创建了数据模型，就应该为它提供一些默认和演示数据。在下一章中我们将学习如何使用数据文件在系统中导入、导出和加载数据。\n扩展阅读 有关模型的官方文档。\n"
},
{
	"uri": "/odoo/7/",
	"title": "第七章 Odoo 15开发之记录集 - 使用模型数据",
	"tags": [],
	"description": "",
	"content": "在前面的章节中，我们概览了模型创建以及如何向模型加载数据。现在我们已有数据模型和相关数据，是时候学习如何编程与其进行交互了。\n业务应用需要业务逻辑来计算数据、执行验证或自动化操作。Odoo框架API为开发者提供了工具用于实现这种业务逻辑。大多数时候是查询、转换及写入数据。\nOdoo在底层数据库之上实现了一个ORM（对象关系映射）层。ORM提供了API（应用程序接口）用于与数据交互。这种API提供了一个执行环境以及记录集的创建，供对象操作数据库中存储的数据。\n本单讲解如何使用执行环境和记录集，通过所需要的工具实现业务处理。\n本章主要讲解以下内容：\n使用 shell 命令交互式地学习 ORM API 理解执行环境和上下文 使用记录集和作用域(domain)查询数据 访问记录集中的数据 在记录中写入 处理日期和时间 使用记录集 事务和底层 SQL 学完本章后，读者可以使用Odoo代码执行所有这些操作，还可使用这些工具来实现自己的业务处理。\n开发准备 本章代码使用交互式 shell 命令行执行，无需使用前面章节的代码。相关代码参见 GitHub 仓库的ch07/ch07_recorsets_code.py文件。\n使用 shell 命令行 Python带有命令行界面，是研究其语法一个很好的方式。Odoo 也有类似的功能，这就是 shell 命令行。可以交互式地执行命令了解其机制。\n使用这种命令行，在启动Odoo时加上shell，以及通常启动Odoo所使用的那些选项：\n在命令行中执行以下命令并指定数据库即可使用：\n(env15) $ odoo shell -c library.conf 此时在终端中可以看到正常的服务启动信息，但这时不是启动监听请求的HTTP服务，而是会进行一个等待输入的Python命令窗口。\n这一交互式命令界面模拟了以OdooBot超级用户运行class方法内的环境。可以使用self变量，它被设置为OdooBot超级用户记录对象。\n例如，使用如下命令查看self记录集：\n\u0026gt;\u0026gt;\u0026gt; self res.users(1,) \u0026gt;\u0026gt;\u0026gt; self._name \u0026#39;res.users\u0026#39; \u0026gt;\u0026gt;\u0026gt; self.name \u0026#39;OdooBot\u0026#39; \u0026gt;\u0026gt;\u0026gt; self.login \u0026#39;__system__\u0026#39; 以下命令打印的内容如下：\nself变量含res.users记录集，仅包含一条 id 为1的记录 查看self._name获得记录集模型名res.users 记录的 name 字段值为OdooBot 记录的 login 字段值为__system__ Odoo 12中的变化 ID号为1的超级用户由原来的 admin 变成内部用户__system__。现在 admin 的 ID 号为 2并且不是超级用户，但默认各标准应用会自动为其授予所有权限。主要原因是避免用户使用超级用户账号来执行日常操作。这样的风险是该用户会跳过权限规则并导致数据的不一致，比如跨公司关联。现在超级用户仅用于查找问题或具体的跨公司操作。\n和 Python 一样，可通过 Ctrl + D退出该命令行。此时会结束服务并返回到系统shell 命令行。\n现在我们学习了如何启动Odoo shell会话。这对于查看Odoo API功能非常重要。下面就进行一步学习其执行环境。\n执行环境 Odoo记录集在环境上下文中进行操作，提供一个触发操作的上下文相关信息。例如使用了数据库游标、当前Odoo用户等等。\n在模型方法中运行的Python代码可以访问self记录集变量，可通过self.env访问本地环境。服务端shell环境也提供了一个self指针，和方法中的用法类似。\n本节中我们学习执行上下文中的那些属性以及如何使用它们。\n环境属性 我们已经知道self是一个记录集。记录集携带环境信息，像浏览数据的用户以及其它上下文相关信息（如，使用的语言和时间）。\n可使用记录集的env属性访问当前环境，如下例所示：\n我们可通过如下代码查看当前环境：\n\u0026gt;\u0026gt;\u0026gt; self.env \u0026lt;odoo.api.Environment object at 0x7f9fb92e0fa0\u0026gt; self.env 中的执行环境中有以下属性：\nenv.cr是正在使用的数据库游标(cursor) env.user是当前用户的记录 env.uid是会话用户 id，与env.user.id相同 env.context是会话上下文数据中的不可变字典 env.company是当前公司 env.companies用户的许可公司 ODOO 13中的变化\nOdoo 13中引入了env.company和env.companies。此前版本中这一信息通过使用env.user.company_id和env.user.company_ids在用户记录中读取。\n环境还提供对带有所有已安装模型注册表的访问，如self.env[\u0026lsquo;res.partner\u0026rsquo;]返回partner 模型的指针。然后我们还可以对其使用search()或browse()方法来获取记录集：\n\u0026gt;\u0026gt;\u0026gt; self.env[\u0026#34;res.partner\u0026#34;].search([(\u0026#34;display_name\u0026#34;, \u0026#34;like\u0026#34;, \u0026#34;Azure\u0026#34;)]) res.partner(14, 26, 33, 27) 上例中返回的res.partner模型记录集包含四条记录，id 分别为14、26、33和27。记录集并没有按 id 排序，因为使用了相应模型的默认排序。就 partner 模型而言，默认的 _order为display_name。\n环境上下文 环境上下文是一个带有会话数据的字典，可用于客户端用户界面以及服务端 ORM 和业务逻辑中。\n在客户端中，它可以把信息从一个视图带到另一个视图中，比如在点击链接或按钮后，携带前一个视图中活跃的记录 id，它也可提供下一个视图中使用的默认值。\n在服务端中，一些记录集的值会依赖于上下文提供的本地化设置。具体的例子有影响可翻译字段值的lang键。\n上下文还可为服务端代码提供信号。比如active_test键在设为 False 时，会改变ORM中search() 方法的行为，它会忽略记录中的active标记，inactive(假删除)的记录也会被返回。\n客户端的初始上下文长这样：\n\u0026gt;\u0026gt;\u0026gt; self.env.context {\u0026#39;lang\u0026#39;: \u0026#39;en_US\u0026#39;, \u0026#39;tz\u0026#39;: \u0026#39;Europe/Brussels\u0026#39;} 补充：还可使用self.context_get()进行获取\n其中 lang 键为用户语言，tz 为时区信息。记录中的内容随当前的上下文可能会不同：\n可翻译字段根据活跃的 lang 语言不同值也会不同 日期字段根据活跃的的 tz 时区不同显示时间会不同 在上一个视图中点击链接或按钮打开视图时，网页客户端会对上下文自动添加一些键，提供我们所浏览记录的信息：\nactive_model为前一个模型名 active_id为用户所位于的原始记录的ID active_ids为用户浏览列表视图时所选中的ID列表 向导助手经常使用这些键来查找所要操作的那些记录。\n通过对键使用如下前缀上下文可用于设置配置值及对目标客户端视图启用默认过滤器：\n对字段名添加default_ 前缀为该字段设置默认值。例如 {\u0026lsquo;default_user_id\u0026rsquo;: uid} 将当前用户设置为默认值。 对过滤器名添加default_search_ 前缀会自动启用该过滤器。例如 {\u0026lsquo;default_search_filter_my_tasks\u0026rsquo;: 1} 会激活名为filter_my_books的过滤器。 这些前缀常用于窗口动作和视图的 \u0026lt;field context=\u0026quot;{...}\u0026quot;\u0026gt; 元素中。\n修改记录集执行环境和上下文 记录集执行上下文可进行修改，来使用前面小节所述的功能或者是对记录集调用的方法添加信息。\n环境和上下文可通过下述的一些方法进行修改。每个方法都返回新记录集，以及修改了环境的原始记录集拷贝：\n.with_context() 方法使用字典中的内容替换上下文。 .with_context(key=value, \u0026hellip;) 方法修改上下文对其设置所提供的属性。 .sudo([flag=True]) 方法启用或禁用可跳过权限规则的超级用户模式，上下文用户保持不变。 .with_user() 方法将用户修改为所提供的用户，可以传用户记录或ID号。 .with_company() 方法将公司修改为所提供的公司，可以传公司记录或ID号。 .with_env() 方法将记录集的所有上下文修改为所传的上下文。 ODOO 13中的变化\nOdoo 13中引入了with_user() 和with_company() 方法。此前的版本中切换用户使用sudo([]) 方法，可操作指定用户切换为超级用户上下文。此前版本中切换公司使用with_context(force=company=) ，设置一个在相关业务逻辑中选择的context键。\n此外环境对象还提供了一个env.ref() 函数，传入一个外部标识符字符串并返回相应记录，如下例所示：\n\u0026gt;\u0026gt;\u0026gt; self.env.ref(\u0026#39;base.user_root\u0026#39;) res.users(1,) 如果外部标识符不存在，会抛出ValueError异常。\n我们已更深入地学习了在Odoo服务端使用Python代码执行环境的知识。下一步要使用数据进行交互。这时首先要学习的是如何查询数据及创建数据集，在下一节中进行讨论。\n使用记录集和作用域查询数据 Odoo业务逻辑需要从数据库中读取数据执行操作。这通过记录集实现，通过查询原始数据并将其暴露至我们可操作的Python对象。\nOdoo中Python通常在类方法中运行，self表示要操作的记录集。有时，我们需要为其它模型创建记录集。这时应获取模型的指针，然后对其查询创建记录集。\n环境对象通常可通过self.env访问，保存对所有可用模型的引用，它们可通过类字典的语法访问。例如，获取对partner模型的引用，使用self.env[\u0026lsquo;res.partner\u0026rsquo;] 或self.env.get(\u0026lsquo;res.partner\u0026rsquo;) 。它个模型指针之后可用于创建记录集，我们在下面的小节学习。\n创建记录集 search() 方法接收一个域表达式然后返回符合条件记录的记录集。例如， [(\u0026rsquo;name\u0026rsquo;, \u0026rsquo;like\u0026rsquo;, \u0026lsquo;Azure\u0026rsquo;)] 会返回name字段包含Azure的所有记录。\n如果模型有特殊字段 active，默认只有active=True的记录才在选择范围内。\n还可以使用以下关键字参数：\norder关键字是数据库查询ORDER BY语句中使用的字符串。通常是一个逗号分隔的字段名列表。每个字段名都可接DESC关键字，用于表示倒序排列。 limit关键字设置获取记录的最大条数。 offset关键字忽略前 n 前记录，可配合limit使用来一次查询指定范围记录。 有时我们只要知道满足某一条件的记录条数。这时可使用search_count() 来有效地返回记录条数而非记录集。\nbrowse() 方法接收一个 ID 列表或单个ID然后返回这些记录的记录集。在我们知道 ID 并想要获取记录时这就非常方便了。\n例如，要获取显示名中包含Lumber的所有partner记录，使用如下的search() 调用：\n\u0026gt;\u0026gt;\u0026gt; self.env[\u0026#39;res.partner\u0026#39;].search([(\u0026#39;display_name\u0026#39;, \u0026#39;like\u0026#39;, \u0026#39;Lumber\u0026#39;)]) res.partner(15, 34) 知道所要查询的ID列表时，使用下例中的browse() 调用：\n\u0026gt;\u0026gt;\u0026gt; self.env[\u0026#39;res.partner\u0026#39;].browse([15, 34]) res.partner(15, 34) 大多数情况下都不知道这些ID，因而search() 方法比browse() 更常用。\n为更好地使用search() ，需要较好地掌握作用域过滤器的语法。因此，下一节中我们集中讨论。\n作用域表达式 作用域(domain)用于过滤数据记录。它使用一种特殊语法来供 Odoo ORM解析，生成数据库查询中的 WHERE 表达式。作用域表达式是一组条件组成的列表，每个条件都是一个 (\u0026lsquo;字段名\u0026rsquo;, \u0026lsquo;运算符\u0026rsquo;, \u0026lsquo;值\u0026rsquo;) 组成的元组，例如，下面这个是就有效的作用域表达式，只有一个条件： [(\u0026lsquo;is_done\u0026rsquo;, \u0026lsquo;=\u0026rsquo;, False)] .。作用域表达式也可以不加条件。这会转换成空列表( [] )，查询的结果是返回所有记录。\n在两种运行作用域上下文的方式：有客户端，如窗口动作和客户端视图，以及服务端，如权限记录规则和方法中的Python代码。字段名和值元素中可以使用的内容取决于运行上下文。\n下面我们来学习每个作用域条件的详细解释：字段名、运算符和值。\n作用域条件中的字段名元素 第一个条件元素是所需过滤字段的名称字符串。在服务端使用作用域表达式时，字段名元素可使用点号标记来访问关联模型的值。例如，我们可以使用 \u0026lsquo;publisher_id.name\u0026rsquo; ，甚至是 \u0026lsquo;publisher_id.country_id.name\u0026rsquo; 。\n客户端中不允许使用点号标记，仅能使用简单字段名。\n小贴士：在客户端中需要使用关联记录时，因为无法使用点号标记，解决方案时通过**related=**属性添加关联记录至模型中。这样，就可以直接访问模型字段获取该值。\n作用域条件中的运算符元素 第二条件元素为应用于所过滤条件的运算符。可以不用管的运算符如下：\n运算符 描述 = 等于 != 不等于 \u0026lt; 小于。在 XML 文件中，请使用\u0026lt; \u0026lt;= 小于等于。在 XML 文件中，请使用\u0026lt;= \u0026gt; 大于。在 XML 文件中，请使用\u0026gt; \u0026gt;= 大于等于。在 XML 文件中，请使用\u0026gt;= like 包含该字符串值。类似于使用任意匹配(_)的字符串。它会匹配任意单个字符串，%匹配任意一组字符。与=like并对搜索值周边添加%相同。 ilike 和 like 一样，但忽略大小写。 !ERROR! undefined variable \u0026rsquo;like\u0026rsquo; 搜索值时使用数据库的 like 运算符，在值中应用_和%任意值匹配。不似ilike那样在搜索值两边加%. !ERROR! undefined variable \u0026lsquo;ilike\u0026rsquo; 与 =like 相同，但忽略大小写。 in 查看字段值是否与值列表中的任意一项相等。其值应为一个列表，但单个值会被当成一元列表处理。 not in in 的反向运算。查看字段值是否不在值列表的子项中。 child_of 在所搜索字段定义了层级关联时，child_of查看记录是否为由值标识的记录的子级。 parent_of 在所搜索字段定义了层级关联时，parent_of查看记录是否为由值标识的记录的父级。 这些运算符应用于第一个元素中提供的字段，使用的是第三个元素是提供的值。如 (\u0026lsquo;shipping_address_id\u0026rsquo;, \u0026lsquo;child_of\u0026rsquo;, partner_id) 在运行上下文查看partner_id变量、读取其值。在数据库中查询shipping_address_id字段，选取地址是partner_id值中查找为其子级的记录。\n作用域条件中的值元素 第三个元素以Python表达式运行。可使用字面值，如数字、布尔值、字符串或列表，可使用运行上下文中的值和标识符。\n不接受记录对象。而应当使用相应记录的ID。例如，不能使用 [(\u0026lsquo;user_id\u0026rsquo;, \u0026lsquo;=\u0026rsquo;, user)] ，而应使用 [(\u0026lsquo;user_id\u0026rsquo;, \u0026lsquo;=\u0026rsquo;, user .id )] 。\n对于记录规则 ，运行上下文中有如下可使用的名称：\nuser: 当前用户的记录(等价于self.env.user)。使用user.id获取对应的ID。 company_id: 活跃公司记录的ID(等价于self.env.company.id)。 company_ids: 所允许公司的ID列表(等价于self.env.companies.ids)。 time: Python时间模块，提供日期和时间函数。请见官方手册。 ODOO 13中的变化\ncompany_id和company_ids上下文值自Odoo 13可在记录规则运算中使用，此前的版本使用的user.company_id.id不推荐再使用。例如，此前常用的 [\u0026rsquo;|\u0026rsquo;, (\u0026lsquo;company_id\u0026rsquo;, \u0026lsquo;=\u0026rsquo;, False), (\u0026lsquo;company_id\u0026rsquo;, \u0026lsquo;child_of\u0026rsquo;, [user.company_id.id])] 现在应写为 [(\u0026lsquo;company_id\u0026rsquo;, \u0026lsquo;in\u0026rsquo;, company_ids)] 。\n对多字段的搜索 在对对多字段进行搜索时，运算符作用于每个字段值，如果任意字段值匹配作用域条件的话运算的记录就会出现在结果中。\n=和in运算符类似于包含运算符。都查看任一字段值是否匹配所搜索值列表中的任意值。对应地， !=和not in运算符查找字段值中不匹配搜索值列表中的任意值。\n使用多个条件组合域表达式 域表达式是一个列表并且包含多个条件元组。默认这些条件使用AND逻辑运算符连接，也就是说它仅返回满足所有条件的记录。\n也可以使用显式逻辑运算符 - \u0026lsquo;\u0026amp;\u0026lsquo;符号表示 AND 运算符（默认值），管道运算符\u0026rsquo;|\u0026lsquo;表示OR运算符。这两个运算符会作用于接下来的两项，递归执行。后面我们会一起来详细了解。\n对于更为正式的定义，域表达式使用前缀标记法，也称波兰表达式(Polish notation)：运算符放在运算项之前。AND和OR是二元运算符，而NOT是一元运算符。\n感叹号\u0026rsquo;!\u0026lsquo;表示NOT运算符，可用于下一项的运算，因此要放在执行的否定项之前。例如 [\u0026rsquo;!\u0026rsquo;, (\u0026lsquo;is_done\u0026rsquo;,\u0026rsquo;=\u0026rsquo;,True)] 会过滤出所有未完成的记录。\n运算符，如 ! 和 | ，可进行嵌套，允许AND/OR/NOT复杂条件的定义。我们通过一个示例进行讲解。\n在服务端的记录规则中，我们可以看到类似下面这样的域表达式：\n[\u0026#39;|\u0026#39;, (\u0026#39;message_follower_ids\u0026#39;, \u0026#39;in\u0026#39;, [user.partner_id.id]), \u0026#39;|\u0026#39;, (\u0026#39;user_id\u0026#39;, \u0026#39;=\u0026#39;, user.id), (\u0026#39;user_id\u0026#39;, \u0026#39;=\u0026#39;, False) ] 这个域过滤出所有这样的记录：\n当前用记是一个关注者，或者 当前用户是记录的责任人(user_id)，或者 记录没有责任用户 下图是上例域表达式的抽象语法树表示：\n图7.1：描述组合作用域表达式的图\n第一个 | (OR)运算符作用于关注者的条件加下一个条件的结果。下一个条件又是另两个条件的并集：记录的用户ID设置为当前用户或者没有设置用户ID。\n特殊作用域条件 在都想要恒真或恒假时还支持使用一些特殊的作用域条件。\n(1, \u0026ldquo;=\u0026rdquo;, 1) 条件为一个恒真表达式。可以对记录规则使用它来为所有记录赋予一个更高的用户组权限。例如，使用User: All Documents 组重载原来受限的继承记录权限组User: Own Documents only。可在Odoo的源代码addons/sales_team/security/sales_team_security.xml中查看这一示例。\n还支持 (0, \u0026ldquo;=\u0026rdquo;, 1) ，它表示一个恒假的表达式。\n按字段分组以及聚合数据 有时我们需要按数据字段对记录分组。Odoo中可使用read_group() 方法。该方法的参数如下：\ndomain参数是过滤所获取记录的作用域表达式列表。 fields是一个字段名列表，配合聚合函数使用的格式为field:aggr。聚合函数为PostgreSQL内置支持的那些，如sum, avg, min, max, count和count_distinct。例如： [\u0026ldquo;subtotal:sum\u0026rdquo;] 。 groupby参数是一个所需分组的字段名列表。 limit参数是可选的最大返回分组数。 offset参数是可选的跳过的记录数。 orderby参数是可选的结果所使用的order by语句字符串（和search() 所支持的类似）。 lazy参数，若设置为True，仅按第一个字段进行分组，将剩余的分组字段添加至 __context结果中。这个参数的默认值是True，在设置为False时会立即应用所有的分组字段。 以下是按国家对partner记录分组并对不同状态计数的示例：\n\u0026gt;\u0026gt;\u0026gt; self.env[\u0026#34;res.partner\u0026#34;].read_group([(\u0026#34;display_name\u0026#34;, \u0026#34;like\u0026#34;, \u0026#34;Azure\u0026#34;)], fields=[\u0026#34;state_id:count_distinct\u0026#34;,], groupby=[\u0026#34;country_id\u0026#34;], lazy=False) [{\u0026#39;__count\u0026#39;: 4, \u0026#39;state_id\u0026#39;: 1, \u0026#39;country_id\u0026#39;: (233, \u0026lt;odoo.tools.func.lazy object at 0x7f38ac66fa80\u0026gt;), \u0026#39;__domain\u0026#39;: [\u0026#39;\u0026amp;\u0026#39;, (\u0026#39;country_id\u0026#39;, \u0026#39;=\u0026#39;, 233), (\u0026#39;display_name\u0026#39;, \u0026#39;like\u0026#39;, \u0026#39;Azure\u0026#39;)]}] 这会返回一个国家ID为233的单个分组结果列表。运行self.env[\u0026ldquo;res.country\u0026rdquo;].browse(233).name，可以看到国家为美国。 __count键显示国家ID为233的partner有4个，state_id对象显示去重聚合户数结果：这些用户为同一个1个国家。\n现在我们学习了如何创建记录集。接下来，我们要从其中读取数据。大多数情况下这是一个小型的操作，但对某些字段类型，有一些细节需要我们注意。下一节会帮助我们理解。\n在记录集中访问数据 一旦获取了数据集，就可以查看其中包含的数据了。下面的几个小节中我们就来探讨如何访问记录集中的数据。\n我们可以获取单条记录的字段值，称为单例(singleton)。关联字段带有特殊属性，我们可通过点号标记来查看关联记录。最后我们一起思考处理日期和时间记录以及进行格式转换。\n访问记录中数据 记录集中仅有一条记录时，称为单例。单例仍是记录集，在需要记录集的地方均可使用。\n与多元素记录集不同，单例可使用点号标记访问它的字段，如：\n\u0026gt;\u0026gt;\u0026gt; print(self.name) OdooBot 下个例子中我们看看同一个 self 单例和记录集相同的行为，我们可对其进行遍历。它只有一条记录，所以只会打印出一个名称：\n\u0026gt;\u0026gt;\u0026gt; for rec in self: print(rec.name) ... OdooBot 尝试访问有多条记录的记录集字段值会产生错误，所以在不确定操作的是否为单例数据集时就会是个问题。\n小贴士：虽然无法使用点号标记访问多记录中的记录，但可以通过将值与记录集进行映射来批量访问。这借由mapped() 实现。例如，rset.mapped(\u0026ldquo;name\u0026rdquo;) 返回带有name值的列表。\n对于设计为仅操作单例的方法，可在开头处使用self.ensure_one() 。如果 self 不是单例时将抛出错误。\n小贴士：在记录为空时ensure_one() 函数也会抛出错误。查看rset是否有零条或一条记录时，可以使用rset or rset.ensure_one() 。\n空记录也是单例。这会很方便，因为在访问字段值时返回的是None而不是抛出错误。对于关联字段也是如此，使用点号标记访问关联记录也不会抛出错误。\n因此在实际使用中，无需在访问字段值前检查是否为空记录集。例如，不需使用if record: print(record.name) ，我们可以无忧地写下更简单的 print(record.name) 。还可以使用or条件提供空值的默认值：print(record.name or \u0026ldquo;None\u0026rdquo; ) 。\n访问关联字段 前面学习到模型可包含关联字段：多对一、一对多和多对多。这些字段类型的值为记录集。\n对于多对一字段，其值可以是单例或空记录集。两种情况下都可以直接访问字段值。如下例中的命令是正确且安全的：\n\u0026gt;\u0026gt;\u0026gt; self.company_id res.company(1,) \u0026gt;\u0026gt;\u0026gt; self.company_id.name \u0026#39;YourCompany\u0026#39; \u0026gt;\u0026gt;\u0026gt; self.company_id.currency_id res.currency(1,) \u0026gt;\u0026gt;\u0026gt; self.company_id.currency_id.name \u0026#39;EUR\u0026#39; 为避免麻烦，空记录可像单例一样操作，访问其字段值不会返回错误而是返回 False。所以我们可以使用点号标记来遍历字段，而无需担心因其值为空而报错，如：\n\u0026gt;\u0026gt;\u0026gt; self.company_id.parent_id res.company() \u0026gt;\u0026gt;\u0026gt; self.company_id.parent_id.name False 访问时间和日期值 在记录集中，日期和日期时间值以原生 Python 对象展示，例如，在查询上次 admin 用户的登录日期时：\n\u0026gt;\u0026gt;\u0026gt; self.browse(2).login_date datetime.datetime(2022, 5, 6, 3, 26, 21, 714562) 因为日期和日期时间是 Python 对象，它们可使用这些对象的所有功能。\nOdoo 12中的变化 date和datetime字段值以 Python 对象表示，而此前 Odoo 版本中它们以文本字符串表示。这些字段类型值仍可像此前 Odoo 版本中那样使用文本表示。\n日期和时间在数据库中以原生的世界标准时间(UTC) 格式存储，不受时区影响。 在记录集中看到的datetime值也是 UTC格式，在客户端中向用户展示时，datetime值会根据当前会话的时区设置来转换成用户的时区，这一设置存储在上下文的tz键中，如 {\u0026rsquo;tz\u0026rsquo;: \u0026lsquo;Europe/Brussels\u0026rsquo;} 。这一转换由客户端负责，而不是由服务端完成。\n例如在布鲁塞尔(UTC+1)的用户输入11:00 AM数据库中会存储为10:00 AM UTC，而在纽约(UTC-4) 的用户查看时则为06:00 AM。Odoo服务端日志消息时间戳使用提UTC时间，而非本地服务器时间。\n相反的转换，由会话时区转换为UTC，也需由客户端在将用户输入的datetime传回服务器时完成。\n小贴士：记住数据库中存储的日期和时间数据，以及在服务端代码中处理时均使用UTC表示。即便是服务端日志消息的时间戳也使用UTC表示。\n现在我们学习了访问记录数据的详细知识。然而我们应用会为业务处理提供一些自动化，免不了要向记录集中写入数据。在下一小节中进行学习。\n在记录中写入 有两种写入记录的方式：使用对象形式的直接赋值或使用write() 方法。write() 方法是底层负责执行写操作的方法，在使用外部API或加载XML记录时还会直接使用。对象形式的赋值稍后会加入到ORM模型中。它实现活跃记录模式且可以在Python代码逻辑中使用。\nODOO 13中的变化\n在Odoo 13中，ORM模型引入了一个新的数据库写入方式，称为内存内ORM。此前的Odoo版本中，每次写入会直接生成相应的数据库SQL命令，这是有性能代价的，尤其复杂的相互依赖所导致的同一记录重复更新。自Odoo 13开始，这些操作会存储在内存缓存中，在事务结束时，自动调用新的flush() 方法一次性执行相应的数据库操作。\n接下来我们学习这两种方法及其区别。\n使用对象形式的赋值 记录集实现了活跃记录模式。意思是我们可对其赋值，然后这些值会在数据库中持久化存储。这是一种符合直接的操作数据的便利方式。\nODOO 13中的变化\nOdoo 13中支持对一条以上记录的记录集赋值。截至Odoo 12，仅支持对单条记录写入值，写入多条记录时需要使用write() 方法。\n示例如下：\n\u0026gt;\u0026gt;\u0026gt; root = self.env[\u0026#34;res.users\u0026#34;].browse(1) \u0026gt;\u0026gt;\u0026gt; print(root.name) OdooBot \u0026gt;\u0026gt;\u0026gt; root.name = \u0026#34;Superuser\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(root.name) Superuser 在使用活跃记录模式时，可通过记录集赋值设置关联字段的值。\n日期和时间字段可以通过Python原生对象或Odoo默认格式的字符串表示进行赋值：\n\u0026gt;\u0026gt;\u0026gt; from datetime import date \u0026gt;\u0026gt;\u0026gt; self.date = date(2020, 12, 1) \u0026gt;\u0026gt;\u0026gt; self.date datetime.date(2020, 12, 1) \u0026gt;\u0026gt;\u0026gt; self.date = \u0026#34;2020-12-02\u0026#34; \u0026gt;\u0026gt;\u0026gt; self.date datetime.date(2020, 12, 2) 二进制字段应使用base64编码的值进行赋值。例如，在从文件读取原始二进制数据时，在赋值给字段前必须使用base64.b64encode() 进行转换：\n\u0026gt;\u0026gt;\u0026gt; import base64 \u0026gt;\u0026gt;\u0026gt; blackdot_binary = b\u0026#34;\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x08\\x04\\x00\\x00\\x00\\xb5\\x1c\\x0c\\x02\\x00\\x00\\x00\\x0bIDATx\\xdacd\\xf8\\x0f\\x00\\x01\\x05\\x01\\x01\u0026#39;\\x18\\xe3f\\x00\\x00\\x00\\x00IEND\\xaeB\u0026#39;\\x82\u0026#34; \u0026gt;\u0026gt;\u0026gt; self.image_1920 = base64.b64encode(blackdot_binary).decode(\u0026#34;utf-8\u0026#34;) 在对多对一字段赋值时，所赋的值必须为单条记录（即单例记录集）。\n对多字段也可使用记录集赋值，将关联记录列表替换为新的记录集。此处允许任意大小的记录集。\n对关联字段设置空值时，可设置为None或False。\n\u0026gt;\u0026gt;\u0026gt; self.child_ids = None \u0026gt;\u0026gt;\u0026gt; self.child_ids res.partner() 在赋值列表中追加或删除记录使用记录操作运行。\n例如，想旬公司记录还有一条用于存储地址详情的关联partner记录。假定我们想要添加当前用户为公司的子联系人。可通过如下命令实现：\n\u0026gt;\u0026gt;\u0026gt; mycompany_partner = self.company_id.partner_id \u0026gt;\u0026gt;\u0026gt; myaddress = self.partner_id \u0026gt;\u0026gt;\u0026gt; mycompany_partner.child_ids = mycompany_partner.child_ids | myaddress 此处使用了管道运算符( | )来拼接记录获取更大的记录集。\n使用更简洁的追加赋值运算符( |=)也可以达到同样效果：\n\u0026gt;\u0026gt;\u0026gt; mycompany_partner.child_ids |= myaddress 更多有关记录操作运算符的知识请参见本章的构造记录集一节。\n通过 write()方法写入 我们还可以使用write() 方法来同时更新记录中的数据。它接收一个带有字段名和所赋值的字典。在很多场景中可以方便的使用，例如，在先准备好字典、稍后进行赋值时。对于老版本的Odoo（截至Odoo 12）无法直接赋值的场景也很有用。\nwrite() 方法接收字段及所赋值的字典，然后使用它们更新记录集：\n\u0026gt;\u0026gt;\u0026gt; Partner = self.env[\u0026#39;res.partner\u0026#39;] \u0026gt;\u0026gt;\u0026gt; recs = Partner.search( [(\u0026#39;name\u0026#39;, \u0026#39;ilike\u0026#39;, \u0026#39;Azure\u0026#39;)] ) \u0026gt;\u0026gt;\u0026gt; recs.write({\u0026#39;comment\u0026#39;: \u0026#39;Hello!\u0026#39;}) True 日期和时间字段可以使用相应的Python对象或字符串文本形式进行赋值，和对象形式的赋值一样。\n从Odoo 13开始，write() 可以使用记录集来为对一和对多关联字段设置值，和对象形式的赋值一样。\nODOO 13中的变化\nwrite() 方法可使用记录集来对关联字段赋值。截至Odoo 12，多对一字段都使用ID值来进行设置，而对多字段通过特殊语法进行设置，如使用 (4, , _) 添加记录， (6, 0, []) 设置完整记录列表。这种语法在第五章 Odoo 15开发之导入、导出以及模块数据中进行过讨论。\n例如，假设有两条Partner记录：address1和address2，我们希望将它们设置到self.child_ids字段上。\n使用write() 方法，命令如下：\n\u0026gt;\u0026gt;\u0026gt; self.write({ \u0026#39;child_ids\u0026#39;: address1 | address2}) 另一种（Odoo 13之前版本需要使用的）方式如下：\nself.write({ \u0026#39;child_ids\u0026#39;: [(6, 0, [address1.id, address2.id])]}) write() 方法用于对已有记录写入数据。但我们还需要创建和删除记录，在下一节中进行讨论。\n创建和删除记录 模型方法create() 和 unlink() 可分别用于创建记录和删除已有记录。\ncreate() 方法接收所需创建记录字段和值组成的字典，语法与 write() 一致。没错，默认值会被自动应用，如下例所示：\n\u0026gt;\u0026gt;\u0026gt; Partner = self.env[\u0026#39;res.partner\u0026#39;] \u0026gt;\u0026gt;\u0026gt; new = Partner.create({\u0026#39;name\u0026#39;: \u0026#39;ACME\u0026#39;, \u0026#39;is_company\u0026#39;: True}) \u0026gt;\u0026gt;\u0026gt; print(new) res.partner(56,) unlink() 方法会删除记录集中的记录，如下例所示：\n\u0026gt;\u0026gt;\u0026gt; rec = Partner.search([(\u0026#39;name\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;ACME\u0026#39;)]) \u0026gt;\u0026gt;\u0026gt; rec.unlink() 2022-06-05 01:53:09,906 43 INFO odoo-dev odoo.models.unlink: User #1 deleted mail.message records with IDs: [22] 2022-06-05 01:53:09,952 43 INFO odoo-dev odoo.models.unlink: User #1 deleted res.partner records with IDs: [56] 2022-06-05 01:53:09,961 43 INFO odoo-dev odoo.models.unlink: User #1 deleted mail.followers records with IDs: [6] True unlink() 方法返回了True。同时在进行删除时，触发日志消息告知我们关联记录的级联删除，如Chatter消息和关注者。\n另一种创建记录的方法是复制已有记录。模型方法copy() 可用于此。它接收一个可选字典参数，其中包含新建记录时要重写的值。\n例如，通过demo用户新建用户的示例如下：\n\u0026gt;\u0026gt;\u0026gt; demo = self.env.ref(\u0026#34;base.user_demo\u0026#34;) \u0026gt;\u0026gt;\u0026gt; new = demo.copy({\u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;login\u0026#34;: \u0026#34;john@example.com\u0026#34;}) 带有copy=False属性的字段不会被自动拷贝。对多关联字段带有该标记时默认被禁用，因此也不可拷贝。\n在前面的小节中，我们学习了如何访问记录集中的数据以及写入记录集。但我们需要关注某些字段类型。在下一节中我们讨论操作日期和时间的具体技巧。\n处理日期和时间 在在记录集中访问数据一节中，我们学习了如何从记录中读取日期和时间值。执行日期计算及在原生格式和字符串表示之间进行转换都很常见。以及这们就来学习这类运算。\nOdoo为新建日期和时间对象提供了一些有用的函数。\nodoo.fields.Date对象提供了这些辅助函数：\nfields.Date.today()返回服务端所需格式的当前日期字符串，它使用UTC作为参照。这足以计算默认值。这种情况可通过default=fields.Date.today直接在日期字段定义中使用。 fields.Date.context_today(record, timestamp=None) 在会话上下文中返回带有当前日期的字符串。时区从记录上下文中获取。可选项timestamp参数是一个datetime对象，如果传入则不使用当前时间，使用传入的值。 odoo.fields.Datetime对象提供了如下日期时间创建函数：\nfields.Datetime.now() 函数返回服务端所需格式的当前日期时间，它使用UTC作为参照。这足以计算默认值。可通过default=fields.Datetime.now直接在日期时间字段定义中使用。 fields.Datetime.context_timestamp(record, timestamp) 函数将原生的日期时间值(无时区)转换为具体时区的日期时间。时区从记录上下文中提取，因此使用了前述函数名。 时间的加减 日期对象可进行比较和相减来获取两个日期的时间差，时间差是一个timedelta对象。timedelta可通过日期运算对date和datetime对象进行加减。\n这些对象由 Python 标准库datetime模块提供。以下是使用它进行的基本运算示例：\n\u0026gt;\u0026gt;\u0026gt; from datetime import date \u0026gt;\u0026gt;\u0026gt; date.today() datetime.date(2022, 6, 5) \u0026gt;\u0026gt;\u0026gt; from datetime import timedelta \u0026gt;\u0026gt;\u0026gt; date(2022, 6, 5) + timedelta(days=7) datetime.date(2022, 6, 12) 对于date, datetime和timedelta数据类型的完整参考请见Python 官方文档。\ntimedelta对象支持周、天、小时、秒等等。但不支持年或月。\n要对月或年进行日期运算，应当使用relativedelta对象。以下是加一年又一月的示例：\n\u0026gt;\u0026gt;\u0026gt; from dateutil.relativedelta import relativedelta \u0026gt;\u0026gt;\u0026gt; date(2022, 6, 5) + relativedelta(years=1, months=1) datetime.date(2023, 7, 5) relativedelta对象对质高级日期运算，包含闰年和复活节的计算。官方文档位于https://dateutil.readthedocs.io。\nOdoo 还在odoo.tools.date_utils模块中提供了一些额外的函数：\nstart_of(value, granularity) 是某个特定刻度时间区间的开始时间，这些刻度有year, quarter, month, week, day或hour。 end_of(value, granularity) 是某个特定刻度时间区间的结束时间。 add(value, kwargs) 为指定值加上一个时间间隔。 ****kwargs参数由一个relativedelta对象来定义时间间隔。这些参数可以是years, months, weeks, days, hours, minutes等等 **subtract(value, kwargs) 为指定值减去一个时间间隔 这些工具函数在odoo.fields.Date和odoo.fields.Datetime对象中也可使用。\n上述函数的使用示例如下：\n\u0026gt;\u0026gt;\u0026gt; from odoo.tools import date_utils \u0026gt;\u0026gt;\u0026gt; from datetime import datetime \u0026gt;\u0026gt;\u0026gt; now = datetime(2022, 6, 5, 0, 0, 0) \u0026gt;\u0026gt;\u0026gt; date_utils.start_of(now, \u0026#39;week\u0026#39;) datetime.datetime(2022, 5, 30, 0, 0) \u0026gt;\u0026gt;\u0026gt; date_utils.end_of(now, \u0026#39;week\u0026#39;) datetime.datetime(2022, 6, 5, 23, 59, 59, 999999) \u0026gt;\u0026gt;\u0026gt; today = date(2022, 6, 5) \u0026gt;\u0026gt;\u0026gt; date_utils.add(today, months=2) datetime.date(2022, 8, 5) \u0026gt;\u0026gt;\u0026gt; date_utils.subtract(today, months=2) datetime.date(2022, 4, 5) 日期和时间对象转换为文本形式 有时需要将Python的date对象转换为文本形式。你不能吃在准备用户消息或格式化数据发送到其它系统时可能会用到。\nOdoo字段对象提供了一些帮助函数用于将原生Python对象转化为字符串：\nfields.Date.to_string(value) 函数将date对象转化为Odoo服务端所需的字符串格式。 fields.Datetime.to_string(value) 函数将datetime对象转化为Odoo服务端所需的字符串格式。 它们使用了Odoo服务端的预定义默认值，即如下的常量定义：\nodoo.tools.DEFAULT_SERVER_DATE_FORMAT odoo.tools.DEFAULT_SERVER_DATETIME_FORMAT 它们分别映射为 %Y-%m-%d和 %Y-%m-%d %H:%M:%S。\ndate.strftime和datetime.strftime函数接收一个格式字符串参数，用于将其它的转化为文本。\n例如下面的示例：\n\u0026gt;\u0026gt;\u0026gt; date(2022, 6, 5).strftime(\u0026#34;%d/%m/%Y\u0026#34;) \u0026#39;05/06/2022\u0026#39; 有关格式化代码的详情请参见官方文档。\n转化文本表示的日期和时间 有时字符串格式的日期需要转化为Python的date或datetime对象。在Odoo 11及之前经常需要使用，其中的日期是以文本进行读取的。有一些工具可辅助文本和原生日期类型之间的相互转换。\n为有助于格式间的转换，fields.Date和fields.Datetime对象提供了这些方法：\nfields.Date.to_date方法将字符串转换为date对象。 fields.Datetime.to_datetime(value) 方法将字符串转换为datetime对象。 使用to_datetime的示例如下：\n\u0026gt;\u0026gt;\u0026gt; from odoo import fields \u0026gt;\u0026gt;\u0026gt; fields.Datetime.to_datetime(\u0026#34;2020-11-21 23:11:55\u0026#34;) datetime.datetime(2020, 11, 21, 23, 11, 55) 上例中使用了Odoo内置的日期格式解析字符串，然后转化为Python的datetime对象。\n对于其它的日期和时间格式，可使用date和datetime对象中的strptime方法：\n\u0026gt;\u0026gt;\u0026gt; from datetime import datetime \u0026gt;\u0026gt;\u0026gt; datetime.strptime(\u0026#34;03/11/2020\u0026#34;, \u0026#34;%d/%m/%Y\u0026#34;) datetime.datetime(2020, 11, 3, 0, 0) 大多数情况下，文本形式的时间不是Odoo服务端所需的UTC时间。需要在存储到Odoo数据库之前转换为UTC时间。\n例如，布鲁塞尔时区（UTC +1:00小时）的用户时间2020-12-01 00:30:00在数据库中应存储为UTC时间2020-11-30 23:30:00。代码如下：\n\u0026gt;\u0026gt;\u0026gt; from datetime import datetime \u0026gt;\u0026gt;\u0026gt; import pytz \u0026gt;\u0026gt;\u0026gt; naive_date = datetime(2020, 12, 1, 0, 30, 0) \u0026gt;\u0026gt;\u0026gt; client_tz = self.env.context[\u0026#34;tz\u0026#34;] \u0026gt;\u0026gt;\u0026gt; client_date = pytz.timezone(client_tz).localize(naive_date) \u0026gt;\u0026gt;\u0026gt; utc_date = client_date.astimezone(pytz.utc) \u0026gt;\u0026gt;\u0026gt; print(utc_date) 2020-11-30 23:30:00+00:00 这段代码通过上下文获取用户时间区，然后使用它将原生日期转化为时间相关的日期。最后一步是使用astimezone(pytz.utc) 将客户端时区的日期转换为UTC日期。\n至此我们学习了Odoo中处理日期和时间的技巧。还有一些处理记录集和关联字段中存储值的具体技巧，我们在下一节中讨论。\n使用记录集 记录集是一个记录集合，Python的业务逻辑中经常使用它。对记录集可执行一些运算，如映射和过滤。可以通过添加或删除记录来编写新的记录集。其它的运算有查看记录集的内容来是否包含具体的记录。\nODOO 10中的变化\n从Odoo 10开始，记录集运算保留了排序。此前的 Odoo 版本中，记录集运算不一定会保留排序，但加运算和切片是保留排序的。\n记录集运算 记录集包含一些函数，可以对其执行一些操作，如排序或过滤记录。\n所支持的函数和属性有：\nrecordset.ids 属性返回记录集元素的ID列表 recordset.ensure_one() 函数检查是否为单条记录（单例）；若不是，则抛出ValueError异常 The recordset.filtered() 函数返回一个过滤了的记录集，函数为过滤记录的测试函数。参数也可为包含所需运算的点号分隔字段序列字符串。会选取运算为真值的记录。 recordset.mapped() 函数返回一个值列表，函数为每条记录返回一个值。参数也可为包含所需运算给返回字段的点号分隔字段序列字符串。在字段序列中使用对多字段是安全的。 recordset.sorted() 返回一个排好序的记录集。函数为每条记录返回一个值。参数也可为待排序字段名称的字符串。注意不允许使用字段的点号标记序列。有一个可选参数reverse=True。 这些函数的使用示例如下：\n\u0026gt;\u0026gt;\u0026gt; rs0 = self.env[\u0026#34;res.partner\u0026#34;].search([(\u0026#34;display_name\u0026#34;, \u0026#34;like\u0026#34;, \u0026#34;Azure\u0026#34;)]) \u0026gt;\u0026gt;\u0026gt; len(rs0) # 几条记录 4 \u0026gt;\u0026gt;\u0026gt; rs0.filtered(lambda r: r.name.startswith(\u0026#34;Nicole\u0026#34;)) res.partner(27,) \u0026gt;\u0026gt;\u0026gt; rs0.filtered(\u0026#34;is_company\u0026#34;) res.partner(14,) \u0026gt;\u0026gt;\u0026gt; rs0.mapped(\u0026#34;name\u0026#34;) [\u0026#39;Azure Interior\u0026#39;, \u0026#39;Brandon Freeman\u0026#39;, \u0026#39;Colleen Diaz\u0026#39;, \u0026#39;Nicole Ford\u0026#39;] \u0026gt;\u0026gt;\u0026gt; rs0.sorted(\u0026#34;name\u0026#34;, reverse=True).mapped(\u0026#34;name\u0026#34;) [\u0026#39;Nicole Ford\u0026#39;, \u0026#39;Colleen Diaz\u0026#39;, \u0026#39;Brandon Freeman\u0026#39;, \u0026#39;Azure Interior\u0026#39;] \u0026gt;\u0026gt;\u0026gt; rs0.mapped(lambda r: (r.id, r.name)) [(14, \u0026#39;Azure Interior\u0026#39;), (26, \u0026#39;Brandon Freeman\u0026#39;), (33, \u0026#39;Colleen Diaz\u0026#39;), (27, \u0026#39;Nicole Ford\u0026#39;)] 构造记录集 记录集是不可变的，也就是说无法直接修改其值。但我们可以根据已有记录集构造一个新记录集。切片标记法常用于Python列表中，可用于记录集来提取记录的子集。举一些例子：\nrs[0] 和rs[-1] 分别返回第一个和最后一个元素 rs[1:] 返回除第一元素外的记录集拷贝 rs[:1] 返回记录集的第一个元素 小贴士：从记录集中提供取第一个元素的安全方式是rs[:1] 而非rs[0] 。后者在rs为空时结果出错，而前者则仅返回一个空记录集。另一个选择是odoo.fields模块中的first() 方法：fields.first(rs) 。\n记录集还支持如下的集合运算：\nrs1 | rs2是一个集合的并运算，会生成一个包含两个记录集所有元素的记录集。这是一个类似set的运算，不会产生重复元素。 例如self.env.user | self.env.user返回单条记录，比如res.users(1,) 。 rs1 \u0026amp; rs2是集合的交集运算，会生成一个仅在两个记录集中同时出现元素组成的数据集。 rs1 - rs2是集合的差集运算，会生成在rs1中有但rs2中没有的元素组成的数据集。 我们可以直接使用如下更简短标记的运算进行赋值：\nself.author_ids |= author1：如果记录集中不存在author1，会将author1加入记录集。 self.author_ids \u0026amp;= author1运算仅保留author1记录集中也存在的记录。 self.author_ids -= author1：如果author1存在于记录集中，进行删除 记录集追加 有时我们希望遍历一些逻辑，将每次循环的结果记录累加起来。ORM中追加的方式是先使用空记录集，然后不断添加记录。要获取空记录集，创建一个模型的指针。例如下面的命令：\n\u0026gt;\u0026gt;\u0026gt; Partner = self.env[\u0026#39;res.partner\u0026#39;] \u0026gt;\u0026gt;\u0026gt; recs = self.env[\u0026#39;res.partner\u0026#39;] \u0026gt;\u0026gt;\u0026gt; for i in range(3): ... rec = Partner.create({\u0026#34;name\u0026#34;: \u0026#34;Partner %s\u0026#34; % i}) ... recs |= rec ... \u0026gt;\u0026gt;\u0026gt; print(recs)res.partner(58, 59, 60) 以上的代码循环了3次，每次循环都新建了一条partner记录，然后追加至recs记录集中。因其是记录集，recs变量可用于记录集能使用的地方，如向对多字段赋值。\n但追加记录集时间效率不高，应避免在循环中进行。原因是Odoo的记录集是不可变对象，对记录集的任何运算都需要通过拷贝来获取变更后的版本。在向记录集追加记录时，原始记录集并未发生变化。而是拷贝了一份追加记录。拷贝运算是耗时的，记录集越大，耗时越久。\n因而，需要考虑替代方案。以前例来说，我们可以在Python列表中汇集记录数据字典，然后通过单条create() 调用创建所有这些记录。可以这么做是因为create() 方法可接收字典列表。\n所以可以把循环变成这样：\nvalues = [] for i in range(3): value = {\u0026#34;name\u0026#34;: \u0026#34;Partner %s\u0026#34; % i} values.append(value) recs = self.env[\u0026#34;res.partner\u0026#34;].create(values) 但这一方案并不适用所有场景。另一种选择是使用Python列表汇集记录。Python列表是可变对象，追加元素的运算是高效的。因Python列表并不是记录集，这种方案无法用在记录集的场景中，比如向对多字段赋值。\n以下是在Python列表中汇集记录的示例：\nPartner = self.env[\u0026#34;res.partner\u0026#34;] recs = [] for i in range(3): rec = Partner.create({\u0026#34;name\u0026#34;: \u0026#34;Partner %s\u0026#34; % i}) recs.append(new_rec) 以上这些例子描述了使用循环通过单独元素构建记录集的一些技巧。但有些场景并不一定要循环，像mapped() 和filtered() 这样的运算可提高效的实现方式。\n记录集比较 某些场景中我们需要比较记录集的内容，来决定是否做进一步操作。记录集支持常规的比较运算。\n查看 记录是否为 \u0026lt;my_recordset\u0026gt; 记录集中的元素，可使用如下代码：\nin \u0026lt;my_recordset\u0026gt; not in \u0026lt;my_recordset\u0026gt; 也可对记录做比较看一个记录集是否包含另一个记录集。比较两个记录集set1和set2：\n如果set1中的所有元素也位于set2中，set1 \u0026lt;= set2及set1 \u0026lt; set2返回True。在两个记录集元素相同时 \u0026lt; 运算符返回False。 如果set2中的所有元素也位于set1中，set1 \u0026gt;= set2及set1 \u0026gt; set2返回True。在两个记录集元素相同时 \u0026gt; 运算符返回False。 数据库事务和底层SQL 通过客户端调用的ORM方法在事务中运行。事务保障了并发写入或出错时数据的正确性。在事务中，数据记录会上锁，保护其不受其它并发事务的影响，并保障不会有计划外的修改。在出错时，所有事务所做的修改会回滚，回到初始状态。\nPostgreSQL提供了对事务的支持。在通过客户端调用ORM方法时，会初始化一个新的事务。如果在方法执行过程中发生错误，所有的修改都会撤销。如果方法执行完成且未报错，就会提交修改，让修改对其它事务有效、可见。\n这些会自动进行处理，我们一般不太需要有任何担心。但在一些高级用例中，对当前事务加以控制可能会比较好。\nODOO 13中的变化\n自Odoo 13起，数据库的写操作不是在方法运行时完成。而是汇聚在内存缓存中，实际的数据库写入会延迟至方法执行结束之时，由自动触发的flush() 调用执行。\n控制数据库事务 有些场景下控制事务会有利，可使用数据库游标self.env.cr加以实现。举个例子，遍历记录对每条记录执行运算，希望跳过运算错误的那些且不影响其它的记录。\n为此，对象提供了如下方法：\nself.env.cr.commit() 提交事务缓冲的写运算，使其在数据库中生效。 self.env.cr.rollback() 取消上次提交之后的写运算，如果尚未提交，则回滚所有操作。 小贴士： Odoo的shell会话模拟方法执行上下文。直到调用self.env.cr.commit() 时才会执行数据库写操作。\n执行原生SQL The values parameter can be a tuple or a dict. When using a tuple, the parameters are replaced with %s, and when using a dict, they are replaced with %()s. Here are examples of both approaches:\n通过游标的execute() 方法，我们可以直接在数据库中运行SQL语句。它接收一个要运行的SQL语句字符串，以及第二个可选参数：一个用作 SQL 参数值。\n这一参数值可以是元组或列表。在使用元组时，参数使用 %s替换，使用字典时，通过 %()s替换。这两种方法的示例如下：\n\u0026gt;\u0026gt;\u0026gt; self.env.cr.execute(\u0026#34;SELECT id, login FROM res_users WHERE login=%s OR id=%s\u0026#34;, (\u0026#34;demo\u0026#34;, 1)) \u0026gt;\u0026gt;\u0026gt; self.env.cr.execute(\u0026#34;SELECT id, login FROM res_users WHERE login=%(login)s OR id=%(id)s\u0026#34;, {\u0026#34;login\u0026#34;: \u0026#34;demo\u0026#34;, \u0026#34;id\u0026#34;: 1}) 以上运行SQL的指令，需要替换参数及准备待抓取的结果游标。更多详情可参见psycopg2的官方文档。\n注意： 在cr.execute() 中我们不应直接编写拼接参数的SQL查询。众所周知这样做会带来SQL注入攻击的安全风险。保持使用 %s占位符并通过第二个参数来传值。\n使用fetchall() 函数获取结果，返回数据行的元组：\n\u0026gt;\u0026gt;\u0026gt; self.env.cr.fetchall() [(1, \u0026#39;__system__\u0026#39;), (6, \u0026#39;demo\u0026#39;)] 也可使用dictfetchall() 函数来以字典获取记录：\n\u0026gt;\u0026gt;\u0026gt; self.env.cr.dictfetchall() [{\u0026#39;id\u0026#39;: 1, \u0026#39;login\u0026#39;: \u0026#39;__system__\u0026#39;}, {\u0026#39;id\u0026#39;: 6, \u0026#39;login\u0026#39;: \u0026#39;demo\u0026#39;}] 小贴士：self.env.cr数据库游标对象是Odoo对PostgreSQL库psycopg2的封装。也就是说psycopg2的官方文档对助于我们对使用该对象的全面理解。\n还可以使用数据操纵语言(DML) 来运行指令，如UPDATE和INSERT。Odoo环境依赖于数据缓存 ，这可能导致执行DML与数据库中的实际数据不一致。出于这个原因，在使用原生DML后，应使用self.env.cache.invalidate(fnames=None, ids=None) .清除缓存。\nfnames是清除和刷新的字段名列表。如未提供，则会清除所有字段。\nids是清除和刷新的记录ID列表。如未提供，则会清除所有字段。\n注意： 直接在数据库中执行SQL语句可能会跳过ORM验证和依赖进而导致数据不一致，请仅在确定时进行该操作。\n总结 在本章中，我们学习了如何操作模型数据执行 CRUD 运算：即创建、读取、更新和删除数据，还有处理和操作数据库所需的所有技巧。这是实现我们的业务逻辑和自动化代码的基石。\n对于ORM API的测试，我们使用了Odoo交互式 shell 命令行。我们通过self.env环境运行了命令，该环境类似于模型方法中的环境，因此对于探索Odoo API功能很有用。\n该环境让我们可以查看任意Odoo模型中的数据并生成记录集。我们学习了创建记录集的不同方式以及如何读取所提供的数据，包含一些特殊数据类型，如日期、二进制值和关联字段。\nOdoo的另一个基本能力是回写数据。本章中，我们学习了如何新建记录，对现有记录写入以及删除记录。\n我们还学习是日期和时间值的处理，使用了Python内置的工具以及Odoo框架所包含的一些帮助函数。\n可操作记录集来添加元素、过滤记录、重新排序或追加值，以及比较记录集或查看具体记录的包含关系。这实现业务逻辑时可能会需要这些运算，本意中讲解了它们的基本技巧。\n最后，我们可能需要跳过ORM模型的使用，使用底层SQL运算直接访问数据库或更精准地控制事务。这样可应对那些ORM模型对任务不理想的场景。\n学习了这么多工具，我们可以进入下一章了，其中会学习模型的业务逻辑层以及实现使用ORM API自动操作的模型方法。\n扩展知识 有关记录集的Odoo官方文档。\n"
},
{
	"uri": "/odoo/8/",
	"title": "第八章 Odoo 15开发之业务逻辑 - 业务流程的支持",
	"tags": [],
	"description": "",
	"content": "在前面的文章中，我们学习了如何使用模型层构建应用数据结构，然后使用ORM API 和记录集查看和操作这些数据。\n本章中，我们把前面所学串到一起实现一些应用中常见的逻辑模式。我们会学习一起触发业务逻辑的方式，以及支撑这些方式的一些常见模式。我们还将学习一些重要的开发技巧，如打日志、调试和测试。\n本章的主要内容有\n学习项目-图书借阅模块 触发业务逻辑的方式 理解记录集的ORM方法装饰器 探讨一些数据模型模式 使用ORM内置方法 添加onchange用户界面逻辑 消息和活动功能 创建向导 抛出异常 编写单元测试 使用日志消息 学习一些开发工具 学完本章后，读者可以自如地设计、实现业务逻辑自动化以及了解如何测试、调试代码。\n开发准备 本章中我们会创建一个library_checkout插件模块。它依赖于前面章节中所创建的library_app和library_member插件模块。\n这些插件模块的代码请参见GitHub 仓库的ch08目录。\n这些插件模块要放到Odoo的插件路径中，这样才能安装使用。\n学习项目–图书借阅模块 图书应用的主数据结构已就绪。现在需要对系统添加交易了。让图书会员可借阅书籍。也即我们要跟踪图书是否可借阅以及是否归还。\n每本书的借阅都有一个生命周期，从图书登记到图书被归还。这可通过看板视图表示为简单工作流，看板视图中每个阶段(stage)可展现为一列，工作项和借阅请求流从左侧列到右侧列，直至完成为止。\n在本章中，我们集中学习实现这一功能的数据模型和业务逻辑。\n用户界面部分的详情将在第十章 Odoo 15开发之后台视图 - 设计用户界面中讨论，看板视图在第十一章 Odoo 15开发之看板视图和用户端 QWeb中讨论。我们来快速过一遍数据模型吧。\n准备数据模型 首先我们就规则图书借阅功能所需的数据模型。\n图书借阅模型应包含如下字段：\n借阅图书的会员（必填） 借阅请求日期（默认为当天） 负责借阅的用户（默认为当前用户） 借阅路线，包含请求借阅的一本或多本图书 要支撑借阅生命周期，需要添加如下内容：\n请求的阶段：已选中、可借阅、已借出、已归还或已取消 待归还日期，图书应当归还的日期 归还，图书归还的日期 我们先新建library_checkout模块并实现图书借阅模型的初始版本。与此前章节相比此处并没有引入新的知识，用于提供一个基础供本章后续构建新功能。\n创建模块 和前面章节一样，需要创建library_checkout模块。按照如下的步骤：\n在其它图书插件模块的同级路径下创建一个library_checkout目录。后续的文件都在这个目录中添加。\n在__manifest__.py文件中加入如下内容：\n{ \u0026#39;name\u0026#39;: \u0026#39;Library Book Borrowing\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Members can borrow books from the library.\u0026#39;, \u0026#39;author\u0026#39;: \u0026#39;Alan Hou\u0026#39;, \u0026#39;depends\u0026#39;: [\u0026#39;library_member\u0026#39;], \u0026#39;data\u0026#39;:[ \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#39;views/library_menu.xml\u0026#39;, \u0026#39;views/checkout_view.xml\u0026#39;, ], } 在模块目录下创建__init__.py文件，并添加如下代码：\nfrom . import models 创建models/__init__.py文件并添加：\nfrom . import library_checkout 添加模型定义文件models/library_checkout.py并加入如下代码：\nfrom odoo import fields, models class Checkout(models.Model): _name = \u0026#34;library.checkout\u0026#34; _description = \u0026#34;Checkout Request\u0026#34; member_id = fields.Many2one( \u0026#34;library.member\u0026#34;, required=True, ) user_id = fields.Many2one( \u0026#34;res.users\u0026#34;, \u0026#34;Librarian\u0026#34;, default=lambda s: s.env.user, ) request_date = fields.Date( default=lambda s: fields.Date.today(), ) 下面就要添加数据文件了，添加访问规则、菜单项和一些基础视图，这样模块就可以使用了。\n在security/ir.model.access. csv文件中添加访问权限配置：\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1 接下来添加views/library_menu.xml实现菜单项：\n\u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;action_library_checkout\u0026#34; model=\u0026#34;ir.actions.act_window\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Checkouts\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;res_model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;view_mode\u0026#34;\u0026gt;tree,form\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;menuitem id=\u0026#34;menu_library_checkout\u0026#34; name=\u0026#34;Checkout\u0026#34; action=\u0026#34;action_library_checkout\u0026#34; parent=\u0026#34;library_app.menu_library\u0026#34; /\u0026gt; \u0026lt;/odoo\u0026gt; 在views/checkout_view.xml文件中实现的视图：\n\u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;view_tree_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Checkout Tree\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;tree\u0026gt; \u0026lt;field name=\u0026#34;request_date\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id=\u0026#34;view_form_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Checkout Form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;request_date\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 既然模块已经包含以上这些文件了，就可以在开发数据库中进行安装了：\n图8.1：初始图书借阅功能\n下面我们可以开始添加更多有意思的功能了。\n在整个项目的开发中，我们会不停地在不同处添加业务逻辑来展示Odoo所提供的那些功能。下一小节就会进行一部分讨论。\n触发业务逻辑的方式 准备好数据模型后，就需要业务逻辑来执行一些自动化操作。业务逻辑可直接由用户发起，比如点击按钮，或根据事件自动触发，如在记录中写入。\n这类业务逻辑大多涉及读取和写入记录节。详细的技巧在第七章 Odoo 15开发之记录集 - 使用模型数据中进行了讨论，在其中我们提供了实现实际业务逻辑的工具。\n下一个问题是业务逻辑应怎样触发。这取决于何时以及为什么触发业务逻辑。下面进行了一部分总结。\n部分业务逻辑与模型字段定义紧密关联。一些模型定义相关的业务逻辑实例如下：\n数据验证规则：强制数据满足某些条件。这类方法使用 @api.constrains装饰。 自动计算：以字段（虚拟或存储字段）进行实现，其值由方法计算。这类方法使用 @api.depends装饰再赋值给compute字段属性。 默认值：可动态计算，这类方法使用 @api.model装饰再赋值给default字段属性。 模型定义逻辑在第六章 Odoo 15开发之模型 - 结构化应用数据中进行了讨论。相关的例子可见数据模型模式一节。记录集的ORM方法装饰器一节提供对一些这里所说的ORM装饰器的回顾。\n还有模型事件相关业务逻辑，与业务工作流相关。可与以下记录相关事件进行关联：\n可对这些事件添加创建、写入、删除业务逻辑，而其它更优雅的方法则无法使用。 对用户界面视图可应用Onchange逻辑，这样一些字段的值可以在其它字段发生变化时做出改变。 对于直接由用户发起的动作，有以下选项：\nbutton视图元素用于调取对象方法。按钮可位于表单或列表的看板视图中。 server动作可在菜单项或Action上下文菜单中使用。 用于打开向导表单的window动作，可由用户输入，按钮会调用业务逻辑。这使得用户交互更丰富。 这些技巧在本章都会用到。支持的方法通常使用API装饰器，因此理解它们的不同很重要。为了能拨云见雾，下一节中进行综述。\n理解记录集的ORM方法装饰器 方法定义前可添加 @ ，对方法进行装饰。这些装饰器对方法添加特定的行为，根据方法的作用不同，可使用不同的装饰器。\n计算字段和验证方法装饰器 @api.depends(fld1,\u0026hellip;) 用于计算字段函数，标记(重新)计算应触发什么样的修改。必须设置在计算字段值上，否则会报错。 @api.constrains(fld1,\u0026hellip;) 用于模型验证函数并在任意参数中包含的字段修改时执行检查。不应在数据中写入修改，如检查失败，则抛出异常。 在第六章 Odoo 15开发之模型 - 结构化应用数据中进行过详细的讨论。\n另一组装饰器影响self记录集的行为，与实现的业务逻辑相关。\n影响self记录集的装饰器 默认方法应作为于由第一个参数self所提供的记录集。方法代码中通常包含for语句循环self记录集中的每条记录。\nODOO 14中的变化\nOdoo 14中删除了 @api.multi装饰器。此前的版本中，使用它来显示标记所装饰的方法在self参数中应传记录集。它早已是方法的默认行为，因此添加上仅为清晰起见。在Odoo 9中已经废弃了 @api.one装饰器， 因而在Odoo 14中也删去了它。它为理处理记录遍历，这样会对每条记录调用该方法，self参数总是个单体。从Odoo 14起，这两个装饰器都从代码中删除了，不再进行支持。\n某些情况下，方法需要对类进行操作，而不是某个具体的记录，像静态方法那样。这些方法使用 @api.model装饰，这时self方法参数应为模型的指针，不包含记录。\n例如，create() 方法使用 @api.model装饰器，它并不需要输入记录，仅要一个值字典，用于创建并返回记录。用于计算默认值的方法也要使用 @api.model装饰器。\n在进一步研究业务逻辑实现之前，我们必须更深入了解数据模型，在此过程中，提供一些通用数据模型模式的示例。\n探讨一些数据模型模式 模型用于表示业务文档有一些所需的数据结构。在一些Odoo应用可以看到，如销售订单或发票。\n常见的模式是头部/分行数据结构。在借阅请求是会使用到，这样可以借多本书。另一种模式是使用状态或者阶段。这两者存在不同，我们会稍后会讨论并提供参考实现。\n最后，ORM API提供一些与用户界面相关的方法。本节中会进行讨论。\n使用头部和分行模型 表单视图常见的需求是头部-分行数据结构。例如，销售订单包含多行订单项。对于借阅功能，借阅请求可以有多个请求行，每行为一个借阅项。\n在Odoo中实现很简单。需要两个模型来实现头部分行表单视图，一个用于文档头部，另一个用于文档分行。分行模型是一个多对一字段，用于标识所属的头部，而头部模型有一个一对多字段，列举文档中的分行。\n在借阅模型中已添加了library_checkout模块，现在需要添加分行。操作步骤如下：\n编辑models/library_checkout.py文件，为借阅分行添加一对多字段：\nline_ids = fields.One2many( \u0026#39;library.checkout.line\u0026#39;, \u0026#39;checkout_id\u0026#39;, string=\u0026#34;Borrowed Books\u0026#34;, ) 在**models/__init__.py**中添加新模型的文件，如下：\nfrom . import library_checkout from . import library_checkout_line 然后，添加声明借阅分行模型的Python文件models/library_checkout_line.py，内容如下：\nfrom odoo import api, exceptions, fields, models class CheckoutLine(models.Model): _name = \u0026#34;library.checkout.line\u0026#34; _description = \u0026#34;Checkout Request Line\u0026#34; checkout_id = fields.Many2one( \u0026#34;library.checkout\u0026#34;, required=True, ) book_id = fields.Many2one(\u0026#34;library.book\u0026#34;, required=True) note = fields.Char(\u0026#34;Notes\u0026#34;) 我们必须添加访问权限配置。编辑security/ir.model.access.csv文件，添加如下高亮部分内容：\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1 checkout_line_user,Checkout Line User,model_library_checkout_line,library_app.library_group_user,1,1,1,1 然后，我们要对表单添加借阅行。将其添加为notebook微件的第一页。编辑views/checkout_view.xml 文件，在 \u0026lt;/sheet\u0026gt; 元素前添加如下代码：\n\u0026lt;notebook\u0026gt; \u0026lt;page name=\u0026#34;lines\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;line_ids\u0026#34; \u0026gt; \u0026lt;tree editable=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;book_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;note\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;/notebook\u0026gt; 借阅表单更新如下：\n图8.2：带notebook微件的借阅表单\n分行一对多字段显示为父表单视图中的一个列表视图。默认，Odoo会查找用于渲染的列表视图定义，这是任意列表视图的典型定义。如未发现定义，会自动生成一个默认定义。\n可以在 \u0026lt;field\u0026gt; 内声明具体的视图。在以上代码就这么做的。在line_ids字段元素内，有一个内嵌的 \u0026lt;tree\u0026gt; 视图定义在该表单中使用。\n使用以文档为中心工作流的阶段和状态 在 Odoo 中，我们可以实现以文档(document)为中心的工作流。我们这里说的文档包括销售订单、项目任务或人事申请。所有这些都遵循一个特定的生命周期，它们都在完成时才被创建。每个工作项在文档中记录，按照一系列阶段推进，直至完成。\n如果把各阶段以列展示在面板中，把文档作为这些列中的工作项，就可以得到一个看板(Kanban)，一个快速查看工作进度的视图。\n实现这些进度步骤有两种方法-状态和阶段：\n状态为预定义的闭合选项列表。它便于实现业务规则，因其可事先固化。模型和视图对 state 字段有特别的支持，让其易于使用。封闭状态列表有一个劣势，它无法适配自定义流程需求步骤。 阶段通过关联模型实现，是一个灵活的步骤列表，可进行配置来满足流程需求。通常使用stage_id字段名实现。阶段列表可以轻易修改，因为我们可以对其删除、添加或重排序。它的劣势是对流程自动化不可靠。因为阶段列表可被修改，自动化规则就无法依赖于具体的阶段 ID 或描述。 在设计数据模型时，我们需要决定是否应使用阶段或状态。如果触发业务逻辑比配置流程更为重要，应优先使用状态，否则应优先选择阶段。\n如果无法抉择，有一个两全其美的方法：我们可以使用阶段，并将阶段映射到相应的状态。流程步骤列表可由用户轻松配置，因每个阶段会与一些可靠的状态码相关联，可自如地用于自动化业务逻辑。\n图书借阅功能会使用这种方法。为实现借阅阶段，我们要添加library.checkout.stage模型。描述阶段所需的字段如下：\nName或标题 Sequence, 用于对阶段列排序 Fold, 用于看板视图，决定默认是否折叠该列。这通常用于非活跃项目列，如已完成或已取消。 Active, 允许存档或不再使用的阶段，以妨流程变更 。 State, 封闭选择列表，用于将每个阶段映射到固定的状态。 实现以上字段我们应添加一个Stages模型，包含模型定义、视图、菜单和访问权限：\n添加models/library_checkout_stage.py文件并包含如下模型定义代码：\nfrom odoo import fields, models class CheckoutStage(models.Model): _name = \u0026#34;library.checkout.stage\u0026#34; _description = \u0026#34;Checkout Stage\u0026#34; _order = \u0026#34;sequence\u0026#34; name = fields.Char() sequence = fields.Integer(default=10) fold = fields.Boolean() active = fields.Boolean(default=True) state = fields.Selection( [(\u0026#34;new\u0026#34;, \u0026#34;Requested\u0026#34;), (\u0026#34;open\u0026#34;, \u0026#34;Borrowed\u0026#34;), (\u0026#34;done\u0026#34;, \u0026#34;Returned\u0026#34;), (\u0026#34;cancel\u0026#34;, \u0026#34;Canceled\u0026#34;)], default=\u0026#34;new\u0026#34;, ) 以上代码读者应该习以为常了。阶段有一个逻辑排序，所以呈现的顺序很生育。这借由 _order=\u0026ldquo;sequence\u0026rdquo; 来实现。我们还看到state字段将每个阶段与一个基本状态相映射，打王者在业务逻辑中可安全使用。\n老规矩，在models/init.py文件中添加新的代码文件，如下：\nfrom . import library_checkout_stage from . import library_checkout from . import library_checkout_line 同样需要访问权限规则。阶段包含设置数据，应仅由管理员用户组编辑。普通用户有只读权限。因此，在security/ir.model.access.csv文件中添加如下高亮代码：\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1 checkout_line_user,Checkout Line User,model_library_checkout_line,library_app.library_group_user,1,1,1,1 checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0 checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1 接下来需要一个菜单项来浏览阶段的设置。它应当位于应用的配置菜单下。library_app模块暂无此菜单，所以需要对其编辑添加。编辑library_app/views/library_menu.xml文件并新增如下XML：\n\u0026lt;menuitem id=\u0026#34;menu_library_configuration\u0026#34; name=\u0026#34;Configuration\u0026#34; parent=\u0026#34;menu_library\u0026#34; /\u0026gt; 现在将Stages菜单项加到配置菜单下。编辑library_checkout/views/library_menu.xml文件添加如下XML：\n\u0026lt;record id=\u0026#34;action_library_stage\u0026#34; model=\u0026#34;ir.actions.act_window\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Stages\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;res_model\u0026#34;\u0026gt;library.checkout.stage\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;view_mode\u0026#34;\u0026gt;tree,form\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;menuitem id=\u0026#34;menu_library_stage\u0026#34; name=\u0026#34;Stages\u0026#34; action=\u0026#34;action_library_stage\u0026#34; parent=\u0026#34;library_app.menu_library_configuration\u0026#34; /\u0026gt; 我们需要一些操作的阶段，因此在模块中添加一些默认数据。创建data/library_checkout_stage.xml文件加入如下代码：\n\u0026lt;odoo noupdate=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;record id=\u0026#34;stage_new\u0026#34; model=\u0026#34;library.checkout.stage\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Draft\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;sequence\u0026#34;\u0026gt;10\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34;\u0026gt;new\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id=\u0026#34;stage_open\u0026#34; model=\u0026#34;library.checkout.stage\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Borrowed\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;sequence\u0026#34;\u0026gt;20\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34;\u0026gt;open\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id=\u0026#34;stage_done\u0026#34; model=\u0026#34;library.checkout.stage\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Completed\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;sequence\u0026#34;\u0026gt;90\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34;\u0026gt;done\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id=\u0026#34;stage_cancel\u0026#34; model=\u0026#34;library.checkout.stage\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Canceled\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;sequence\u0026#34;\u0026gt;95\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34;\u0026gt;cancel\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 需要在library_checkout/__manifest__.py文件中进行添加才会生效，如下：\n\u0026#39;data\u0026#39;:[ \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#39;views/library_menu.xml\u0026#39;, \u0026#39;views/checkout_view.xml\u0026#39;, \u0026#39;data/library_checkout_stage.xml\u0026#39;, ], 成功更新后阶段列表应当如下图所示：\n图8.3：阶段列表视图\n这就是library_checkout中所需添加的阶段模型，用户也可进行配置。\n添加阶段工作流支持模型 下面应在图书借阅模型中添加阶段字段。为保障用户体验，还要再处理两个问题：\n默认阶段应赋值为new状态。 在对阶段分组时，所有可用的阶段都应在场，即使是那些没有借阅的阶段也如此。 这些应该在library_checkout/models/library_checkout.py文件的Checkout类中添加。\n查找默认阶段的函数应返回用于默认值的记录：\n@api.model def _default_stage_id(self): Stage = self.env[\u0026#34;library.checkout.stage\u0026#34;] return Stage.search([(\u0026#34;state\u0026#34;, \u0026#34;=\u0026#34;, \u0026#34;new\u0026#34;)], limit=1) 这会返回阶段模型中的第一条记录。因阶段模型按序号排序，它会返回序号最低的那条记录。\n在按阶段分组时，会会看到所有的阶段，而不仅仅是那些有借阅记录的。使用的方法返回分组使用的记录集。本例中，返回所有活跃阶段是恰当的：\n@api.model def _group_expand_stage_id(self, stages, domain, order): return stages.search([], order=order) 最后，我们希望添加到借阅模型的stage_id字段，可对default和group_expand属性使用以上的方法：\nstage_id = fields.Many2one( \u0026#34;library.checkout.stage\u0026#34;, default=_default_stage_id, group_expand=\u0026#34;_group_expand_stage_id\u0026#34;) state = fields.Selection(related=\u0026#34;stage_id.state\u0026#34;) stage_id与阶段模型存在多对一关联。默认值由 _default_stage_id方法计算，按stage_id的分组使用 _group_expand_stage_id方法的结果。\nODOO 10中的变化\n在Odoo 10中引入了group_expand属性，在此前版本中没有该属性。\ngroup_expand参数重载了字段分组的方式。分组操作的默认行为是仅查看使用中的阶段，那些没有借阅文档的阶段不显示。但对于stage_id字段，我们希望可用阶段都显示，不管有没有内容。\n_group_expand_stage_id() 帮助方法返回分组操作使用的分组记录列表。本例中，它返回所有存在的阶段，不管是否包含图书记录。\n注：group_expand属性必须为方法名字符串。它不同于其它属性，比如default属性可直接引用方法名或使用字符串。\n还添加了state字段。它只是模型中存在阶段相关的state字段，以在视图中使用。这会使用视图中可用的state的特殊支持。\n用户界面的支持方法 以下方法最常用于网页客户端中渲染用户界面和执行基础交互：\nname_get() 计算显示名称，为在视图中显示关联记录使用的表示每条记录的文件。它返回ID和 (ID, name) 元组列表.它是display_name值的默认教育处，可扩展用于实现自定义显示，如显示记录名和标识码。 name_search(name=\u0026rsquo;\u0026rsquo;, args=None, operator=\u0026lsquo;ilike\u0026rsquo;, limit=100) 对显示名称执行搜索。用于用户在视图的关联字段中输入生成匹配所输文本推荐记录的列表。它返回一个元组 (ID, name) 列表。 name_create(name) 创建一条仅带有输入名称的新记录。它在看板视图中配合on_create=\u0026ldquo;quick_create\u0026rdquo; 使用，在其中通过提供名称可快速创建关联记录。可扩展来为通过此功能创建的新记录提供指定默认值。 default_get([fields]) 以字典返回待创建新记录的默认值。默认值依赖于变量，如当前用户或会话上下文。可对其扩展添加其它默认值。 fields_get() 用于描述模型字段的定义，在开发者菜单的View Fields选项中也可以看到。 fields_view_get() 在网页客户端中用于获取要渲染的 UI视图的结构。可传入视图的 ID或想要使用的视图类型(view_type=\u0026lsquo;form\u0026rsquo;)作为参数。例如self.fields_view_get(view_type=\u0026lsquo;tree\u0026rsquo;) 返回为self模型渲染的树状视图XML结构。。 这些内置的ORM方法可作为实现模型业务逻辑的扩展点。\n下一节中我们讨论记录操作（如创建或写入记录）如何触发业务逻辑。\n使用 ORM 内置方法 模型定义相关方法可以完成很多任务，但却无法实现有些业务逻辑，所以需要使用到ORM记录写入操作。\nORM 提供对模型数据执行增删改查(CRUD)操作的方法。下面我们来探讨这些写操作以及如何进行扩展支持自定义逻辑。\n读取数据的主要方法search() 和browse() 在第七章 Odoo 15开发之记录集 - 使用模型数据中已进行讨论。\n写入模型数据的方法 ORM 为三种基本写操作提供了三个方法，如下所示：\n.create(values) 在模型上创建新记录，values为字典或在批量创建记录时为字典列表。 .write(values) 使用values字典更新记录集，不返回值。 .unlink() 从数据库中删除记录，不返回值。 values参数是一个字典，映射要写入的字段名和值。这些方法由 @api.multi装饰，但create() 方法使用 @api.model装饰。\nOdoo 12中的变化\ncreate()可访问字典列表，而不只是单个字典对象，这在Odoo 12引入 。这样我们也可批量创建数据。这一功能同 @api.model_create_multi装饰器进行支持。\n有些情况下，我们需要扩展这些方法来在触发方法时运行一些特定的业务逻辑。这种业务逻辑可在主方法执行前或执行后霆。\n继承create()方法的示例 我们来学习一个实例。我们不允许新创建借阅记录直接变为已借出或已归还状态。通常应用使用 @api.constrains装饰的某个方法来实现验证。但本例只创建记录事件相绑定，很难由常规的验证实现。\n编辑library_checkout/models/library_checkout.py文件并添加create() 继承方法：\n@api.model def create(self, vals): # 创建前执行的代码，应使用vals字典 new_record = super().create(vals) # 创建后执行的代码，应使用new_record if new_record.stage_id.state in (\u0026#39;open\u0026#39;, \u0026#39;close\u0026#39;): raise exceptions.UserError(\u0026#34;State not allowed for new checkouts.\u0026#34;) return new_record 新记录由super().create() 调用创建。在此之前，业务逻辑中无法使用新记录，仅可使用values字典，也无法修改以在待创建记录中强制一些值。\nsuper().create() 之后的代码可访问新创建记录，且可使用记录功能，如使用点号标记链访问关联记录。上例使用new_record.stage_id.state访问新记录阶段对应的状态。状态是不可由用户配置的，为业务逻辑提供了稳定的值列表。因此，我们可以查找open或done状态并在找到时抛出错误。\n继承write()的示例 我们再看一个例子。Checkout模型应记录图书借出的日期，借阅日期，以及归还的日期，关闭日期。这无法使用计算字段实现。而是应继承write() 方法来监测借阅状态的变化，然后在相应时刻（变为open或done状态之时）更新日期。\n在实现这一逻辑之前，需要创建两个日期字段。编辑library_checkout/models/library_checkout.py文件、添加如下代码：\ncheckout_date = fields.Date(readonly=True) close_date = fields.Date(readonly=True) 在记录发生修改时，在借阅记录进入相应状态时应分别设置checkout_date和close_date字段。为此，我们需要自定义write() 方法如下：\ndef write(self, vals): # 写入之前的代码，self为老值 if \u0026#34;stage_id\u0026#34; in vals: Stage = self.env[\u0026#34;library.checkout.stage\u0026#34;] old_state = self.stage_id.state new_state = Stage.browse(vals[\u0026#34;stage_id\u0026#34;]).state if new_state != old_state and new_state == \u0026#34;open\u0026#34;: vals[\u0026#34;checkout_date\u0026#34;] = fields.Date.today() if new_state != old_state and new_state == \u0026#34;done\u0026#34;: vals[\u0026#34;close_date\u0026#34;] = fields.Date.today() super().write(vals) # 写入之后的代码，可使用更新后的self return True 上例中，扩展代码加在super() 调用之前，因而是在写入self记录之前。要知道对记录准备做的修改，可以查看vals参数。字典vals中的stage_id是一个ID号，不是记录，所以需要进行扫描获取相应记录，然后读取对应的状态。\n比较老状态和新状态来在相应的时刻触发日期值更新。如若可能，我们更希望在super().write() 之前修改修改写入的值、更新vals字典，而不是直接设置字段值。下一节中会讲解原因。\n继承write()设置字段值的示例 前面的代码仅修改用于写入的值，它不直接对模型字段赋值。这样做安全，但在某些情况下不够。\n在write() 方法内对某个模型字段赋值会导致无限循环：赋值会再次触发写方法，然后又重复赋值，周而复始。直至Python返回递归错误为止。\n有一种避免递归循环的技巧，让write() 方法可以对记录字段设置值。这种技巧是设置值前在环境上下文中设置唯一标识，仅在没有标记时才运行设置值的代码。\n看实例会更清楚。我们重写前面的示例，让更新在调用super() 之后进行：\ndef write(self, vals): # 写入之前的代码，self为老值 old_state = self.stage_id.state super().write(vals) # 写入之后的代码，可使用更新后的self new_state = self.stage_id.state if not self.env.context.get(\u0026#34;_checkout_write\u0026#34;): if new_state != old_state and new_state == \u0026#34;open\u0026#34;: self.with_context(_checkout_write=True).write( {\u0026#34;checkout_date\u0026#34;: fields.Date.today()}) if new_state != old_state and new_state == \u0026#34;done\u0026#34;: self.with_context(_checkout_write=True).write( {\u0026#34;close_date\u0026#34;: fields.Date.today()}) return True 通过这一技巧，扩展代码由一条if语句守护，仅在上下文不存在指定标记时执行。此外，使用了带with_context方法的self.write() 操作执行写入。这组合确保了if语句中代码仅运行一次，在未来的write() 调用中不会再次触发，避免了无限循环。\n何时(不)继承create()和write()方法 继承create() 和write() 方法时应认真考虑。\n大部分情况下，在保存记录时必须执行一些验证，或是自动计算某些值。对于这些常见情况，有一些更好的选择，列举如下：\n对根据其它字段自动计算的字段值，使用计算字段。例如在各行值发生变化时计算头部的总计。 对于非固定字段默认值，使用方法作为默认字段值。会在赋默认值时进行运算。 在一个字段值变化时修改其它字段值，如在用户界面完成，使用onchange方法，如在服务端完成，使用一个新的可写入计算字段。例如，在用户选择客户时，虽然价格列表可由用户稍后修改，我们可以自动设置为客户的价格列表。在使用onchange方法时，仅对表单视图交互有效，无法用于直接写入，但可写入计算字段适用这两种情况。在添加onchange用户界面逻辑一节中进行了更详细的讨论。 验证使用constraint方法。在字段值修改时会自动触发，不满足验证条件时会抛出错误。 还有一些情况这些选择都不适用，则需要继承create() 或write() ，比如所设置的默认值依赖所创建记录的其它字段时。这时，无法使用默认值方法，因为它无法访问新记录的其它字段。\n数据导入、导出方法 导入、导出操作在第五章 Odoo 15开发之导入、导出以及模块数据已做讨论，也可以通过 ORM API 中的如下方法操作：\nload([fields], [data]) 用于导入数据，由Odoo在导入CSV或数据表数据时使用。第一个参数是导入的字段列表，与 CSV 的第一行对应。第二个参数是记录列表，每条记录是一个待解析和导入的字符串列表。与 CSV 数据中的行和列直接对应，它实现了 CSV 数据导入的功能，比如对外部标识符的支持。 export_data([fields], raw_data=False) 用于网页客户端的导出函数。它返回一个字典，带有包含datas（一个行列表）的数据键。字段名可使用 CSV 文件使用的.id和/id后缀，数据格式与需导入的 CSV 文件兼容。可选raw_data参数让数据值与 Python 类型一同导出，而不是 CSV 文件中的字符串形式。 也可在用户编辑数据时实现对用户界面的自动化。我们在下一节中进行学习。\n添加onchange用户界面逻辑 可在用户编辑时网页客户端视图做出修改。这种机制是onchange。由带 @api.onchange装饰器的方法实现，在用户编辑某个具体字段时由用户界面视图触发。\n从Odoo 13开始，同样的效果使用计算字段的特定表单实现，称为可写计算字段。这种ORM改进旨在避免经典的onchange机制所带来的限制，从长期来看，会完全进行替换。\n经典onchange 方法 onchange方法可修改表单中其它值、执行验证、对用户显示消息或对关联字段设置域过滤器，限制可选项。\nonchange方法异步调用，返回由网页客户端使用的数据更新当前视图中的字段。\nonchange与所触发字段关联，字段以参数传递给 @api.onchange(\u0026ldquo;fld1\u0026rdquo;, \u0026ldquo;fld2\u0026rdquo;, \u0026hellip;) 装饰器。\n注：api.onchange参数不支持点号标记，例如 \u0026ldquo;partner_id.name\u0026rdquo; 。如若使用，会进行忽略。\n在该方法内，self 参数是包含当前表单数据的一条虚拟记录。其为虚拟的原因是它可以在编辑但未存入数据库之时为新记录或修改后的记录。如对self记录设置值，则会在用户界面表单中修改。注意它不写入到数据库记录中，而是提供信息在UI表单中修改数据。\n注：onchange方法还有一些其它限制，请参见官方文档。可写计算字段可用作对onchange方法的全功能替代。详细信息参见带可写计算字段的新onchange一节。\n不需要返回值，但可能会返回带警告消息的dict结构在用户界面中显示，或是对表单所设置的域过滤器。\n我们做个实例吧。在借阅表单中，选中了图书会员时，请求日期会修改为当天。如果日期发生变化时，会对用户显示一条警告消息，通知用户发生了改变。\n实现这一逻辑，编辑library_checkout/models/library_checkout.py文件并添加如下代码：\n@api.onchange(\u0026#34;member_id\u0026#34;) def onchange_member_id(self): today_date = fields.Date.today() if self.request_date != today_date: self.request_date = today_date return { \u0026#34;warning\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Changed Request Date\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Request date changed to today!\u0026#34;, } } 以上onchange方法在用户界面中设置了member_id字段时触发。实际的方法名无关紧要，但按惯例是在字段名前加onchange_ 前缀。\n在onchange方法内，self表示包含在编辑记录时当前设置的所有记录，我们可与其进行交互 。\n方法代码查看当前的request_date是否需要修改。如是，将request_date设置为当天，这样用户可在表单中看到修改。然后向用户返回非阻塞的警告消息。\nonchange无需返回任何内容，但可返回包含警告或作用域键的字段，如下：\n警告的键应描述显示在对话框中的消息，如 {\u0026rsquo;title\u0026rsquo;: \u0026lsquo;Message Title\u0026rsquo;, \u0026lsquo;message\u0026rsquo;: \u0026lsquo;Message Body\u0026rsquo;} 作用域键可设置或修改其它字段的域属性。通过让对多字段仅展示在当下有意义的字段，会使得用户界面更加友好。作用域键类似这样： {\u0026lsquo;user_id\u0026rsquo;: [(\u0026rsquo;email\u0026rsquo;, \u0026lsquo;!=\u0026rsquo;, False)]} 带可写计算字段的新onchange 经典onchange机制在由Odoo框架提供的用户体验中扮演着关键角色。但存在着一些重要的缺陷。\n其一是它与服务端事件无关联。onchange仅在表单视图请求时起作用，但在实际write() 值变更时不会调用。这要求服务端业务逻辑重关相关的onchange方法。\n另一不足是 onchange与触发字段相关，但受修改的字段无绑定。对一些小用例，很难扩展，追踪修改源也很困难。\n为解决这些问题，Odoo框架扩充了计算字段的功能，让它可以处理onchange用例。我们称这一技巧为可写计算字段。当前仍支持经典onchange，但在未来的版本中会由计算字段替换并进行废弃。\nODOO 13中的变化\n可写计算字段在Odoo 13中引入，可在该版本及之后的版本中使用\n可写计算字段拥有赋值给它们的计算方法，必须进行存储，必须有readonly=False属性。\n我们换由这种方法实现前面的onchange。request_date字段应这样修改：\nrequest_date = fields.Date( default=lambda s: fields.Date.today(), compute=\u0026#34;_compute_request_date_onchange\u0026#34;, store=True, readonly=False, ) 这是常规的可存储可写字段，但绑定了可由指定条件触发的计算方法。例如，计算方法应在member_id改变时触发。\n计算方法 _compute_request_date_onchange的代码如下：\n@api.depends(\u0026#34;member_id\u0026#34;) def _compute_request_date_onchange(self): today_date = fields.Date.today() if self.request_date != today_date: self.request_date = today_date return { \u0026#34;warning\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Changed Request Date\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Request date changed to today!\u0026#34;, } } @api.depends像对计算字段一样，声明要监测变化的字段。实际提供的字段列表与经典 @api.onchange所使用的一致。\n方法代码也与onchange方法很相近。在某些情况下完全一致。注意计算字段不保证在每次方法调用时设置。仅在满足某些条件时发生。本例中为原请求日期与当天日期不同。这不同于普通的计算字段规则 ，但可用于可写计算字段。\n业务流程强相关的功能有发送邮件或通知用户。下一节中讨论Odoo为此所提供的功能。\n消息和活动(activity)功能 Odoo 自带全局的消息和活动规划功能，由 Discuss 应用提供，技术名称为 mail。\nmail.thread模型提供消息功能，在表单视图中有一个消息微件，也称之为聊天器（Chatter）。该微件让我们可以记录笔记或向其它用户发送消息。还保存发出的历史消息，同时由自动流程用于记录过程追踪消息。\n同一应用还由mail.activity.mixin模型提供活动管理功能。可对表单视图添加活动我邮件，让用户可以计划、追踪活动历史。\n添加消息和活动功能 mail 模块提供包含mail.thread抽象类，用于对任意模型添加消息功能。还提供mail.activity.mixin用于添加规划活动功能。在第四章 Odoo 15开发之模块继承中已讲解了如何使用mixin 抽象类的继承来为模型添加这些继承功能。\n执行必要的步骤如下：\n编辑library_checkout/__manifest__.py文件中的depends键来对library_checkout插件模型添加mail模块依赖，如下：\n\u0026#39;depends\u0026#39;: [\u0026#39;library_member\u0026#39;, \u0026#39;mail\u0026#39;], 要令library.checkout模型继承消息和活动抽象类，编辑library_checkout/models/library_checkout.py文件如下：\nclass Checkout(models.Model): _name = \u0026#34;library.checkout\u0026#34; _description = \u0026#34;Checkout Request\u0026#34; _inherit = [\u0026#34;mail.thread\u0026#34;, \u0026#34;mail.activity.mixin\u0026#34;] 在借阅表单视图中添加消息和活动字段，编辑 library_checkout/ and views/checkout_view.xml文件：\n\u0026lt;record id=\u0026#34;view_form_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Checkout Form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;group\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;request_date\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;stage_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;checkout_date\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;close_date\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;notebook\u0026gt; \u0026lt;page name=\u0026#34;lines\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;line_ids\u0026#34; \u0026gt; \u0026lt;tree editable=\u0026#34;bottom\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;book_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;note\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;/notebook\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;div class=\u0026#34;oe_chatter\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;message_follower_ids\u0026#34; widget=\u0026#34;mail_followers\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;activity_ids\u0026#34; widget=\u0026#34;mail_activity\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;message_ids\u0026#34; widget=\u0026#34;mail_thread\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 完成这些之后，借阅模型就具有了消息和活动字段，并可以使用相应的功能了。\n消息和活动字段与模型 消息和活动功能对继承了mail.thread和mail.activity.mixin类的模型添加了新字段，以及所有支持这些功能的模型。以下是添加了的基本数据结构。\nmail.thread mixin类添加了两个新字段：\n关注者：message_follower_ids与mail.follower有着一对多关联，存储接收通知的消息关注者。关注者可以是用户或频道。partner表示某个人或组织。channel不是某个人，而是一个订阅列表。 消息：message_ids与mail.message记录存在一对多关联，列出记录历史消息。 mail.activity.mixin mixin类新增如下字段：\n活动：activity_ids与mail.activity存在一对多关联，存储已完成或已规划的活动。 消息子类型 消息可添加子类型。子类型用于标识指定活动，如所创建或关闭的任务，对于精准控制将什么消息发送给何人很有用。\n子类型存储在mail.message.subtype模型中，可通过Settings \u0026gt; Technical \u0026gt; Email \u0026gt; Subtypes菜单配置。\n基本的三种消息子类型如下：\n讨论：带有mail.mt_comment XML ID，用于由消息微件中Send message所发送的消息，默认会发送通知给关注者。 笔记：带有mail.mt_note XML ID，用于创建带有Log note XML ID的消息，默认不会发送通知。 活动：带有mail.mt_activities XML ID，用于创建带有Schedule activity链接的消息，不发送通知。 应可添加自己的子类型，通常与相关的活动关联。例如，Sales应用添加了两个子类型：报价已发送和销售订单已确认。在消息历史中记录这些事件时会由应用的业务逻辑所用。\n子类型允许我们决定何时发送通知以及发送给谁。消息微件右上角的关注者菜单允许我们新增或删除关注者，以及选择接收通知的子类型。下图展示了某一关注者Gemini Furniture的子类型选择表单：\n图8.4：选取活跃消息子类型的关注者微件\n子类型订阅标记可拖动编辑，其默认值在编辑子类型定义查看Default字段时配置。一经设置，新记录的关注者默认会收到通知。\n除内置子类型，插件模块可添加自己的子类型。子类型可以是全局的，也可以只针对指定模型，对于后者，子类型的res_model字段标记其所应用的模型。\n发送消息 模块业务逻辑可利用这个消息系统向用户发送通知。\n可使用message_post() 方法来发送通知。示例如下：\nself.message_post(\u0026#39;Hello!\u0026#39;) 以上代码添加一条普通文本消息，但不会向关注者发送通知。这是因为默认消息使用Log a Note发布，带有subtype=\u0026ldquo;mail.mt_note\u0026rdquo; 参数。\n要让消息还发送通知，需要使用mail.mt_comment子类型，如下例所示：\nself.message_post( \u0026#39;Hello again!\u0026#39;, subject=\u0026#39;Hello\u0026#39;, subtype=\u0026#39;mail.mt_comment\u0026#39;) 消息体是HTML格式的，所以我们可以添加标记来实现文本效果，如 \u0026lt;b\u0026gt; 为加粗， \u0026lt;i\u0026gt; 为斜体。\n出于安全原因消息体会被清洗，所以有些 HTML 元素可能最终无法出现在消息中。\n添加关注者 从业务逻辑角度来看还有一个有用的功能：可以向文档添加关注者，这样他们可以获取相应的通知。我们有以下几种方法来添加关注者：\nmessage_subscribe(partner_ids=\u0026lt;整型 id 列表\u0026gt;) 添加partner message_subscribe(channel_ids=\u0026lt;整型 id 列表\u0026gt;) 添加频道 message_subscribe_users(user_ids=\u0026lt;整型 id 列表\u0026gt;) 添加用户 默认的子类型会作用于每个订阅者。强制订阅指定的子类型列表，可添加subtype_ids=\u0026lt;整型 id 列表\u0026gt; 属性，来列出在订阅中使用指定子类型。如使用该属性，还会重置已有的关注者订阅子类型为所指定的子类型。\n创建向导 向导是为用户提供丰富交互的用户界面模式，常用于提供自动化流程的输入。\n例如，我们的借阅模块为图书用户提供一个向导，对借阅者批量发送邮件。比如可选取图书最早的那些借阅者，向他们发送消息要求归还图书。\n我们的用户开始从借阅列表中选择待使用的记录，然后从Action上下文菜单中选择Send Messages选项。这会打开向导表单，让用户写入消息主题和内容。点击Send按钮会向每个借阅所选图书的人发送邮件。\n向导模型 向导对用户显示为一个表单视图，通常是一个对话框，可填入一些字段，还有触发一些业务逻辑的按钮。随后会在向导逻辑中使用。\n它通过普通视图同样的模型/视图结构实现，但支持的模型继承的是models.TransientMode而不是models.Model。这种类型的模型也会在数据库体现，用于存储状态。向导的数据是临时的，让向导可完成其任务。有一个调度任务会定期清除向导数据表中的老数据。\n我们将使用wizard/checkout_mass_message.py 文件来定义与用户交互的字段：通知的借阅记录列表，标题和消息体。\n按如下步骤对library_checkout模块添加向导；\n首先编辑library_checkout/__init__.py文件并导入wizard/子目录，如下：\nfrom . import models from . import wizard 添加wizard/__init__.py文件并加入如下代码：\nfrom . import checkout_mass_message 然后创建实际的wizard/checkout_mass_message.py文件，内容如下：\nfrom odoo import api, exceptions, fields, models class CheckoutMassMessage(models.TransientModel): _name = \u0026#34;library.checkout.massmessage\u0026#34; _description = \u0026#34;Send Message to Borrowers\u0026#34; checkout_ids = fields.Many2many( \u0026#34;library.checkout\u0026#34;, string=\u0026#34;Checkouts\u0026#34; ) message_subject = fields.Char() message_body = fields.Html() 这样我们就准备好了向导所需的基本数据结构。\n注意普通模型不应存在关联临时模型的字段。\n结果就是临时模型不能与普通模型存在一对多关联。原因是临时模型的一对多关联会要求普通模型存在反向的多对一关联，这在自动清理临时记录会产生问题。\n替代方案是使用多对多关联。多对多关联存在单独的表中，关联某一方删除时都会自动删除该表中的对应行。\n向导访问权限 和普通模型一样，临时模型也需要定义访问权限规则。实现方式与普通模型相同，即通常在security/ir.model.access.csv文件中实现。\nODOO 13中的变化\n截至Odoo 12，临时模型无需访问权限规则。这在Odoo 13中进行了调整，因此现在临时模型和普通模型一样需要权限规则。\n对向导模型添加访问权限列表，编辑security/ir.model.access.csv文件，添加高亮部分的代码：\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink checkout_user,Checkout User,model_library_checkout,library_app.library_group_user,1,1,1,1 checkout_line_user,Checkout Line User,model_library_checkout_line,library_app.library_group_user,1,1,1,1 checkout_stage_user,Checkout Stage User,model_library_checkout_stage,library_app.library_group_user,1,0,0,0 checkout_stage_manager,Checkout Stage Manager,model_library_checkout_stage,library_app.library_group_manager,1,1,1,1 checkout_massmessage_user,Checkout Mass Message User,model_library_checkout_massmessage,library_app.library_group_user,1,1,1,1 一行足以对图书用户组添加完整权限，图书管理员组无需要指定权限。\n向导表单 向导表单视图与普通模型相同，只是它有两个特定元素：\n可使用 元素来替换操作按钮 special=\u0026ldquo;cancel\u0026rdquo; 按钮用于中断向导，不执行任何操作 wizard/checkout_mass_message_wizard_view.xml文件的内容如下：\n\u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;view_form_checkout_message\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Checkout Mass Message Wizard\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout.massmessage\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026#34;message_subject\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;message_body\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;checkout_ids\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;footer\u0026gt; \u0026lt;button type=\u0026#34;object\u0026#34; name=\u0026#34;button_send\u0026#34; string=\u0026#34;Send Messages\u0026#34; /\u0026gt; \u0026lt;button special=\u0026#34;cancel\u0026#34; string=\u0026#34;Cancel\u0026#34; class=\u0026#34;btn-secondary\u0026#34; /\u0026gt; \u0026lt;/footer\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id=\u0026#34;action_checkout_message\u0026#34; model=\u0026#34;ir.actions.act_window\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Send Messages\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;res_model\u0026#34;\u0026gt;library.checkout.massmessage\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;view_mode\u0026#34;\u0026gt;form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;binding_model_id\u0026#34; ref=\u0026#34;model_library_checkout\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;binding_view_types\u0026#34;\u0026gt;form,list\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;target\u0026#34;\u0026gt;new\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 以上的XML代码添加了两个数据记录，一个用于向导表单视图，另一个用于打开向导的动作。\nir.actions.act_window窗口动作记录使用binding_model_id字段值在Action上下文菜单中添加。\n别忘记在声明文件中添加该文件：\n\u0026#39;data\u0026#39;:[ \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#34;wizard/checkout_mass_message_wizard_view.xml\u0026#34;, \u0026#39;views/library_menu.xml\u0026#39;, \u0026#39;views/checkout_view.xml\u0026#39;, \u0026#39;data/library_checkout_stage.xml\u0026#39;, ], 向导表单如下：\n图8.5：发送消息向导表单\n译者注：此时更新模块会报错，因为我们尚未实现button_send方法，可先添加一个空方法完成安装\n打开该向导，用户应在借阅列表视图中选中一条或多条记录，通过位于列表视图上方的Action菜单选择Send Messages选项。\n向导业务逻辑 至此我们可打开向导表单，但还不能对记录执行任何操作。首先我们希望向导展示我们在借阅列表视图中选中的记录列表。\n打开向导表单时，它显示一个空表单。它还不是条记录，仅在点击按钮调用方法时才会成为记录。\n注：打开向导表单时，我们有一条空记录。还未调用create() 方法，这需要按下按钮。因此，它不能用于设置在向导表单中展示的值。\n可以通过对字段设置默认值来为空表单添加数据。default_get() 是负责计算记录默认值的ORM API 方法。可对其扩展添加业务逻辑，如下：\n@api.model def default_get(self, field_names): defaults_dict = super().default_get(field_names) # 在此处为defaults_dict添加值 return defaults_dict 以上方法可用于为checkout_ids字段添加默认值。但我们还需要知道如何访问原列表视图中所选中的记录列表。\n在从一个客户端窗口进入一个窗口时，网页客户端会在环境的context中存储原视图的一些数据。数据如下：\nactive_model：该模型的技术名 active_id：表单活跃记录或所访问列表视图中第一条记录的 ID active_ids：包含所选记录的列表（如果是表单则只有一个元素） active_domain：在表单视图中触发了该操作时 本例中，active_ids可用于获取列表视图中所选中的记录ID，并对checkout_ids字段设置默认值。此时default_get方法如下：\n@api.model def default_get(self, field_names): defaults_dict = super().default_get(field_names) checkout_ids = self.env.context[\u0026#34;active_ids\u0026#34;] defaults_dict[\u0026#34;checkout_ids\u0026#34;] = [(6, 0, checkout_ids)] return defaults_dict 首先，super() 用于调用框架的default_get() 实现，它返回包含默认值的字典。然后对defaults_dict添加checkout_id键，从环境上下文中读取active_ids值。\n这样在打开向导表单时，checkout_ids字段会自动将所选择的记录加入进业。接下来需要实现表单的Send Messages按钮的功能。\n查看表单的XML代码，我们可以看到按钮调用一个名为button_send的方法。应在wizard/checkout_mass_message.py文件中定义如下：\ndef button_send(self): self.ensure_one() for checkout in self.checkout_ids: checkout.message_post( body=self.message_body, subject=self.message_subject, subtype_xmlid =\u0026#34;mail.mt_comment\u0026#34; ) return True 这个方法用于操作单条记录，在self是记录集是无法正常使用。这里使用self.ensure_one() 进了显示的说明。\n这里的 self 表示在点击按钮时创建的向导记录数据。它包含在向导表单中输入的数据。执行了验证在确保用记输入了消息体文本。\n访问了checkout_ids字段，并遍历其中的每条记录。对单条借阅记录，使用mail.thread API提交消息。向记录关注者发送通知邮件必须使用mail.mt_comment子类型。消息内容和主题从self记录字段中提取。\n让方法返回内容是一种良好实践，至少返回True。原因是有些XML-RPC客户端不支持None值。在Python方法没有显式的return时，会隐式地返回None。在实践中可能不会碰到这个问题，因为网页客户端使用的是JSON-RPC，而不是XML-RPC，但仍是一种良好实践。\n向导是我们业务逻辑工作箱以及本单详细讲解的技巧中最为复杂的工具。\n业务逻辑还包括在执行某些操作的前后测试是否满足条件。下一节中讲解如何在不满足条件时抛出异常。\n抛出异常 有时输入的内容不适于所执行任务，代码需要警告用户给出错误消息并中断程序执行。这通过抛出异常来实现。Odoo提供的异常类在此时使用。\n最常用的Odoo异常有：\nfrom odoo import exceptions raise exceptions.ValidationError(\u0026#34;数据不一致\u0026#34;) raise exceptions.UserError(\u0026#34;输入错误\u0026#34;) ValidationError异常用于 Python 代码中的验证，比如对 @api.constrains装饰的方法。\nUserError应该用在其它所有操作不被允许的情况，因为这不符合业务逻辑。\nOdoo 9中的变化\n引用了UserError异常来替换掉Warning异常，淘汰掉 Warning 异常的原因是因为它与 Python 内置异常冲突，但 Odoo 保留了它以保持向后兼容性。\n通常所有在方法执行期间的数据操作在同一个数据库事务中，发生异常时会进行回滚。也就是说在抛出异常时，所有此前对数据的修改都会取消。\n下面就使用本例向导button_send方法来进行举例说明。试想一下如果执行发送消息逻辑时没有选中任何借阅文档是不是不合逻辑？同样如果没有消息体就发送消息也不合逻辑。下面就来在发生这些情况时向用户发出警告。\n编辑button_send()方法加入如下高亮部分的代码：\ndef button_send(self): self.ensure_one() if not self.checkout_ids: raise exceptions.UserError(\u0026#34;No checkouts were selected\u0026#34;) if not self.message_body: raise exceptions.UserError(\u0026#34;A message body is required\u0026#34;) for checkout in self.checkout_ids: checkout.message_post( body=self.message_body, subject=self.message_subject, subtype_xmlid=\u0026#34;mail.mt_comment\u0026#34; ) return True 使用异常时，请确保在代码文件顶部添加from odoo import exceptions导入。添加验证只需要查看是否满足某些条件，在不满足时抛出异常。\n下一节讨论每个Odoo开发者都应当非常熟悉的开发工具。我们先从自动化测试开始。\n编写单元测试 自动化测试是广泛接受的软件开发最佳实践。不仅可以帮助我们确保代码正确实现，更重要的是为我们未来的代码修改和重写提供了一个安全保障。\n对于 Python 这样的动态编程语言，因为没有编译这一步，语法错误经常不容易注意到。这也使得检测代码错误的单元测试愈发重要，比如类型错误的标识符名称。\n以下两个目标是我们编写测试时的灯塔。测试的第一个目标应是测试覆盖率：编写测试用例运行所有代码行。\n这通常对于每二个目标有很大的促进，也即代码的正确性。这是因为在提高测试覆盖率后，我们对大型用例构建测试用例就有基础了。\nℹ️Odoo 12中的变化\n在该版本之前，Odoo 还支持通过 YAML格式的数据文件进行测试。Odoo 12中删除了YAML数据文件引擎，不再支持该格式，有关该格式的最后一个文档请见官方网站。\n接下来我们将学习如何为模块添加测试用例并运行。\n添加单元测试 插件模块的测试必须放在tests/ 子目录下。测试执行器会自动在该目录下查找测试文件，并且在模块的顶级 __init__.py中不应导入该目录。\n要对library_checkout模块的向导逻辑添加测试，我们可以创建tests/__init__.py，在其中导入测试文件。本例中应包含如下代码：\nfrom . import test_checkout_mass_message 然后，我们要创建tests/test_checkout_mass_message.py文件，并确保其符合单元测试代码的基本结构：\nfrom odoo import exceptions from odoo.tests import common class TestWizard(common.SingleTransactionCase): def setUp(self,*args, **kwargs): super(TestWizard, self).setUp(*args, **kwargs) # 在此处添加测试配置代码 def test_01_button_send(self): \u0026#34;\u0026#34;\u0026#34;发送按钮应对借阅记录创建消息\u0026#34;\u0026#34;\u0026#34; # 添加测试代码 Odoo 提供了一些供测试使用的类：\nTransactionCase为每个测试使用不同的事务，在测试结束时自动回滚。 SingleTransactionCase将所有测试放在一个事务中运行，在最后一条测试结束后才进行回滚。这可以大幅提升测试速度，但每条测试需要按照其兼容的方式编写。 这些测试类是对Python标准库unittest测试用例的封装。更详细的内容请参见官方文档。\nsetUp() 方法用于准备测试数据并将其存储在类属性中，以后测试方法们使用。\n测试以类方法进行实现，如以示例代码中的est_01_button_send() 。测试用例方法名必须以test_ 为前缀。这样才能被测试执行器发现。测试方法按方法名称的顺序执行。\ndocstring方法在运行测试时在服务端日志中打印，用于提供对所执行测试的简短描述。\n运行测试 写好测试后就可以运行了。此时必须要升级或安装模块(-I 或 -u)并在Odoo服务端命令中添加--test-enable选项。\n命令如下：\n(env15) $ odoo -c library.conf --test-enable -u library_checkout --stop-after-init 仅会测试安装或升级的模块，这也是使用**-u选项的原因。如果需要安装某些依赖，也会运行其测试。如果不希望测试依赖，就先安装新模块，然后在升级模块(-u**) 时运行测试。\n虽然模块包含测试代码，但此处的代码没有执行任何测试，会成功运行。如果仔细查看服务端日志的话，会有报告测试运行的INFO消息，类似下面这样：\nINFO library odoo.modules.module: odoo.addons.library_checkout.tests.test_checkout_mass_message running tests. 测试代码基本结构已就位。下面我们添加实际测试代码。首先应配置数据。\n配置测试 编写测试的第一步是准备所使用的数据。这一般在setUp方法中完成。本例需要一条借阅记录，在测试向导时使用。\n使用指定用户执行测试操作很便捷，这样可以同时测试权限控制是否正常配置。这通过sudo() 模型方法来实现。记录集中携带这一信息，因此在使用 sudo() 创建后，相同记录集后续的操作都会使用相同上下文执行。\n以下是setUp方法中的代码：\nclass TestWizard(common.SingleTransactionCase): def setUp(self,*args, **kwargs): super(TestWizard, self).setUp(*args, **kwargs) # 配置测试数据 admin_user = self.env.ref(\u0026#34;base.user_admin\u0026#34;) self.Checkout = self.env[\u0026#34;library.checkout\u0026#34;].with_user(admin_user) self.Wizard = self.env[\u0026#34;library.checkout.massmessage\u0026#34;].with_user(admin_user) a_member = self.env[\u0026#34;library.member\u0026#34;].create({\u0026#34;partner_id\u0026#34;: admin_user.partner_id.id}) self.checkout0 = self.Checkout.create({\u0026#34;member_id\u0026#34;: a_member.id}) 此时我们就可以在测试中使用self.checkout0记录和self.Wizard模型了。\n编写测试用例 现在让我们来扩展一下初始框架中的test_button_test() 方法吧。\n基本的测试是运行测试对象中的部分代码，获取结果，然后使用断言语句来与预期结果进行对比。消息发送逻辑未返回任何值，因而需要其它方法。\nbutton_send() 方法对消息历史添加一条消息。一种确定是否发生的方式是计算方法执行前后的消息数。测试代码可在向导前后计算消息数据。如下代码添加了这一逻辑：\ndef test_01_button_send(self): \u0026#34;\u0026#34;\u0026#34;发送按钮应对借阅记录创建消息\u0026#34;\u0026#34;\u0026#34; count_before = len(self.checkout0.message_ids) # TODO: 运行向导 count_after = len(self.checkout0.message_ids) self.assertEqual( count_before + 1, count_after, \u0026#34;Expected one additional message in the Checkout.\u0026#34;, ) 这一检测在self.assertEqual语句中验证测试成功还是失败。它对比运行向导前后的消息数，预期会比运行前多一条消息。最后一个参数在测试失败时作为信息提示，它是可选项，但推荐使用。\nassertEqual方法仅是断言方法的一种，我们应根据具体用例选择合适的断言方法。unittest文档提供对所有这些方法的说明，参见 Python 官方文档。\n运行向导不够直接，需要模拟用户界面工作流。还记得环境上下文使用active_ids对向导传递数据。我们必须使用填入向导表单的数据创建一条向导记录，数据为button_send方法所使用的消息标题和内容。\n完整代码如下：\ndef test_01_button_send(self): \u0026#34;\u0026#34;\u0026#34;发送按钮应对借阅记录创建消息\u0026#34;\u0026#34;\u0026#34; count_before = len(self.checkout0.message_ids) Wizard0 = self.Wizard.with_context(active_ids=self.checkout0.ids) wizard0 = Wizard0.create({ \u0026#34;message_subject\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;message_body\u0026#34;: \u0026#34;This is a message.\u0026#34;, }) wizard0.button_send() count_after = len(self.checkout0.message_ids) self.assertEqual( count_before + 1, count_after, \u0026#34;Expected one additional message in the Checkout.\u0026#34;, ) with_context模型方法用于对环境上下文添加active_ids。然后create() 方法用于创建向导记录及添加用户输入的数据。最后调用button_send方法。\n更多的测试用例可使用测试类中的其它方法添加。记住使用TransactionCase测试，每次测试结束时会回滚，测试中所执行的操作都会撤销。SingleTransactionCase中测试是叠加的，测试顺序非常重要。因为测试是按照字母顺序执行的，所选的测试方法就有关了。为保持清晰，在测试方法名前添加数字是一种良好实践，前例中正是这么做的。\n测试异常 有时代码应抛出异常，这也应该进行水岸东方。例如，我们可以测试验证的执行是否正确。\n继续对向导进行测试，对消息体是否为空执行了检测。可添加测试来检测是否正确执行了验证。\n检查是否抛出了导演，相应的代码应放在with self.assertRaises() 代码块中。\n再添加一个测试如下：\ndef test_02_button_send_empty_body(self): \u0026#34;\u0026#34;\u0026#34;消息体而空时发送按钮报错\u0026#34;\u0026#34;\u0026#34; Wizard0 = self.Wizard.with_context(active_ids=self.checkout0.ids) wizard0 = Wizard0.create({}) with self.assertRaises(exceptions.UserError) as e: wizard0.button_send() 果button_send() 方法没有抛出UserException，测试会失败。如果抛出了异常则测试成功。所抛出的异常存储在变量e中，可供其它方法命令检查，例如验证错误消息的内容。\n使用日志消息 向日志文件写入消息有助于监控和审计运行的系统。它还有助于代码维护，在无需修改代码的情况下可以从运行的进程中轻松获取调试信息。\n要Odoo代码中使用日志功能，首先要准备一个日志记录器(logger)对象。在library_checkout/wizard/checkout_mass_message.py文件的头部添加如下代码：\nimport logging _logger = logging.getLogger(__name__) 这里使用了 Python标准库logging模块。 _logger通过当前代码文件名__name__来进行初始化。这样日志信息就会带有生成日志文件的信息。\n有以下几种级别的日志信息：\n_logger.debug(\u0026#39;DEBUG调试消息\u0026#39;) _logger.info(\u0026#39;INFO信息日志\u0026#39;) _logger.warning(\u0026#39;WARNING警告消息\u0026#39;) _logger.error(\u0026#39;ERROR错误消息\u0026#39;) 现在就可以使用logger向Odoo服务端日志中写入消息了。\n我们来为button_send向导方法来添加日志。在文件最后一行return True前添加如下代码：\n_logger.info( \u0026#39;Posted %d messages to Checkouts: %s\u0026#39;, len(self.checkout_ids), str(self.checkout_ids), ) 这样在使用向导发送消息时，服务端日志中会打印类似如下消息：\nINFO library odoo.addons.library_checkout.wizard.checkout_mass_message: Posted 2 messages to the Checkouts: [3, 4] 注意我们没有在日志消息中使用 Python 内插字符串，也即 % 运算符。具体来说，我们没使用 _logger.info(\u0026lsquo;Hello %s\u0026rsquo; % \u0026lsquo;World\u0026rsquo;) ，而是使用了类似 _logger.info(\u0026lsquo;Hello %s\u0026rsquo;, \u0026lsquo;World\u0026rsquo;) 。不使用内插使我们的代码少执行一个任务，让日志记录更为高效。因此我们应一直为额外的日志参数传入变量。\n服务器端日志的时间戳总是使用 UTC 时间。这可能会让你意外，但Odoo服务内部都是使用 UTC 来处理日期的。\n对于调试级别日志，我们使用 _logger.debug() 。例如，可以在checkout.message_post() 命令后添加如下调试日志消息：\n_logger.debug( \u0026#39;Message on %d to followers: %s\u0026#39;, checkout.id, checkout.message_follower_ids) 这不会在服务器日志中显示任何消息，因为默认的日志级别是INFO。需要将日志级别设置为DEBUG才会输出调试日志消息。\nOdoo 命令行选项--log-level可用于设置通用日志级别。例如使用--log-level=debug在命令行启用调试日志消息。\n我们还可以对指定模块设置日志级别。要开启向导的调试消息，使用--loghandler选项，该选项还可重复多次来对多个模块设置日志级别。\n例如我们的向导的 Python 模块是odoo.addons.library_checkout.wizard.checkout_mass_message，这在 INFO 日志消息中也可以看到。要将其设置为调试日志级别，使用如下命令行参数：\n--loghandler=odoo.addons.library_checkout.wizard.checkout_mass_message:DEBUG 有关 Odoo 服务器日志选项的完整手册可参见官方文档。\n小贴士：如果想要了解原始的 Python 日志细节，可先参见Python 官方文档。\n日志是有用的工具，但在进行调试时就捉襟见肘了。还有一些工具和技巧可辅助开发者的工作。我们在下一节中学习。\n学习一些开发工具 有一些工具可缓解开发者的工作。本书曾介绍过用户界面的开发者模式，就是其中之一。也可以在服务端使用该选项来提供对开发者更友好的功能。下面会进行详细说明。然后我们会讨论如何对服务端代码进行调试。\n服务端开发选项 Odoo服务提供一个--dev选项用于开启开发者功能、加速开发流程，比如：\n在发现插件模块中有异常时进入调试器。这通过配置调试器实现。默认为pdb。 Python 文件保存时自动重新加载代码，避免反复手动重启服务。这可通过reload选项实现。 直接从 XML 文件中读取视图定义，无需手动更新模块。这可通过xml选项实现。 在网页中直接使用的Python调试界面。这通过werkzeug选项实现。 --dev参数接收一个逗号分隔列表选项。可使用--dev=all开启所有这些选项。\n启用了调试器时，Odoo服务端默认使用的是 ，如果系统中安装了其它调试器也可以用其它选项。支持的调试器如下：\nipdb：参见 https://pypi.org/project/ipdb 了解详情 pudb：参见 https://pypi.org/project/pudb 了解详情 wdb：参见https://pypi.org/project/wdb 了解详情 在编辑Python 代码时，每次代码修改都需重启服务来重新加载代码在Odoo中使用。--dev=reload选项自动进行重新加载。启用后Odoo服务端会监测代码文件所做的修改，自动触发代码重新加载，让代码修改立即生效。\n要正常运行，要求安装watchdog Python包，可通过如下命令来安装：\n(env15) $ pip3 install watchdog --dev=all选项也可启用重新加载，大多情况下都使用它：\n(env15) $ odoo -c library.conf --dev=all 注意这仅对 Python 代码的修改有益。对于其它修改，如模型数据结构，需要进行模块升级，仅仅重新加载是不够的。\n调试 开发者的大部分工作都是调试代码。打断点再单步调试会很方便。\nOdoo为运行Python代码等待客户端请求的服务端，请求由相应的服务端代码处理，然后对客户端返回响应。也就是Python代码的调试在服务端完成。断点在服务端中启用，暂停该行代码的服务端执行。因此，设置断点以及操作调试器都需要开发者在终端窗口中完成。\nPython 调试器 最简单的调试工具是Python集成的调试器pdb。但其它选项的用户界面更加丰富，接近于高级IDE。\n有两种方式触发调试器弹窗。\n一种是抛出未处理的异常且启用了--dev=all选项。调试器还会在导致异常的命令处停止代码执行。开发者可查看当前的变量和程序语句，来更好地了解背后的原因。\n另一种是编辑代码拖动打断点，在需要执行暂停的地方加入如下行：\nimport pdb; pdb.set_trace() 这不需要开启**–dev模式。需要重新加载Odoo服务端来使用修改后的代码。在执行程序到达pdb.set_trace()** 命令时，会在服务端终端窗口显示一个 (pdb) Python弹窗，等待输入。\n(pdb) 弹窗以Python的shell运行，可在执行任意表达式或当前执行上下文的命令。也就是说可以查看甚至修改当前变量。\n有一些与调试器相关的命令。最重要的命令如下：\nh (help) 显示可用 pdb 命令的汇总 p (print) 运行并打印表达式 pp (pretty print) 有助于打印数据结构，如字典或列表 l (list) 列出下一步要执行代码的周边代码 n (next) 进入下一条命令 s (step) 进入当前命令 c (continue)继续正常执行 u (up) 在执行栈中上移 d (down)在执行栈中下移 bt (backtrace)显示当前执行栈 Python官方文档中包含了对pdb命令完整的描述。\n示例调试会话 要理解如何使用调试器功能，我们来看看调试器会话长什么样。\n在button_send() 向导方法的第一行添加一个调试器断点，如下：\ndef button_send(self): import pdb; pdb.set_trace() self.ensure_one() # ... 在重新执行服务加载后，打开Send Message向导表单，点击Send Messages按钮。这会在服务端触发button_send() 方法，在断点会暂停。网页客户端会处于**Loading…**状态，等待服务端响应。\n此时，服务端所运行的终端会显示类似如下信息：\n\u0026gt; /home/vagrant/odoo-dev/custom-addons/library_checkout/wizard/checkout_mass_message.py(24)button_send() -\u0026gt; self.ensure_one() (Pdb) 这是pdb调试器对话框，前两行提供有关Python代码执行暂停的相关信息。第一行显示文件、行号和函数名，第二行为下面要执行的代码。\n小贴士：在调试会话中，服务端日志消息会乱入。大部分都来自werkzeug模块。可通过Odoo命令行的--log-handler=werkzeug:WARNING选项静默显示。另一个简化通用日志的选项是--log-level=warn。\nThe p debug command prints out the result of an expression, while pp does the same but formats the output to be more readable, especially the dict and list data structures. For example, to print the value for the checkout_ids field that\u0026rsquo;s used in the wizard, type the following:\n此时输入 h，可以看到可用命令的一个快速指南。输入 l 显示当前行代码，以及其周边的代码。\n输入 n 会运行当前行代码并进入下一行。如果只按下 Enter，会重复上一条命令。\np调试命令会打印表达式结果，而pp效果桢，便输出格式可读性更强，对字典和列表数据结构尤其如此。例如，打印向导中使用的checkout_ids字段，输入如下命令：\n(Pdb) p self.checkout_ids library.checkout(30,) 调试对话框可运行Python命令和表达式。支持任意 Python 表达式，甚至是分配赋值。\n在使用完成调试会话后，按c回到正常程序执行。有时可能希望中断执行，可按q退出。\n我们可以逐行调试，在任意时刻按下 c 继续正常运行。\n小贴士： 在由调试器回到终端窗口时，如果终端不响应，在终端中的输入不显示。可通过reset命令解决输入 reset 。\n其它 Python 调试器 pdb 的优势是“开箱即用”，它简单但粗暴，还有一些使用上更舒适的选择。\nipdb(Iron Python debugger)是一个常用的选择，它使用和 pdb 一样的命令，但做了一些改进，比如添加 tab 补全和语法高亮来让使用更舒适。可通过如下命令安装：\npip3 install ipdb 使用如下命令添加断点：\nimport ipdb; ipdb.set_trace() 另一个可选调试器是pudb，它也支持和pdb相同的命令，仅用在文本终端中，但使用了类似 IDE 调试器的图形化显示。当前上下文的变量及值这类有用信息，在屏幕上它自己的窗口中显示。\nsudo apt-get install python-pudb # 使用Debian系统包 pip3 install pudb # 使用 pip，可在虚拟环境中 添加断点与pdb没什么分别：\nimport pudb; pudb.set_trace() 也可以使用更短更简短的方式：\nimport pudb; pu.db 上面的代码输起来更快，还达到了希望的效果-添加代码执行断点。\n注：从Python 3.7开始，断点可使用breakpoint() 方法来代替pdb.set_trace() 。调试库可重载breakpoint() 的行为直接调用。但是，在写本书时，pudb和ipdb还没这么做，因此使用breakpoint() 没有什么好处。\n打印消息和日志 有时我们只需要查看一些变量的值或者检查一些代码段是否执行。Python的print() 命令可以在不中断执行流的情况下完美解决这些问题。打印的内容发送至标准输出，不会存储到服务端的日志文件中。\nprint() 函数仅用于辅助开发，不应出现在最终部署的代码中。如果print语句还可帮助查看生产中的问题，考虑将其换成调试级别的日志消息。\n查看和关闭运行进程 还有一些查看 Odoo 运行中进程的小技巧。\n首先我们需要找到相应的进程ID (PID)。在每条日志消息时间戳之后都打印该数字。另一种查找PID的方式是在另一个终端窗口中运行如下命令：\nps ax | grep odoo-bin 示例输出如下：\n2650 pts/5 S+ 0:00 grep --color=auto odoo 21688 pts/4 Sl+ 0:05 python3 /home/daniel/work15/env15/bin/odoo 输出的第一列是进程的PID，上例中Odoo的进程PID为21688。\n知道了进程PID后，可对Odoo服务端进程发送信息。使用kill命令发送信息。默认kill发送信号终止进程，但也可发送其它更友好的信号。\n如果发送SIGQUIT或**-3**信号Odoo服务端会打印代码执行处的栈追踪：\nkill -3 \u0026lt;PID\u0026gt; 在发送SIGQUIT后，Odoo服务端日志会显示一个栈追踪记录。对于了解当前执行的代码很有用。这一信息为为每个所使用的纯种打印。\n这用于一些代码性能分析中，追踪服务端时间消耗在何处，对代码执行性能分析。有关代码性能分析的资料可参见官方文档。\n其它可向 Odoo 服务端进程发送的信号有：HUP重新加载服务，INT或TERM强制关闭服务，如下：\nkill -HUP \u0026lt;PID\u0026gt; kill -TERM \u0026lt;PID\u0026gt; HUP信号对于不停止服务又重新加载Odoo配置尤为有用。\n总结 本章中我们探讨了ORM API的各种功能以及以及如何使用这些功能来创建动态应用与用户互动，这可以帮助用户避免错误并自动化一些单调的任务。\n模型验证和计算字段可以处理很多用例，但并不是所有的。我们学习了如何继承API的create, write和unlink 方法来处理更多用例。\n对更丰富的用户交互，我们使用了 mail 内核插件 mixin 来为用户添加功能，方便他们围绕文档和活动规划进行交流。向导让应用可以与用户对话，收集所需数据来运行具体进程。异常允许应用终止错误操作，告知用户存在的问题并回滚中间的修改，保持系统的一致性。\n我们还讨论了开发者可用于创建和维护应用的工具：记录日志消息、调试工具和单元测试。\n在下一章中，我们还将使用 ORM，但会从外部应用的视角来操作，将 Odoo 服务端作为存储数据和运行业务进程的后端。\n扩展阅读 以下是本文所讨论的内容相关参考材料：\nORM参考 消息和活动功能 Odoo 测试参考 Python 单元测试参考 "
},
{
	"uri": "/odoo/9/",
	"title": "第九章 Odoo 15开发之外部 API - 集成第三方系统",
	"tags": [],
	"description": "",
	"content": "Odoo 服务端提供有外部 API，可供网页客户端和其它客户端应用使用。本章中我们将学习如何Odoo 的外部 API来实现将其Odoo服务端作为后端的外部应用。\n可通过编写脚本来加载或修改Odoo数据，或是集成Odoo现有的业务应用，作为对Odoo应用一种补充。\n我们将描述如何使用Odoo RPC调用，然后根据所学知识使用 Python为图书应用创建一个简单的命令行应用。\n本章的主要内容有：\n介绍学习项目：图书目录的客户端应用 在客户端机器上配置 Python 探索Odoo的外部API 实现客户端应用的XML-RPC接口 实现客户端应用的用户界面 使用OdooRPC库 学完本章后，读者可以创建一个简单的Python应用，使用Odoo作为后端进行查询和数据存储。\n开发准备 本文基于第三章 Odoo 15开发之创建第一个 Odoo 应用创建的代码，具体代码请参见 GitHub 仓库。应将library_app模块放在addons路径下并进行安装。为保持前后一致，我们将使用第二章 Odoo 15开发之开发环境准备中的安装操作。本章完成后的代码请参见 GitHub 仓库。\n学习项目-图书目录客户端 本文中，我们将开发一个简单的客户端应用来管理图书目录。这是一个命令行接口(CLI) 应用，使用 Odoo 来作为后端。应用的功能很基础，核心放在用于与 Odoo服务端交互的技术。\n这个简单CLI应用可以完成如下功能：\n通过标题搜索并列出图书 向目录添加新书籍 编辑图书标题 我们的主要目标是使用Odoo对外API，因此不希望引用其它读者可能不太熟悉的编程语言。有了这一出发点，最好的方式是就是使用Python来实现客户端应用。不过只要掌握了一种语言的XML-RPC库，相关处理RPC的技术同样适用于其它语言。\n这个应用是一个 Python 脚本，等待输入命令来执行操作。示例如下：\n$ python3 library.py add \u0026#34;Moby-Dick\u0026#34; $ python3 library.py list \u0026#34;moby\u0026#34; 60 Moby-Dick $ python3 library.py set 60 \u0026#34;Moby Dick\u0026#34; 这个示例会话演示了如何使用客户端应用添加、列出及修改图书标题。\n该客户端应用通过Python运行，在开始编写客户端应用代码之前，应确保在客户端机器上安装有Python。\n在客户端机器上安装 Python Odoo API 可以在外部通过两种协议访问：XML-RPC和JSON-RPC。任何外部程序，只要是能实现其中一种协议的客户端，就可以与 Odoo 服务端进行交互。为避免引入其它编程语言，我们将保持使用 Python 来探讨外部 API。\n到目前为止我们仅在服务端运行了 Python 代码。现在我们要在客户端上使用 Python，所以你可能需要在电脑上做一些额外设置。\n要学习本文的示例，你需要能在操作电脑上运行 Python 3 代码。如果在前面已按前面章节配置过开发环境，应该已经就绪了，否则请安装Python。\n可通过在命令行终端运行python3 --version命令来进行确认。如果没有安装，请参考官方网站找到所使用的平台的安装包。\nUbuntu中通常预安装了 Python 3，如果没有安装，可通过以下命令进行安装：\nsudo apt-get install python3 python3-pip 如果你使用的是 Windows 10，可通过微软应用商店进行安装。\n在PowerShell中运行python3会直接引导你去相应的下载页面（这算是龟叔去微软后增加的福利吗？）。\n通过一键安装包安装了Odoo的Windows用户可能会奇怪为什么Python解释器没有准备就绪。这时需要进行额外的安装。简单地说是因为 Odoo一键安装包内置了Python解析器，在操作系统层面无法直接使用。\n现在读者已经安装好了Python，就可以开始使用Odoo对外API了。\n学习Odoo外部 API 在实现客户端应用前应当先熟悉下Odoo外部API。以下小节中使用Python解释器一探XML-RPC API。\n使用XML-RPC连接 Odoo API 访问Odoo服务最简单的方法是使用XML-RPC，我们可以使用 Python 标准库中的xmlrpclib来实现。\n不要忘记我们是要编写客户端程序连接服务端，因此需运行 Odoo 服务端实例来供连接。本例中我们假设 Odoo 服务端实例在同一台机器上运行，http://localhost:8069 ，但读者可以使用任意运行着服务的其它机器，只需能连接其IP地址或服务器名。\nOdoo的 xmlrpc/2/common端点暴露了公共方法，无需登录即可访问。可用于查看服务端版本及检测登录信息。我们使用xmlrpc库来研究对外可访问的Odoo API common。\n首先打开 Python 3终端并输入如下代码：\n\u0026gt;\u0026gt;\u0026gt; from xmlrpc import client \u0026gt;\u0026gt;\u0026gt; srv = \u0026#34;http://localhost:8069\u0026#34; \u0026gt;\u0026gt;\u0026gt; common = client.ServerProxy(\u0026#34;%s/xmlrpc/2/common\u0026#34; % srv) \u0026gt;\u0026gt;\u0026gt; common.version() {\u0026#39;server_version\u0026#39;: \u0026#39;15.0\u0026#39;, \u0026#39;server_version_info\u0026#39;: [15, 0, 0, \u0026#39;final\u0026#39;, 0, \u0026#39;\u0026#39;], \u0026#39;server_serie\u0026#39;: \u0026#39;15.0\u0026#39;, \u0026#39;protocol_version\u0026#39;: 1} 以上代码导入了xmlrpc库，然后创建了一个包含服务端地址和监听端口信息的变量。请根据自身状况进行修改（如 Alan 使用srv = 'http://192.168.0.12:8069'）。\n下一步访问服务端公共服务（无需登录），在 /xmlrpc/2/common 端点上暴露。其中一个可用方法是version()，用于查看服务端版本。我们使用它来确认可与服务端进行通讯。\n另一个公共方法是authenticate()。该方法确认用户名和密码可被接受，返回的用户 ID可用于后续请求。示例如下：\n\u0026gt;\u0026gt;\u0026gt; db, user, password = \u0026#34;odoo-dev\u0026#34;, \u0026#34;admin\u0026#34;, \u0026#34;admin\u0026#34; \u0026gt;\u0026gt;\u0026gt; uid = common.authenticate(db, user, password, {}) \u0026gt;\u0026gt;\u0026gt; print(uid) 2 **authenticate()**方法接收4个参数：数据库名、用户名、密码以及user agent。些前的代码通过变量存储这些信息，然后将使用这些变量传参。\nODOO 14中发生的改变\nOdoo 14支持API密钥，可使用它来获取Odoo API外部访问权限。API密钥可在用户的首选项（Preferences）表单中进行设置，位于账号安全（Account Security）标签下。\n用户代理(User Agent)环境用于提供有关客户端的元信息。为必填项，至少应传一个空字典 {}。\n若验证失败，返回值为False。\ncommon公共端点内容非常有限，要访问ORM API或是其它端点则需要先进行账号验证。\n使用XML-RPC运行服务器端方法 要访问Odoo的模型及方法，需要使用xmlrpc/2/object。该端点要求先登录才能请求。\n这个端点暴露了一个通用的execute_kw方法，接收模型名称、要调用的方法以及传递给方法的参数列表。\n下面有一个演示execute_kw的示例。它调用了search_count方法，返回匹配域过滤器的记录数：\n\u0026gt;\u0026gt;\u0026gt; api = client.ServerProxy(\u0026#39;%s/xmlrpc/2/object\u0026#39; % srv) \u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#39;res.users\u0026#39;, \u0026#39;search_count\u0026#39;, [[]]) 3 此处我们使用了xmlrpc/2/endpoint对象访问服务端 API。调用的方法名为execute_kw()，接收如下参数：\n连接的数据库名 连接用户ID 用户密码（或API密钥） 目标模型名称 调用的方法 位置参数列表 可选的关键字参数字典(本例中未使用) 可调用所有的模型方法，以下划线(_)开头的除外，这些是私有方法。有些的方法的返回值如果无法通过XML-RPC发送，则无法使用XML-RPC协议调用。browse()方法就属于这种情况，它返回的是一个记录集对象。使用XML-RPC调用browse()会返回TypeError: cannot marshal objects的报错。在进行XML-RPC调用时应将browse()换成read或是search_read，所返回的数据格式可通过XML-RPC协议发送给客户端。\n下面我们就来看看如何通过search和read查询Odoo数据。\n使用API方法search和read Odoo的服务端使用browse来查询记录。在RPC客户端中无法使用它，因为记录集对象无法通过RPC协议进行传输。这时应当使用read方法。\nread([, [])和browse方法类似，但它返回的不是记录集，而是记录列表。每条记录都是包含请求字段及数据的字典。\n下面来看如何通过read() 从Odoo获取数据：\n\u0026gt;\u0026gt;\u0026gt; api = client.ServerProxy(\u0026#34;%s/xmlrpc/2/object\u0026#34; % srv) \u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.users\u0026#34;, \u0026#34;read\u0026#34;, [2, [\u0026#34;login\u0026#34;, \u0026#34;name\u0026#34;, \u0026#34;company_id\u0026#34;]]) [{\u0026#39;id\u0026#39;: 2, \u0026#39;login\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Mitchell Admin\u0026#39;, \u0026#39;company_id\u0026#39;: [1, \u0026#39;YourCompany\u0026#39;]}] 上例对res.users模型调用了read方法，传入了两个位置参数：记录ID 2 （也可以使用ID列表）以及获取字段的列表 [\u0026ldquo;login\u0026rdquo;, \u0026ldquo;name\u0026rdquo;, \u0026ldquo;company_id\u0026rdquo;]，没传递关键字参数。\n得到结果是一个字典列表，其中每个字典对应一条记录。对多字段的值有一种具体的表现形式。由记录ID和记录显示名组成的一对。例如，上例中返回的company_id的值为 [1, \u0026lsquo;YourCompany\u0026rsquo;]。\n可能会不知道记录ID，这时需要使用search调用来查找到匹配域过滤器的那些记录ID。\n例如，想要查找管理员用户时，可使用 [(\u0026ldquo;login\u0026rdquo;, \u0026ldquo;=\u0026rdquo;, \u0026ldquo;admin\u0026rdquo;)]。这一RPC调用如下：\n\u0026gt;\u0026gt;\u0026gt; domain = [(\u0026#34;login\u0026#34;, \u0026#34;=\u0026#34;, \u0026#34;admin\u0026#34;)] \u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.users\u0026#34;, \u0026#34;search\u0026#34;, [domain]) [2] 其结果是仅有一个元素（2）的列表，元素为admin用户的ID。\n经常会使用search结合read方法查找符合域过滤器条件的ID，然后再获取它们的数据。在客户端应用中，这会反复调用服务端。可通过search_read方法进行简化，它可以一步就执行以上两个操作。\n下例为使用search_read来查找admin用户并返回其名称：\n\u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.users\u0026#34;, \u0026#34;search_read\u0026#34;, [domain, [\u0026#34;login\u0026#34;, \u0026#34;name\u0026#34;]]) [{\u0026#39;id\u0026#39;: 2, \u0026#39;login\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Mitchell Admin\u0026#39;}] 这个search_read方法使用了两个位置参数：包含域过滤器的列表，以及另一个包含需获取字段的列表。\nsearch_read的参数如下：\ndomain： 域过滤器表达式列表 fields： 待获取字段名称列表 offset： 跳过的记录数或用于分页 limit： 返回的最大记录数 order： 用于ORDER BY语句的字符串 对read和search_read，fields均为可选参数。如未提供，会获取所有的模型字段。但这可能会使用到大开销的字段计算并且会返回大量无需使用的数据。因此建议显式地提供字段列表。\nexecute_kw调用既可使用位置参数也可使用关键字参数。以下是把位置参数换成关键字参数的示例：\n\u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.users\u0026#34;, \u0026#34;search_read\u0026#34;, [], {\u0026#34;domain\u0026#34;: domain, \u0026#34;fields\u0026#34;: [\u0026#34;login\u0026#34;, \u0026#34;name\u0026#34;]}) [{\u0026#39;id\u0026#39;: 2, \u0026#39;login\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Mitchell Admin\u0026#39;}] 获取数据时最常使用的就是search_read，但还存在其它方法用于写入数据或触发其它业务逻辑。\n调用其它API方法 所有的其它模型方法也通过RPC对外暴露，那以下划线开头的私有方法除外。也就是说可以调用create、write和unlink来修改服务端的数据。\n我们来看一个例子。以下代码新建一条partner记录，然后修改记录，再读取记录确定是否写入了修改，最后进行了删除：\n\u0026gt;\u0026gt;\u0026gt; x = api.execute_kw(db, uid, password, \u0026#34;res.partner\u0026#34;, ... \u0026#34;create\u0026#34;, ... [{\u0026#39;name\u0026#39;: \u0026#39;Packt Pub\u0026#39;}]) \u0026gt;\u0026gt;\u0026gt; print(x) 63 \u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.partner\u0026#34;, ... \u0026#34;write\u0026#34;, ... [[x], {\u0026#39;name\u0026#39;: \u0026#39;Packt Publishing\u0026#39;}]) True \u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.partner\u0026#34;, ... \u0026#34;read\u0026#34;, ... [[x], [\u0026#34;name\u0026#34;]]) [{\u0026#39;id\u0026#39;: 63, \u0026#39;name\u0026#39;: \u0026#39;Packt Publishing\u0026#39;}] \u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.partner\u0026#34;, ... \u0026#34;unlink\u0026#34;, ... [[x]]) True \u0026gt;\u0026gt;\u0026gt; api.execute_kw(db, uid, password, \u0026#34;res.partner\u0026#34;, ... \u0026#34;read\u0026#34;, ... [[x]]) [] XML-RPC的一个限制是它不支持None值。有一个XML-RPC插件可支持None值，但这取决于客户端使用的XML-RPC库。没有返回值的方法可能无法使用XML-RPC，因为这些方法隐式地返回None。这也是为什么方法的最佳实践要求有返回值，至少应返回True。另一个选择是使用JSON-RPC。OdooRPC库支持该协议，本文的使用OdooRPC库一节中会用到它。\n模型中以下划线开头的方法被看作私有方法，无法通过XML-RPC对外暴露。\n小贴士：通常客户端应用希望复制用户在Odoo表单中输入的内容。调用create()方法可能还不够，因为表单可能会使用onchange方法自动化操作一些字段，这通过表单交互触发，没经过create()。解决方案是在Odoo中创建一个自定义方法，其中使用create()方法并运行onchange方法中的操作。\n有必须反复说明一下，Odoo的对外API大部分编程语言都可以使用。官方文档中包含有Ruby、PHP和Java使用示例。\n至此，我们已学习到如何使用XML-RPC协议调用Odoo方法。接下来我们使用它来构建图书目录客户端应用。\n实现图书客户端XML-RPC 接口 下面就来实现图书目录客户端应用。\n可分为两个文件：一个是包含服务端后台的Odoo后台接口，library_xmlrpc.py，另一个用于用户界面，library.py。这让我们可以对后台接口使用替代的实现。\n先从Odoo后台组件开始，LibraryAPI 类用于配置与Odoo服务端之间连接，以支持与Odoo交互所需的方法。所要实现的方法有：\nsearch_read(\u0026lt;title\u0026gt;) 通过标题查找图书数据 create(\u0026lt;title\u0026gt;) 使用指定标题创建图书 write(\u0026lt;id\u0026gt;, \u0026lt;title\u0026gt;) 使用图书ID更新书名 unlink(\u0026lt;id\u0026gt;) 使用ID删除图书 在电脑上选择一个目录存放应用文件，并创建library_xmlrpc.py文件。先添加类的构造方法，如下：\nimport xmlrpc.client class LibraryAPI: def __init__(self, host, port, db, user, pwd): common = xmlrpc.client.ServerProxy( \u0026#34;http://%s:%d/xmlrpc/2/common\u0026#34; % (host, port)) self.api = xmlrpc.client.ServerProxy( \u0026#34;http://%s:%d/xmlrpc/2/object\u0026#34; % (host, port)) self.uid = common.authenticate(db, user, pwd, {}) self.pwd = pwd self.db = db self.model = \u0026#34;library.book\u0026#34; 类中存储了执行对目标模块调用所需的所有信息：API XML-RPC引用、uid、密码、数据库名以及模型名。\n对Odoo的RPC调用会使用相同的execute_kw RPC方法。下面对其添加一层封装，放在**_execute()** 私有方法中。它利用对象存储的数据提供更小的函数签名，如以下代码所示：\ndef _execute(self, method, arg_list, kwarg_dict=None): return self.api.execute_kw( self.db, self.uid, self.pwd, self.model, method, arg_list, kwarg_dict or {}) _execute() 私有方法用于让更高阶的方法实现更简洁。\n第一个公有方法是search_read()。它接收 一个可选字符串用于搜索书名。如未提供标题，则会返回所有记录。相应的实现如下：\ndef search_read(self, title=None): domain = [(\u0026#34;name\u0026#34;, \u0026#34;ilike\u0026#34;, title)] if title else [] fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;] return self._execute(\u0026#34;search_read\u0026#34;, [domain, fields]) create() 方法用于按给定书名创建新书并返回所创建记录的 ID：\ndef create(self, title): vals = {\u0026#34;name\u0026#34;: title} return self._execute(\u0026#34;create\u0026#34;, [vals]) write() 方法中传入新书名和图书 ID 作为参数，对该书执行写操作：\ndef write(self, id, title): vals = {\u0026#34;name\u0026#34;: title} return self._execute(\u0026#34;write\u0026#34;, [[id], vals]) 最后unlink() 方法用于删除给定ID的图书：\ndef unlink(self, id): return self._execute(\u0026#34;unlink\u0026#34;, [[id]]) 在该Python文件最后添加一段测试代码在运行时执行：\nif __name__ == \u0026#34;__main__\u0026#34;: # 测试配置 host, port, db = \u0026#34;localhost\u0026#34;, 8069, \u0026#34;odoo-dev\u0026#34; user, pwd = \u0026#34;admin\u0026#34;, \u0026#34;admin\u0026#34; api = LibraryAPI(host, port, db, user, pwd) from pprint import pprint pprint(api.search_read()) 如果执行以上 Python 脚本，我们可以打印出图书的内容：\n$ python3 library_xmlrpc.py [{\u0026#39;id\u0026#39;: 3, \u0026#39;name\u0026#39;: \u0026#39;Brave New World\u0026#39;}, {\u0026#39;id\u0026#39;: 2, \u0026#39;name\u0026#39;: \u0026#39;Odoo 11 Development Cookbook\u0026#39;}, {\u0026#39;id\u0026#39;: 1, \u0026#39;name\u0026#39;: \u0026#39;Odoo Development Essentials 11\u0026#39;}] 现在已经有了对 Odoo 后台的简单封装，下面就可以处理命令行用户接口了。\n实现客户端用户接口 我的目标是学习如何写外部应用和 Odoo 服务之间的接口，前面已经实现了。但不能止步于此，我们再为这个最小化客户端应用构建一个用户接口。\n为保持尽量简单，我们使用简单的命令行用户接口并避免使用其它依赖。那我们可以使用Python 内置功能和ArgumentParser库来实现这个命令行应用。代码如下：\nfrom argparse import ArgumentParser from library_xmlrpc import LibraryAPI 下面我们来看看参数解析器接收的命令，有以下四条命令：\nlist 搜索并列出图书 add 添加图书 set 修改书名 del 删除图书 实现以上命令的命令行解析代码如下：\nparser = ArgumentParser() parser.add_argument( \u0026#34;command\u0026#34;, choices=[\u0026#34;list\u0026#34;, \u0026#34;add\u0026#34;, \u0026#34;set\u0026#34;, \u0026#34;del\u0026#34;]) parser.add_argument(\u0026#34;params\u0026#34;, nargs=\u0026#34;*\u0026#34;) # 可选参数 args = parser.parse_args() 这里的args对象表示用户传入的参数。args.command是所用到的命令，在给定args.params时，其存储的是命令所使用的其它参数。\n如果未传参数或参数错误，参数解析器会进行处理，提示用户应该输入的内容。有关argparse更完整的说明，请参考官方文档。\n下一步是执行操作响应用户输入的命令。我们先创建一个LibraryAPI实例。这需要提供详细的Odoo连接信息，在我们的简单实现中采用了硬编码，代码如下：\nhost, port, db = \u0026#34;localhost\u0026#34;, 8069, \u0026#34;odoo-dev\u0026#34; user, pwd = \u0026#34;admin\u0026#34;, \u0026#34;admin\u0026#34; api = LibraryAPI(host, port, db, user, pwd) 第一行代码设置服务实例的一些固定参数以及要连接的数据库。本例中，我们连接本地 Odoo 服务(localhost)，监听8069默认端口，并使用 odoo-dev数据库。如需连接其它服务器和数据库，请对参数进行相应调整。\n还需要添加代码处理每条命令。我们先从返回图书列表的list命令开始：\nif args.command == \u0026#34;list\u0026#34;: title = args.params[:1] if len(title) != 0: title = title[0] books = api.search_read(title) for book in books: print(\u0026#34;%(id)d %(name)s\u0026#34; % book) 这里我们使用了LibraryAPI.search_read() 来从服务端获取图书记录列表。然后遍历列表中每个元素并打印。\n下面添加add命令：\nif args.command == \u0026#34;add\u0026#34;: title = args.params[0] book_id = api.create(title) print(\u0026#34;Book added with ID %d for title %s.\u0026#34; % (book_id, title)) 因为主要的工作已经在LibraryAPI 对象中完成，我们只要调用create() 方法并向终端用户显示结果即可。\nset命令允许我们修改已有图书的书名，应传入两个参数，新书名和图书的 ID：\nif args.command == \u0026#34;set\u0026#34;: if len(args.params) != 2: print(\u0026#34;set command requires a Title and ID.\u0026#34;) else: book_id, title = int(args.params[0]), args.params[1] api.write(book_id, title) print(\u0026#34;Title of Book ID %d set to %s.\u0026#34; % (book_id, title)) 最终我们要实现 del 命令来删除图书记录。实现方式和之前并没有什么差别：\nif args.command == \u0026#34;del\u0026#34;: book_id = int(args.params[0]) api.unlink(book_id) print(\u0026#34;Book with ID %s was deleted.\u0026#34; % book_id) 客户端应用至此已完成，可以尝试使用一些命令。应该可以执行本文开头的那些命令。\n小贴士：在Linux系统中，可通过执行chmod +x library.py命令并在文件的首行添加**#!/usr/bin/env python3来让library.py文件变为可执行。之后就可以在命令行中运行了./library.py**。\n这是一个非常基础的应用，还有很多改进的方式。我们的目的是使用Odoo RPC API构建一个最小可用应用。\n使用OdooRPC库 另一个可以考虑的客户端库是OdooRPC。它是一个完整的客户端库，把XML-RPC协议换成了JSON-RPC 协议。事实上 Odoo 官方客户端使用的就是JSON-RPC，XML-RPC更多是用于支持向后兼容性。\nℹ️OdooRPC库现在由 OCA 管理和持续维护。了解更多请参见OCA。\nOdooRPC库可通过PyPI安装：\npip3 install odoorpc OdooRPC 在新建 odoorpc.ODOO 对象时配置了服务端连接。此时我们应使用ODOO.login() 方法创建一个用户会话。和服务端一样，会员有一个包含会话环境的env属性，包括用户ID、uid 和上下文。\nOdooRPC库可用于对服务端的library_xmlrpc.py接口提供一个替代实现。功能相同，只是把XML-RPC换成了JSON-RPC。\n创建library_odoorpc.py Python模块来对library_xmlrpc.py模块进行修改。新建的library_odoorpc.py文件中加入如下代码：\nimport odoorpc class LibraryAPI(): def __init__(self, host, port, db, user, pwd): self.api = odoorpc.ODOO(host, port=port) self.api.login(db, user, pwd) self.uid = self.api.env.uid self.model = \u0026#34;library.book\u0026#34; self.Model = self.api.env[self.model] def _execute(self, method, arg_list, kwarg_dict=None): return self.api.execute( self.model, method, *arg_list, **kwarg_dict) OdooRPC库实现Model和Recordset对象来模拟服务端对应的功能。目标是在客户端编程与服务端编程应基本一致。客户端使用的方法利用这点并在self.Model属性中存储对library.book模型引用，通过OdooRPC的**env[\u0026ldquo;library.book\u0026rdquo;]**调用提供。\n这里同样实现了**_execute()方法，可与XML-RPC版本进行对比。OdooRPC库中的execute()**方法可运行指定的Odoo模型方法。\n下面我们来实现search_read(), create(), **write()和unlink()这些客户端方法。在相同文件的LibraryAPI()**类中添加如下方法：\ndef search_read(self, title=None): domain = [(\u0026#34;name\u0026#34;, \u0026#34;ilike\u0026#34;, title)] if title else [] fields = [\u0026#34;id\u0026#34;, \u0026#34;name\u0026#34;] return self.Model.search_read(domain, fields) def create(self, title): vals = {\u0026#34;name\u0026#34;: title} return self.Model.create(vals) def write(self, id, title): vals = {\u0026#34;name\u0026#34;: title} self.Model.write(id, vals) def unlink(self, id): return self.Model.unlink(id) 注意这段代码和 Odoo 服务端代码极其相似。\n可使用LibraryAPI对象替换library_xmlrpc.py。可通过编辑library.py文件将from library_xmlrpc import LibraryAPI一行替换为from library_odoorpc import LibraryAPI将其用作RPC连接层。然后对library.py客户端应用进行测试，执行效果应该是和之前一样的。\n了解ERPpeek客户端 ERPpeek是一个多功能工具，既可以作为交互式命令行接口(CLI)也可以作为 Python库，它提供了比xmlrpc库更便捷的 API。它在PyPi索引中，可通过如下命令安装：\npip3 install erppeek ERPpeek不仅可用作 Python 库，它还可作为 CLI 来在服务器上执行管理操作。Odoo shell 命令在主机上提供了一个本地交互式会话功能，而erppeek库则为网络上的客户端提供了一个远程交互式会话。打开命令行，通过以下命令可查看能够使用的选项：\nerppeek --help 下面一起来看看一个示例会话：\n$ erppeek --server=\u0026#39;http://127.0.0.1:8069\u0026#39; -d odoo-dev -uadmin Usage (some commands): models(name) # List models matching pattern model(name) # Return a Model instance ... Password for \u0026#39;admin\u0026#39;: Logged in as \u0026#39;admin\u0026#39; odoo-dev \u0026gt;\u0026gt;\u0026gt; model(\u0026#39;res.users\u0026#39;).count() 3 odoo-dev \u0026gt;\u0026gt;\u0026gt; rec = model(\u0026#39;res.partner\u0026#39;).browse(14) odoo-dev \u0026gt;\u0026gt;\u0026gt; rec.name \u0026#39;Azure Interior\u0026#39; 如上所见，建立了服务端的连接，执行上下文引用了model() 方法来获得模型实例并对其进行操作。连接使用的erppeek.Client实例也可通过客户端变量来使用。 值得一提的是它可替代网页客户端来管理所安装的插件模块：\nclient.modules()列出可用或已安装模块 client.install()执行模块安装 client.upgrade()执行模块升级 client.uninstall()卸载模块 因此ERPpeek可作为 Odoo 服务端远程管理的很好的服务。有关ERPpeek的更多细节请见 GitHub。\n小结 本文的目标是学习外部 API 如何运作以及它们能做些什么。一开始我们通过一个简单的Python XML-RPC客户端来进行探讨，但外部 API 也可用于其它编程语言。事实上官方文档中包含了Java, PHP和Ruby的代码示例。\n然后我们学习了如何使用XML-RPC调用搜索、读取数据，以及如何调用其它方法。比如我们可以创建、更新和删除记录。\n接着我们介绍了OdooRPC库。它在RPC基础库(XML-RPC 或 JSON-RPC) 上提供了一层，用于提供类似服务端API的本地API。这降低了学习曲线，减少了编程失误并且让在服务端和客户端之间拷贝代码变得更容易。\n以上我们就完结了本文有关编程 API 和业务逻辑的学习。是时候深入视图和用户界面了。在下一篇文章中，我们进一步学习后台视图以及web客户端提供的开箱即用的用户体验。\n扩展阅读 以下参考资料可用于补充本文所学习的内容：\nOdoo web服务的官方文档中包含了Python以外编程语言的代码示例。 OdooRPC文档 ERPpeek文档 "
},
{
	"uri": "/odoo/10/",
	"title": "第十章 Odoo 12开发之后台视图 - 设计用户界面",
	"tags": [],
	"description": "",
	"content": "本文为最好用的免费ERP系统Odoo 12开发手册系列文章第十篇。\n本文将学习如何为用户创建图形化界面来与图书应用交互。我们将了解不同视图类型和小组件(widgets)之间的差别，以及如何使用它们来提供更优的用户体验。\n本文主要内容有：\n菜单项 窗口操作(Window Actions) 表单视图结构 字段 按钮和智能按钮 动态视图元素 列表视图 搜索视图 其它视图类型 开发准备 我们将继续使用library_checkout插件模块，它已经有了模型层，现在需要视图层来实现用户界面。本文中的代码基于第八章 Odoo 12开发之业务逻辑 - 业务流程的支持，相关代码请参见 GitHub 仓库，本章完成后代码也请参见 GitHub仓库。\n菜单项 用户界面的入口是菜单项，菜单项形成一个层级结构，最顶级项为应用，其下一级为每个应用的主菜单。还可以添加更深的子菜单。可操作菜单与窗口操作关联，它告诉客户端在点击了菜单项后应执行什么操作。\n菜单项存储在ir.ui.menu模型中，可通过Settings \u0026gt; Technical \u0026gt; User Interface \u0026gt; Menu Items菜单进行查看。\nlibrary_app模块为图书创建了一个顶级菜单，library_checkout插件模块添加了借阅和借阅阶段的菜单项。在library_checkout/views/library_menu.xml文件中，借阅的菜单项 XML 代码如下：\n\u0026lt;menuitem id=\u0026#34;menu_library_checkout\u0026#34; name=\u0026#34;Checkout\u0026#34; action=\u0026#34;action_library_checkout\u0026#34; parent=\u0026#34;library_app.menu_library\u0026#34; /\u0026gt; 这里有一个快捷元素，提供了一种定义菜单项的简写方式，比原生的元素要更为便捷。以上使用的属性有：\nname是展示在用户界面中的菜单项标题 action是点击菜单项时运行的窗口操作的XML ID parent是父级菜单项的XML ID。本例中父级项由其它模块创建，因此们使用了完整的XML ID, .进行引用。 还有以下可用属性：\nsequence设置一个数字来在展示菜单项时进行排序，如sequence=\u0026ldquo;10\u0026rdquo; groups是一个逗号分隔的可访问菜单项安全组的XML ID列表，如groups=\u0026ldquo;library_app.library_group_user, library_app.library_group_manager\u0026rdquo; web_icon是菜单项的图标，仅用于企业版的顶级菜单项，如web_icon=\u0026ldquo;library_app,static/description/icon.png\u0026rdquo; 窗口操作(Window Actions) 窗口操作给 GUI（图形化用户界面）客户端操作指令，通常用于菜单项或视图中的按钮。它告诉 GUI 所作用的模型以及要显示的视图。这些操作可以通过域过滤器过滤出可用记录，设置默认值以及从上下文属性中过滤。窗口操作存储在ir.actions.act_window模型中，可通过Settings \u0026gt; Technical \u0026gt; Actions \u0026gt; Window Actions菜单进行查看。\n在library_checkout/views/library_menu.xml文件中，我们可以找到借阅菜单项中使用的窗口操作，我们需要对其进行修改来启用本文中将添加的视图类型：\n\u0026lt;act_window id=\u0026#34;action_library_checkout\u0026#34; name=\u0026#34;Checkouts\u0026#34; res_model=\u0026#34;library.checkout\u0026#34; view_mode=\u0026#34;tree,form,activity,calendar,graph,pivot\u0026#34; /\u0026gt; 窗口操作通常像以上这样使用\u0026lt;act_window\u0026gt;快捷标签创建。这里修改\u0026quot;tree, form\u0026quot;为更大的列表\u0026quot;tree, form, activity, calendar, graph, pivot\u0026quot;。以上使用的窗口操作属性有：\nname是通过操作打开的视图中显示的标题 res_model是目标模型的标识符 view_mode是一个逗号分隔的可用视图类型列表。第一项为默认打开时的视图。 窗口操作还有一些其它属性：\ntarget：如果设置为 new,会在弹出的对话框窗口中打开视图，例如target=\u0026ldquo;new\u0026rdquo;。默认值是current，在主内容区行内打开视图。 context：为目标视图设置上下文信息，可设置默认值或启用过滤器等，例如context=\u0026quot;{\u0026lsquo;default_user_id\u0026rsquo;: uid}\u0026quot;。 domain：是对可在打开视图中浏览的记录强制过滤的域表达式，例如domain=\u0026quot;[(\u0026lsquo;user_id\u0026rsquo;, \u0026lsquo;=\u0026rsquo;, uid)]\u0026quot;。 limit：列表视图中每页显示的记录数，例如limit=\u0026ldquo;80\u0026rdquo;。 做了这些修改后，在选择Checkouts菜单项并浏览相应的列表视图时，右上角在列表和表单按钮后会增加一些按钮。但在我们创建对应视图前并不能使用，本文将一一学习。窗口操作还可在列表和表单视图的上方的 Action 菜单按钮中使用，它在 Fitlers 按钮旁。要使用这个，我们需要在元素中添加以下两个属性：\nsrc_model设置Action所作用的模型，例如src_model=\u0026ldquo;library.checkout\u0026rdquo; multi=\u0026ldquo;true\u0026quot;也启用列表视图中的Action，这样它可以作用于多个已选记录。否则仅在表单视图中可用，并且一次只能应用于一条记录。 补充：此时打开借阅表单会提示Insufficient fields for Calendar View!，在编写日历视图前最好选视图模式里删除 calendar 来进行效果查看\n表单视图结构 表单视图要么按照简单布局，要么按与纸质文档相似的业务文档布局。我们将学习如何设计这些业务文档布局以及使用可用的元素和组件。要进行这一学习，我们重新查看并扩展第八章 Odoo 12开发之业务逻辑 - 业务流程的支持中创建的图书借阅表单。\n业务文档视图 业务应用中记录的很多数据可以按纸质文档那样展示。表单视图可模仿这些纸质文档来提供更直观的用户界面。例如，在我们的应用中，可以把一次借阅看作填写一张纸，我们将编写一个遵循这一设计的表单视图。编辑library_checkout/views/chceckout_view.xml文件并修改表单视图记录来带有业务文档视图的基本框架：\n\u0026lt;record id=\u0026#34;view_form_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;form\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!--以下仅供查看效果使用--\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34; widget=\u0026#34;statusbar\u0026#34; clickable=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;sheet\u0026gt; ... \u0026lt;/sheet\u0026gt; \u0026lt;div class=\u0026#34;oe_chatter\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;message_follower_ids\u0026#34; widget=\u0026#34;mail_followers\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;activity_ids\u0026#34; widget=\u0026#34;mail_activity\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;message_ids\u0026#34; widget=\u0026#34;mail_thread\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 视图名称是可选的，在不写时会自动生成。为简便以上利用了这一点，在视图记录中省略了元素。可以看到业务文件视图通常使用三大区域：\nheader状态栏 sheet主内容 底部交流区，也称作chatter 底部的交流区使用了 mail 插件模块中提供的社交网络组件。可使用这些，我们的模型需要继承mail.thread和mail.activity.mixin，可参见第八章 Odoo 12开发之业务逻辑 - 业务流程的支持。\n头部 Header 头部header 通常用于文档所走过的生命周期或步骤，还包含相关的操作按钮。这些按钮是普通表单按钮，最重要的下一步可以高亮显示。\n头部按钮 编辑表单视图中的版块，我们添加一个按钮来更易于设置归还的借阅为完成(done)：\n\u0026lt;header\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34; invisible=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;button name=\u0026#34;button_done\u0026#34; string=\u0026#34;Return Books\u0026#34; attrs=\u0026#34;{\u0026#39;invisible\u0026#39;: [(\u0026#39;state\u0026#39;, \u0026#39;in\u0026#39;, [\u0026#39;new\u0026#39;, \u0026#39;done\u0026#39;])]}\u0026#34; class=\u0026#34;oe_highlight\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; 这里我们在头部添加了一个Return Books 按钮，在点击时调用button_done模型方法。注意可使用class=\u0026ldquo;oe_highlight\u0026quot;来对用户高亮显示操作。例如，在有几个可选按钮时，我们可以高亮显示主操作或下一步要执行的“更多”操作。attrs用于在 New 和 Done 状态时隐藏该按钮。实现这点的条件使用了不会在表单显示的 state 字段。要使条件生效，我们需要将使用的所有值在网页客户端中加载。我们不打算向终端用户显示 state 字段，因此使用 invisible 将其添加为不可见字段。\nℹ️domain 或 attrs 表达式中使用的字段必须在视图中加载，作用于它们的元素。如果字段不对用户可见，则必须以不可见字段元素对其进行加载。\n本例中我们使用的是 state 字段，相同的效果可通过 states 字段属性实现。虽然没有 attrs 属性灵活，但它更为精简。可将 attrs 一段替换为如下代码：\n\u0026lt;button name=\u0026#34;button_done\u0026#34; type=\u0026#34;object\u0026#34; string=\u0026#34;Returned\u0026#34; states=\u0026#34;open,cancel\u0026#34; class=\u0026#34;oe_highlight\u0026#34; /\u0026gt; attrs和states元素可见功能也可用于其它视图元素，如 field。本文后续会深入讨论。要让按钮可以运作，我们还需要实现调用的方法。在library_checkout/models/library_checkout.py file文件的借阅类里添加以下方法：\ndef button_done(self): Stage = self.env[\u0026#39;library.checkout.stage\u0026#39;] done_stage = Stage.search( [(\u0026#39;state\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;done\u0026#39;)], limit=1) for checkout in self: checkout.stage_id = done_stage return True 该方法首先查找 done 阶段的记录来使用，然后对 self 记录集中的每条记录，设置其 stage_id 值为完成阶段。\n阶段管道 下面我们为头部添加状态条组件，显示文档所在阶段。从代码层面说，是使用statusbar组件的stage_id字段的元素:\n\u0026lt;header\u0026gt; ... \u0026lt;field name=\u0026#34;stage_id\u0026#34; widget=\u0026#34;statusbar\u0026#34; clickable=\u0026#34;True\u0026#34; options=\u0026#34;{\u0026#39;fold_field\u0026#39;: \u0026#39;fold\u0026#39;}\u0026#34; /\u0026gt; \u0026lt;/header\u0026gt; 这会在头部添加一个阶段管道组件，它在表示文档当前所在生命周期点的字段上使用了statusbar组件。通常是一个状态选项字段或阶段many-to-one字段。这两类字段在 Odoo 核心模块中多次出现。clickable属性让用户可通过点击状态条来修改文档阶段。一般需要开启它，但有时又不需要，比如需要对工作进行更强的控制，并且要求用户仅使用可用的操作按钮来进入下一步。这种方法允许在切换阶段时进行指定验证。\n对阶段使用状态条组件时，我们可将很少使用的阶段隐藏(折叠)在 More 阶段组中。对应的阶段模型必须要有一个标记来配置需隐藏的阶段，通常命名为 fold。然后statusbar组件使用 options 属性来将这一字段名提供给fold_field选项，如以上代码所示。\n使用状态代替阶段 阶段是一个使用了模型来设置进度步骤的many-to-one字段。因此终端用户可对其动态配置来符合他们具体的业务流程以及支持看板的完美展示。我们将在图书借阅中使用到state。\n状态是一个包含了流程中相当稳定步骤的选择列表，如新建、处理中和完成。终端用户无法对其进行配置，因为它是静态的，更易于在业务逻辑中使用。视图字段对状态甚至还有特别的支持：状态字段属性仅在记录处理特定状态才对用户开放。\nℹ️阶段引入的时间要晚于状态。两者现在共存，在 Odoo 内核的趋势是使用阶段来替代状态。但如前所述，状态仍提供一些阶段所不具备的功能。\n可通过将阶段映射到状态中来同时获得两者的优势。在借阅模型中我们通过向借阅阶段中添加一个状态字段来实现，借阅文档通过一个关联字段来使用状态。使用状态代替阶段的模型中，我们也可以使用进度条管道。这种情况下要在进度条中列出状态，需要使用statusbar_visible属性来替换fold_field选项。具体代码如下：\n\u0026lt;field name=\u0026#34;state\u0026#34; widget=\u0026#34;statusbar\u0026#34; clickable=\u0026#34;True\u0026#34; statusbar_visible=\u0026#34;draft,open,done\u0026#34; /\u0026gt; 注意在我们实际的图书借阅项目中并不能这么使用，因为它是阶段驱动的，而非状态驱动。\n文档表单 表单画布是表单的主区域，这里放置实际的数据元素，设计上类似一张真实的纸质文档，通常 Odoo 中的这些记录也会被称为文档。通常文档表单结构包含如下区域：\n左上角文档标题和副标题 右上角按钮区 其它文档头部字段 底部笔记区，将附加字段组织成选项卡或页面 文档各行通常在笔记区的第一页，在表单之后，通常有一个 chatter 组件，带有文档订阅者、讨论消息和活动规划。下面逐一了解这些区域。\n补充：关于sheet的翻译Alan的理解sheet 仅为单(据)，但出于行文习惯一律使用表单\n标题和副标题 一个元素之外的字段不会自动带有渲染它们的标签。对于标题元素就是如此，因此该元素应用来对其进行渲染。虽然要花费额外的工作量，但这样的好处是对标签显示控制有更好的灵活性。常规 HTML，包括 CSS 样式元素，可用于美化标题。一般标题放在oe_title类中。以下为扩展后的元素，它包含标题以及一些额外字段如副标题：\n\u0026lt;sheet\u0026gt; \u0026lt;field name=\u0026#34;member_image\u0026#34; widget=\u0026#34;image\u0026#34; class=\u0026#34;oe_avatar\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;oe_title\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;member_id\u0026#34; class=\u0026#34;oe_edit_only\u0026#34; /\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;span class=\u0026#34;oe_read_only\u0026#34;\u0026gt;By \u0026lt;/span\u0026gt; \u0026lt;label for=\u0026#34;user_id\u0026#34; class=\u0026#34;oe_edit_only\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; class=\u0026#34;oe_inline\u0026#34; /\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!-- More elements will be added from here... --\u0026gt; \u0026lt;/sheet\u0026gt; 此处可以看到我们使用了div, span, h1和h3这些常规 HTML 元素。元素让我们可以控制字段标签在何时何处显示。for 属性标识了获取标签文件的字段。也可以使用 string 属性来为标签提供具体的文本。本例中还使用了class=\u0026ldquo;oe_edit_only\u0026quot;属性让其仅在编辑模式下可用。\n我们还可在表单左上角标题旁包含展示图像。它用在 parnter 或产品这类模型的表单视图中。作为示例，我们在标题区前添加了一个member_image字段，它使用图像组件widget=\u0026ldquo;image\u0026rdquo;，以及特定的 CSS 类class=\u0026ldquo;oe_avatar\u0026rdquo;。该字段尚未添加至模型中，下面我们就来添加，我们使用关联字段来将会员的图片显示在借阅文档中。编辑library_checkout/models/library_checkout.py文件并在借阅类中添加如下字段：\nmember_image = fields.Binary(related=\u0026#39;member_id.partner_id.image\u0026#39;) 表单内容分组 表单主内容区应通过标签来进行组织。标签在画布中插入了两列。默认在这些列中标签会在字段旁显示，因此又占据两列。字段加标签会占据 一行，下一个字段和标签又会另起一行，垂直排列。Odoo表单的常见布局是带标签的字段并排成两列。达到这一效果，我们只需要添加两个嵌入顶部的标签。\n继续修改表单视图，在主内容区标题后添加如下代码：\n\u0026lt;group name=\u0026#34;group_top\u0026#34;\u0026gt; \u0026lt;group name=\u0026#34;group_col1\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;checkout_date\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group name=\u0026#34;group_col2\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;closed_date\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; 为 group 标签分配name是一个好的编码实践，这样在其它模块中继承时会更易于对它们进行引用。还可设置 string 属性，一旦设置将作为该部分的标题来显示。\nℹ️Odoo 11中的修改 string 属性不能作为继承的锚点，因为在应用继承前会对其进行翻译。这时应使用 name 属性来代替它。\n在 group 内，元素会强制在新的一行，下一个元素会渲染到组的第一列。附加的版块标题可通过组内元素添加，如果带有 string 属性也会显示标题标签。要更好地控制元素布局，我们可以使用col和colspan属性。\ncol 属性可用于元素中来自定义包含的列数。如前所述，默认为两列，但可修改为任意其它数字。双数效果更佳，因为默认每个添加的字段会占据两列：字段标签和字段值。按照以下代码我们通过colspan=\u0026ldquo;2\u0026rdquo; 来在一个组内将4个字段放在两列中显示：\n\u0026lt;group name=\u0026#34;group_top\u0026#34;\u0026gt; \u0026lt;group name=\u0026#34;group_col1\u0026#34; col=\u0026#34;4\u0026#34; colspan=\u0026#34;2\u0026#34; string=\u0026#34;Group 1\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;checkout_date\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;closed_date\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group name=\u0026#34;group_col2\u0026#34; string=\u0026#34;Group2\u0026#34; /\u0026gt; \u0026lt;/group\u0026gt; 以上我们使用 string 属性为组添加了标题，来更清楚地看组所在位置。注意字段的顺序不同，它们先是从左到右，然后从上到下。元素可以使用 colspan 属性来设置它所占用的具体列数。默认和带标签的字段一样为两列。可以修改以上代码中 col 和 colspan 的值来在表单中查看不同的效果。比如 col=\u0026ldquo;6\u0026rdquo; colspan=\u0026ldquo;4\u0026quot;的效果是什么样的？可以试一试(见下图)。\n选项卡笔记本(Tabbed notebooks) 另一种组织内容的方式是 notebook 元素，一个包含多个称为页面(page)的选项卡分区的容器。它们可以让不常用的内容在不使用时隐藏起来，或者用于按话题组织大量字段。\n我们将在借阅表单中添加一个带有已借图书列表的notebook 元素。在前面的元素后可添加如下代码：\n\u0026lt;notebook\u0026gt; \u0026lt;page string=\u0026#34;Borrowed Books\u0026#34; name=\u0026#34;page_lines\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;line_ids\u0026#34; /\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;/notebook\u0026gt; 本例中笔记本仅有一个页面。添加更多，我们需在元素内添加更多的版块。页面画布默认不会渲染字段标签，如需显示，需像表单主画布那样将字段放在版块内。本例中我们在页面中添加了one-to-many字段line_ids，我们已经有了页面标题，因此不需要标签。page支持以下属性：\nstring：选项卡的标题（必填） attrs：不可见属性与表达式映射的字典 accesskey：HTML访问密钥 字段 视图字段有一些可用属性。大部分从模型定义中获取值，但可在视图中覆盖。以下来快速查看字段的可用属性：\nname标识字段数据库中名称 string用于想要覆盖模型中标签文本的标签文本 help是鼠标悬停在字段上显示的提示文本，它允许我们覆盖模型定义中提供的帮助文本 placeholder是在字段中显示的提示文本 widget让我们可以覆盖字段的默认组件，一会儿我们就会讲到可用的组件 options是一个带有组件附加数据的JSON数据结构，值随各组件的不同支持而不同 class是用于字段 HTML 渲染的CSS类 nolabel=\u0026ldquo;True\u0026quot;阻止自动字段标签的展示。仅对元素内的字段有作用，通常与元素一起使用。 invisible=\u0026ldquo;True\u0026quot;让字段不可见，但仍会从服务端获取数据并可在表单中使用 readonly=\u0026ldquo;True\u0026quot;让表单中该字段不可编辑 required=\u0026ldquo;True\u0026quot;让表单中该字段为必填 一些特定字段的属性如下：\npassword=\u0026ldquo;True\u0026quot;用于文本字段。显示为密码项，隐藏所输入文字 filename用于二进制字段，它是用于存储上传文件名的模型字段的名称 字段标签 元素可用于更好地控制字段标签的展示。一个使用示例是仅在表单为编辑模式时展示标签：\n\u0026lt;label for=\u0026#34;name\u0026#34; class=\u0026#34;oe_edit_only\u0026#34; /\u0026gt; 这么做时，如果字段在元素内部，我们通常还要对其设置nolabel=\u0026ldquo;True\u0026rdquo;。class=\u0026ldquo;oe_edit_only\u0026quot;可用于应用 CSS 样式，让标签仅在编辑模式下可见。\n字段组件 每个字段类型都会使用相应的默认组件在表单中显示。但还有一些替代组件可以使用。对于文本字段，有如下组件：\nemail用于让 email 文本成为可操作的\u0026quot;mail-to\u0026quot;地址 url用于将文本格式化为可点击的URL html用于将文本渲染为HTML内容；在编辑模式下，它显示为一个WYSIWYG(所见即所得)编辑器，可在不使用 HTML 代码的情况下格式化内容。 对于数字字段，有以下组件：\nhandle在列表视图中作为一个排序字段，显示一个句柄来让我们可以拖放进行自定义排序 float_time将一个浮点型字段格式化为带有小时和分钟的值 monetary将一个浮点型字段显示为货币金额。它与currency_id字段一起使用，还可以通过options=\u0026rdquo;{\u0026lsquo;currency_field\u0026rsquo;: \u0026lsquo;currency_id\u0026rsquo;}\u0026ldquo;来使用另一个字段名 progressbar将一个浮点值显示为进度条百分比，有助于将字段展示为完成率 percentage和percentpie组件可用于浮点型字段 对于关联和选择项字段，有以下附加组件：\nmany2many_tags将值显示为按钮标签列表 many2many_checkboxes将选项值显示为一个复选框列表 selection对many-to-one字段使用选择字段组件 radio以单选按钮显示选择字段选项 priority将选项字段显示为一个可点击星形列表。选择项目通常是数值。 state_selection将看板状态选择列表显示为信号灯。普通状态显示为灰色，完成显示为绿色，其它状态显示为红色。 pdf_viewer是一个二进制字段(在 Odoo 12中引入)。 ℹ️Odoo 11中的修改 state_selection在 Odoo11中引入来替换掉kanban_state_selection。后者被淘汰，但为保持向后兼容性，还支持使用。\n关联字段 在关联字段中，我们可让用户操作做一些额外控制。默认用户从这些字段中创建新记录（也称作“快速创建”）并打开关联记录表单。可通过options字段属性来关闭：\noptions=\u0026#34;{\u0026#39;no_open\u0026#39;: True, \u0026#39;no_create\u0026#39;: True}\u0026#34; context和domain也是字段属性并对于关联字段特别有用。context可定义关联字记录默认值，domain 可限制可选记录。常见的示例为让一个字段依赖其它字段值来产生选择项。domain可在模型中直接定义，但也可在视图中进行覆盖。\n在to-many字段中，我们还可使用 mode 属性来更改用于显示记录的视图类型。默认为 tree，但还有其它选项：form, kanban或graph。关联字段可定义行内指定视图来使用。这些视图在元素中的嵌套视图定义中声明。例如，在line_ids借阅中，我们可以为这些线路定义特定的列表和表单视图：\n\u0026lt;notebook\u0026gt; \u0026lt;page string=\u0026#34;Borrowed Books\u0026#34; name=\u0026#34;page_lines\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;line_ids\u0026#34;\u0026gt; \u0026lt;tree\u0026gt; \u0026lt;field name=\u0026#34;book_id\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;!--form\u0026gt; \u0026lt;field name=\u0026#34;book_id\u0026#34; /\u0026gt; \u0026lt;/form--\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/page\u0026gt; \u0026lt;/notebook\u0026gt; 线路列表将带有给定的定义。当我们与线路交互时，弹出一个表单对话框，在定义中包含该结构。\n**小贴士：**如果想要在列表视图的表单弹出窗口中直接编辑one-to-many路线，应使用或\n按钮 按钮支持这些属性：\nstring是按钮文本标签或使用图标时的 HTML alt 文本 type是执行操作的类型，有以下值： object用于调用 Python 方法 action用于运行窗口操作 name标识按所选类型要操作的具体的操作，要么是模型方法名，要么是要运行的窗口操作的数据库 ID。可使用%(xmlid)d方程式来将XML ID转换成加载视图时所需的数据库 ID。 args在类型为 object 时用于向方法传递额外的参数，须是在形成方法调用参数的记录 ID 之后所添加的纯静态 JSON 参数。 context在上下文中添加值，可在窗口操作或 Python 代码方法调用之后产生效果。 confirm在运行相关操作之前显示确认消息框，显示的内容是属性中分配的文本。special=\u0026ldquo;cancel\u0026quot;用于向导表单。 icon是按钮所显示的图标。可用的按钮来自Font Awesome图标集，版本为4.7.0，应通过对应的 CSS 类来指定，如icon=\u0026ldquo;fa-question\u0026rdquo;。更多信息可访问Font Awesome。 ℹ️Odoo 11中的修改 在 Odoo 11之前，按钮图标是来自GTK客户端库的图片，并且仅限于addons/web/static/src/img/icons中所保存图片。\nℹ️Odoo 11中的修改 在 Odoo 11中工作流引擎被淘汰并删除。此前的版本中，在支持工作流的地方，按钮可通过type=\u0026ldquo;workflow\u0026quot;来触发工作流引擎信号。这时name属性用于工作流的信号名。\n智能按钮 在右上角版块中带有智能按钮(smart button)也很常见。智能按钮显示为带有数据指示的矩形，在点击时可进入。\nOdoo 中使用的 UI样式是在放置智能按钮的地方带有一个隐藏框，按钮框通常是的第一个元素，在元素前(以及头像)，类似这样：\n\u0026lt;div name=\u0026#34;button_box\u0026#34; class=\u0026#34;oe_button_box\u0026#34;\u0026gt; \u0026lt;!-- Smart buttons will go here... --\u0026gt; \u0026lt;/div\u0026gt; 按钮的容器是一个带有oe_button_box类的 div 元素。在 Odoo 11.0以前，可能需要添加一个oe_right类来确保按钮框在表单中右对齐。在我们的应用中，我们将在按钮中显示图书会员待归还的其它借阅的总数，点击按钮会进入这些项的列表中。\n所以我们需要该会员处于 open 状态的借阅记录，排除掉当前借阅。对于按钮统计，我们应创建一个计算字段来在library_checkout/models/library_checkout.py文件的借阅类中进行计数：\nnum_other_checkouts = fields.Integer( compute=\u0026#39;_compute_num_other_checkouts\u0026#39;) def _compute_num_other_checkouts(self): for rec in self: domain = [ (\u0026#39;member_id\u0026#39;, \u0026#39;=\u0026#39;, rec.member_id.id), (\u0026#39;state\u0026#39;, \u0026#39;in\u0026#39;, [\u0026#39;open\u0026#39;]), (\u0026#39;id\u0026#39;, \u0026#39;!=\u0026#39;, rec.id)] rec.num_other_checkouts = self.search_count(domain) 下一步我们可以添加按钮框并在其中添加按钮。在版块的上方，替换上面的按钮框占位符为以下代码：\n\u0026lt;div name=\u0026#34;button_box\u0026#34; class=\u0026#34;oe_button_box\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;oe_stat_button\u0026#34; icon=\u0026#34;fa-tasks\u0026#34; help=\u0026#34;Other checkouts pending return.\u0026#34; type=\u0026#34;action\u0026#34; name=\u0026#34;%(action_other_checkouts_button)d\u0026#34; context=\u0026#34;{\u0026#39;default_member_id\u0026#39;: member_id}\u0026#34;\u0026gt; \u0026lt;field string=\u0026#34;To Return\u0026#34; name=\u0026#34;num_other_checkouts\u0026#34; widget=\u0026#34;statinfo\u0026#34; /\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 按钮元素本身是一个带有显示数据字段的容器。这些数据是使用statinfo特定组件的普通字段。该字段通常是作用于模型中定义的计算字段。除字段外，在按钮中还可以使用静态文本，如Other Checkouts。其它待借阅的数量展示在按钮定义中的num_other借阅字段中。\n智能按钮必须带有class=\u0026ldquo;oe_stat_button\u0026rdquo; CSS样式，并应使用 icon 属性来带有一个图标。它有一个type=\u0026ldquo;action\u0026rdquo;，表示点击按钮时将运行通过 name 属性标识的窗口操作。%(action_other_checkouts_button)d表达式返回要运行的操作的数据库 ID。\n在点击按钮时，我们要查看当前会员的其它借阅列表。这可通过action_other_checkouts_button窗口操作来实现。该操作会使用合适的域过滤器打开一个图书借阅列表。操作和相应的域过滤器在表单上下文之外处理，无法访问表单数据。因此按钮必须在上下文中设置当前member_id 来供窗口操作随后使用。使用的窗口操作必须在表单之前定义，因此我们应在 XML 文件根元素中的最上方添加以下代码：\n\u0026lt;act_window id=\u0026#34;action_other_checkouts_button\u0026#34; name=\u0026#34;Open Other Checkouts\u0026#34; res_model=\u0026#34;library.checkout\u0026#34; view_mode=\u0026#34;tree,form\u0026#34; domain=\u0026#34;[(\u0026#39;member_id\u0026#39;, \u0026#39;=\u0026#39;, default_member_id), (\u0026#39;state\u0026#39;, \u0026#39;in\u0026#39;, [\u0026#39;open\u0026#39;]), (\u0026#39;id\u0026#39;, \u0026#39;!=\u0026#39;, active_id)]\u0026#34;/\u0026gt; 注意我们在域过滤器中如何使用default_member_id上下文键。该键还会点击按钮链接创建新任务时为member_id字段设置默认值。域过滤器也需要当前 ID。这无需在上下文中明确设置，因为网页客户端会在active_id上下文键中自动进行设置。\n以下是可在智能按钮中添加的属性，供您参考：\nclass=\u0026ldquo;oe_stat_button\u0026quot;渲染的不是普通按钮而是一个矩形 icon从Font Awesome图标集中选择图标来使用。访问Font Awesome查看有哪些图标。 type和name是按钮类型以及触发的操作名。对于智能按钮，类型通常是 action，指定窗口操作，名称为所要执行操作的 ID。应传入真实数据库 ID，因此我们要使用方程式来将XML ID转换为数据库 ID：\u0026rdquo;%(actionxmlid)d\u0026rdquo;。这一操作应该会打开带有关联记录的视图。 string为按钮添加标签文本，这里没有使用因为所包含的字段中已经提供了文本。 context应用于为目标视图设置默认值，用于点击按钮后视图上新建的记录。 help在鼠标悬停在按钮上显示帮助提示信息 动态视图元素 视图元素还支持一些允许视图按字段值动态变更外观或行为的属性。我们可以有onchange 事件来在编辑表单数据时修改其它字段值，或在满足特定条件时让字段为必填或显示。\nonchange 事件 onchange机制允许我在某一特定字段变更时修改其它表单字段。例如一个商品字段的 onchange可以在商品被修改时设置价格字段为默认值。在老版本中，onchange 事件在视图级别定义，但8.0之后直接在模型层中定义，无需在视图上做任何特定标记。这通过使用@api.onchange(\u0026lsquo;field1\u0026rsquo;, \u0026lsquo;field2\u0026rsquo;, \u0026hellip;) 装饰器创建模型，来对一些字段绑定 onchange 逻辑。onchange 模型方法在第八章 Odoo 12开发之业务逻辑 - 业务流程的支持中详细讨论过，其中还有相关示例。\nonchange 机制还可以在用户输入时即时反馈进行计算字段的自动重算。继续使用商品来举例，如果在修改商品时价格字段变化了，它还会根据新的价格自动更新计算后的总金额字段。\n动态属性 一些属性允许我们根据记录的值来动态变更视图元素的显示。指定用户界面元素的可见性可通过如下属性很方便地控制：\ngroups可根据当前用户所属安全组来让元素可见。仅指定组的成员可看到该元素。它的值应为一个逗号分隔的XML ID列表 states可根据记录的状态字段来让元素可见。它的值为一个逗号分隔的状态列表，仅对带有state 字段的模型生效。 除这些以外，我们有一些灵活的方法来根据客户端动态生成的表达式设置元素可见性。它是一个特别属性 attrs，它的值为一个映射invisible属性值与表达式结果的字典。例如，要让closed_date字段在new和open状态时不可见，可使用如下代码：\n\u0026lt;field name=\u0026#34;closed_date\u0026#34; attrs=\u0026#34;{\u0026#39;invisible\u0026#39;:[(\u0026#39;state\u0026#39;, \u0026#39;in\u0026#39;, [\u0026#39;new\u0026#39;, \u0026#39;open\u0026#39;])]}\u0026#34;/\u0026gt; invisible不只在字段中可用，在任意元素中均可用。例如，它可用于 notebook 页面和group元素中。attrs属性也可为其它两个属性设置值：readonly和required。它们仅对数据字段有意义，通过二者来让字段可编辑或为必填。这让我们可以实现一些基础客户端逻辑，如根据其它字段值(如 state)来让字段设为必填。\n列表视图 学到这里可能不太需要介绍列表视图了，但它还一些有趣的额外属性可以讨论。下面我们修改library_checkout/views/checkout_view.xml文件来改进第八章 Odoo 12开发之业务逻辑 - 业务流程的支持中的版本：\n\u0026lt;record id=\u0026#34;view_tree_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Checkout Tree\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;tree decoration-muted=\u0026#34;state in [\u0026#39;done\u0026#39;, \u0026#39;cancel\u0026#39;]\u0026#34; decoration-bf=\u0026#34;state==\u0026#39;open\u0026#39;\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;state\u0026#34; invisible=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;request_date\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;checkout_date\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;stage_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;num_books\u0026#34; sum=\u0026#34;# Books\u0026#34; /\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 行文本颜色和字体可根据 Python 表达式计算结果来动态变化。这通过decoration–NAME属性带上计算字段属性的表达式来实现。NAME可以是bf或it，分别表示粗体和斜体，也可以是其它Bootstrap文本上下文颜色：danger, info, muted, primary, success或warning。Bootstrap文档中有相关显示示例。\nℹ️Odoo 9中的修改 decoration-NAME 属性在 Odoo 9中引入。在 Odoo 8中使用是 colors 和 fonts 属性。\n记住表达式中使用的字段必须要在字段中声明，这样网页客户端才知道要从服务端获取该列。如果不想对用户显示，应对其使用invisible=\u0026ldquo;1\u0026quot;属性。其它 tree 元素的相关属性有：\ndefault_order让我们可以覆盖模型中的默认排序，它的值和模型中定义的排序格式相同。 create, delete和edit，如果设为 false（字母小写），会禁用列表视图中的相应操作。 editable让记录在列表视图中可直接被编辑。可用值有 top 和 bottom，表示新记录添加的位置。 列表视图可包含字段和按钮，表单中的大部分属性对它们也有效。在列表视图中，数值字段可显示为对应列的汇总值。为字段添加一个累加属性(sum, avg, min或max)会为其分配汇总值的标签文本。我们在 num_books 字段中添加了一个示例：\n\u0026lt;field name=\u0026#34;num_books\u0026#34; sum=\u0026#34;# Books\u0026#34; / num_books字段计算每个借阅中的图书数量，它是一个计算字段，我们需要在模型进行添加：\nnum_books = fields.Integer(compute=\u0026#39;_compute_num_books\u0026#39;) @api.depends(\u0026#39;line_ids\u0026#39;) def _compute_num_books(self): for book in self: book.num_books = len(book.line_ids) 搜索视图 可用的搜索选项通过视图类型来定义。我们可以选择在搜索框中输入时自动搜索的字段。还可以预置过滤器，通过点击启用，以及在列表视图中的预置分组选项。图书借阅的搜索视图可设置如下：\n\u0026lt;record id=\u0026#34;view_filter_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;search\u0026gt; \u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;filter name=\u0026#34;filter_not_done\u0026#34; string=\u0026#34;To Return\u0026#34; domain=\u0026#34;[(\u0026#39;state\u0026#39;,\u0026#39;=\u0026#39;,\u0026#39;open\u0026#39;)]\u0026#34; /\u0026gt; \u0026lt;filter name=\u0026#34;filter_my_checkouts\u0026#34; string=\u0026#34;My Checkouts\u0026#34; domain=\u0026#34;[\u0026#39;user_id\u0026#39;, \u0026#39;=\u0026#39;, uid]\u0026#34; /\u0026gt; \u0026lt;filter name=\u0026#34;group_user\u0026#34; string=\u0026#34;By Member\u0026#34; context=\u0026#34;{\u0026#39;group_by\u0026#39;: \u0026#39;member_id\u0026#39;}\u0026#34; /\u0026gt; \u0026lt;/search\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 在视图定义中，可以看到两个member_id和user_id的简单元素，当用户在搜索框中输入时，推荐下拉框中会显示对这些字段的匹配。然后有两个使用域过滤器的预置过滤器。可在搜索框下方的 Filter 按钮下选择。第一个过滤器是 To Return 图书，也就还处于 open 状态的图书。第二个过滤器是当前图书管理员处理的图书，通过当前用户的 user_id （可在上下文的 uid 键中获取）过滤。\n这两个过滤器可以分别被启用并以 OR运算符连接。以元素分隔的整块过滤器以 AND 运算符连接。\n第三个过滤器仅设置 group by 上下文键，它让视图按照字段来对记录分组，本例中为 member_id 字段。\n字段元素可使用如下属性：\nname标识要使用的字段 string用作标签文本，它会替换默认值 operator用于修改默认的运算符(默认值：数值字段=，其它字段类型ilike) filter_domain设置搜索使用的特定域表达式，为 operator 属性提供一种灵活的替代方式。搜索文本在表达式中通过 self 引用。一个简单示例：filter_domain=\u0026rdquo;[(\u0026rsquo;name\u0026rsquo;, \u0026lsquo;ilike\u0026rsquo;, self)]\u0026rdquo; groups让对该字段的搜索仅向安全组内成员开发，它的值是一个逗号分隔的XML ID列表 过滤元素有以下可用属性：\nname用作后续继承/扩展或通过窗口操作启用的标识符。这不是必填项，但包含该属性是一个不错的编码习惯。 string是过滤器显示的标签文本，必填 domain是加入当前域的域表达式 context是加入当前上下文的上下文字典。通常使用group_id作为键，用于对记录分组的字段名作为值 groups让该字段的搜索仅对安全组列表(XML IDs)成员开放 其它视图类型 表单、列表和搜索视图是最常用的视图类型。但还有一些其它的视图类型可用于设计用户界面。对于前述三种基本视图类型我们已经很熟悉了，在第十一章 Odoo 12开发之看板视图和用户端 QWeb中将详细介绍看板视图，它会将记录可视化为卡片形式，甚至会按列组织为看板。下面我们将学习一些其它视图类型：\nactivity将计划活动显示为有组织的汇总 calendar基于所选日期字段以日历格式展示数据 diagram展示记录间的关系，当前不在 Odoo 中使用 以下两种视图类型用于显示累加数据：\ngraph用于图表展示 pivot用于交互的数据透视表 还有更多的视图类型，但仅在 Odoo 企业版中可用。因为我们整个系列的文章是基于社区版的，所以无法为这些视图提供示例：\ndashboard使用透视表和图表这类子视图展示累加数据 cohort用于显示在不同时期数据如何变化 gantt以甘特图显示日期计划信息，常用于项目管理 grid通过行和列网格组织数据进行展示 官方文档中提供了对所有视图和可用属性很好的参考，这里就不再重复。我们集中于提供一些基础使用示例，这样可以对这些视图入门。这样应该可以提供一个很好的基础，然后可进一步探索每个视图的所有功能。\n**小贴士：**可通过社区插件模块查看其它视图类型。OCA 管理的网页客户端插件请见 GitHub 仓库。例如，web_timeline模块提供了一个时间线视图类型，也可像甘特图那样展示计划信息，它是社区版的 gantt 视图类型。\n活动视图 活动视图类型是内置的计划活动汇总板，帮助用于可视化活动任务。由 mail 模块提供，因此需要先安装该模块才能使用这一视图类型。要使用这一类型，只需在窗口操作的 view_code 属性的视图列表中添加活动视图类型即可。实际的视图定义会自动生成，我们也可以手动进行添加，唯一的选项是修改 string 属性，但在UI 中并不使用。\n作为参考，活动视图的定义类似这样：\n\u0026lt;activity string=\u0026#34;Activities\u0026#34;/\u0026gt; 日历视图 从名称可以看出，该视图类型在日历中展示记录，可通过不同时间区间浏览：按月、按周或按日。以下是我们图书借阅的日历视图，根据请求日期在日历上显示各项：\n\u0026lt;record id=\u0026#34;view_calendar_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;calendar date_start=\u0026#34;request_date\u0026#34; color=\u0026#34;user_id\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;stage_id\u0026#34; /\u0026gt; \u0026lt;/calendar\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 补充：请记得在菜单xml文件中加回前文删除的 calendar 类型\n基础的日历属性有：\ndate_start是开始日期字段（必填） date_end是结束日期字段（可选） date_delay是天数字段，用于代替date_end all_day传入一个布尔字段名，用于标识全天活动。这类活动会忽略时长。 color用于为一组日历项添加颜色。每个不同值都会被分配一种颜色，它的所有项都会显示为相同颜色。 mode是日历视图的默认显示模块，可以是天、周或月。 ℹ️Odoo 11中的修改 dipsplay 日历属性在 Odoo 11中删除。此前的版本中，它用于自定义日历项标题文本的格式，例如display=\u0026quot;[name], Stage [stage_id]\u0026quot;。\n透视表视图 还可通过透视表查看数据，它是一个动态分析矩阵。为此我们可使用透视表视图。\nℹ️Odoo 9中的修改 透视表在 Odoo 8中就已存在，作为一个图表视图功能。在 Odoo 9中，它成为一个独立的视图类型。同时也增强了透视表功能、优化了透视表数据的获取。\n数据累加仅对数据库中存储的字段可用。我们将使用num_books字段来展示一些借书数量的统计。它是一个计算字段，还没有存储在数据库中。要在这些视图中使用，需要通过添加store=True属性先将其存储在数据库中：\nnum_books = fields.Integer( compute=\u0026#39;_compute_num_books\u0026#39;, store=True) 使用如下代码来为图书借阅添加数据透视表：\n\u0026lt;record id=\u0026#34;view_pivot_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;pivot\u0026gt; \u0026lt;field name=\u0026#34;stage_id\u0026#34; type=\u0026#34;col\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;request_date\u0026#34; interval=\u0026#34;week\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;num_books\u0026#34; type=\u0026#34;measure\u0026#34; /\u0026gt; \u0026lt;/pivot\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 图表和透视表视图应包含描述轴和度量的字段元素，两者的属性大多数都通用：\nname像其它视图一样标识图表中使用的字段 type是指如何使用字段，行分组(默认)、度量(measure)或列（仅针对透视表，用于列分组） interval用于日期字段，是对时间数据的分组间隔：按天、按周、按月、按季度或按年 图表视图 图表视图将数据累加展示为图表，可以使用柱状图、线状图和饼图。下面来为图书借阅添加图表视图：\n\u0026lt;record id=\u0026#34;view_graph_checkout\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;graph type=\u0026#34;bar\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;stage_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;num_books\u0026#34; type=\u0026#34;measure\u0026#34; /\u0026gt; \u0026lt;/graph\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 图表视图元素可带有一个type属性，值可为 bar(默认), pie或line。对于 bar，可使用额外的stacked=\u0026ldquo;True\u0026quot;属性来让柱状图叠放起来。图表使用两种类型字段：\ntype=\u0026ldquo;row\u0026quot;是默认值，设置累加值的条件 type=\u0026ldquo;measure\u0026quot;用于作为实际累加值的度量字段 图表和透视表视图应包含描述需使用的轴和度量的字段元素。大多数图表视图中的属性同样可在透视表视图中使用。\n总结 本文中我们学习了更多创建用户界面的 Odoo 视图。我们深入讲解了表单视图，然后一起概览了其它视图类型，包括列表视图和搜索视图。我们还学习了如何向视图元素添加动态行为。\n下一篇文章中，我们将学习本文中未涉及到的视图：看板视图以及它使用的模板语言 QWeb。\n☞☞☞第十一章 Odoo 12开发之看板视图和用户端 QWeb\n扩展阅读 以下本文中所讨论的话题的附加参考和补充材料：\nOdoo 官方文档 有关actions 有关视图 Font Awesome图标索引 "
},
{
	"uri": "/odoo/11/",
	"title": "第十一章 Odoo 12开发之看板视图和用户端 QWeb",
	"tags": [],
	"description": "",
	"content": "本文为最好用的免费ERP系统Odoo 12开发手册系列文章第十一篇。\nQWeb 是 Odoo 使用的模板引擎，它基于 XML 来生成 HTML 片断和页面。通过 QWeb可生成内容丰富的看板(Kankan)视图、报表和 CMS 网页。本文中我们将学习QWeb 语法以及如何使用 QWeb 来创建我们自己的看板视图和自定义报表。\n本文主要内容有：\n看板是什么？ 设计看板视图 QWeb 模板语言 看板视图的继承 添加自定义 CSS 和 JavaScript 开发准备 我们将继续使用第十章 Odoo 12开发之后台视图 - 设计用户界面完成的library_checkout插件模块。相应代码请见 GitHub仓库。本章完成后的代码也请参见GitHub仓库。\n了解看板 Kanban 是一个日语词汇，字面意思榜单，与精益制造和准时化生产相关联，由丰田工业工程师大野耐一(Taiichi Ohno)引入。最近看板的概念应用于更多领域，并且随着敏捷方法的施行在软件工业内流行起来。\n看板让我们能够可视化工作队列，它以列来进行组织，每列代表工作进程的一个阶段。工作项以放在看板对应列的卡片来表示。新的工作项从最左边的列开始，并开始向右移动直至最右边列，代表工作完成。\n看板的简单化或视觉效果让其对简单的业务流程有着优异的支持。一个基本的看板示例包含三列，如下图所示：待办、在办和完成。当然它可以扩展为你需要的其它指定流程：\n对许多业务用例，看板都是管理相应流程的更有效方式，与 Odoo 11之前的更重的工作流引擎形成鲜明对比。Odoo 在支持经典的列表和表单视图的同时还支持看板视图，这易于我们实施这种类型的视图。下面就让我们一起来学习如何使用看板视图。\n看板视图 现在我们要为借阅模型添加一个看板视图。每个借阅是一个卡片，看板将会被组织成阶段列。在前面的文章中，我们已经添加了stage_id阶段字段。\n此前在表单视图我们大部分时候使用 Odoo 独有的 XML 元素，比如和，有时也会使用 HTML 元素，如或，但用得较少。在看板视图中则恰恰相反，展示模板基于 HTML，仅支持两个 Odoo 独有的元素：和。\n最终呈现在网页客户端中的内容是由 QWeb 模板动态生成的。QWeb 引擎处理特殊的 XML 标签和属性来进行生成。这样可以很好地控制如何渲染内容，但也让视图设计更为复杂。看板视图设计灵活性很强，我们将尽力以直接易懂地方式介绍快速创建看板视图的知识。查看与所需相似的看板视图来获取创意然后创建自己的看板是一种不错的方法。\n我们将学习两种使用看板视图的方式。一种是卡片列表，它用于联系人、产品、雇员通讯录或应用等。联系人看板视图长这样：\n但这不是真正的看板，看板应是一个组织成不同列的卡片，当然看板视图也支持这种布局。可能过 CRM 或项目应用来查看示例。访问CRM \u0026gt; Sales \u0026gt; My Pipeline可得到如下结果：\n这两种布局的最大区别是卡片按列的组织方式。这通过 Group By 功能实现，与列表视图中相似。通常分组是通过stage字段实现。看板视图的一个非常有用的功能是可以在列之间拖放卡片，自动分配分组视图字段的对应值。从两个示例中的卡片我们可以看到一些分别。其实它们的设计非常灵活，设计看板卡片不只有一种方式。这两个示例为我们提供设计的一些基础。\n联系人卡片基本组成有左侧的图像，主区域的加粗标题和紧随其后的一系列值。CRM 管道卡片结构更为复杂些。卡片主区域也有一个标题以及相关信息紧随其后，还有 footer 区。在该区域中，可看到左侧有一个优先级组件，后面带有一个活动指示，在右侧是一个负责用户的头像。上图中看不到，在鼠标悬停在右上角时还会有一个选项菜单。这个菜单让我们可以修改卡片的颜色提示等。\n我们将使用这种更复杂的结构来作为借阅看板卡片的参照。\n设计看板视图 我们将改进一直以来开发的library_checkout模型，为图书借阅添加看板视图。为此我们使用一个新文件library_checkout/views/checkout_kanban_view.xml。需要在__manifest__.py文件的 data 键最下方添加这个文件。在library_checkout/views/library_menu.xml文件中，可以看到借阅菜单项使用的窗口操作。需要对其修改来启用本文中添加的视图类型：\n\u0026lt;act_window id=\u0026#34;action_library_checkout\u0026#34; name=\u0026#34;Checkouts\u0026#34; res_model=\u0026#34;library.checkout\u0026#34; view_mode=\u0026#34;kanban,tree,form,activity,calendar,graph,pivot\u0026#34; /\u0026gt; 这里我们修改了菜单操作来在view_mode列表的最前面添加了kanban，来让它成为默认的视图模式。然后我们来添加kanban视图记录。与其它视图基本相同，除了 arch 字段内，最外层 XML元素为。下一步创建实际使用的 XML 文件library_checkout/views/checkout_kanban_view.xml来放置这个惊艳的看板视图：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;library_checkout_kanban\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.checkout\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;kanban\u0026gt; \u0026lt;/kanban\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 在使用看板视图前，我们需要为图书借阅模型添加几个字段。\n优先级、看板状态和颜色 除阶段外，看板中还有一些常用和有用的字段：\npriority让用户组织他们的工作项，标记什么应优先处理 kanban_state标记是否应移向下一阶段或因某种原因原地不动。在模型定义层中两者都是选择项字段。在视图层，对它们有特别的组件用于表单和看板视图。 color用于存储看板卡片显示的颜色，并可通过看板视图中的颜色拾取器菜单设置 编辑library_checkout/models/library_checkout.py文件来在我们的模型中添加这些字段：\nclass Checkout(models.Model): ... priority = fields.Selection( [(\u0026#39;0\u0026#39;, \u0026#39;Low\u0026#39;), (\u0026#39;1\u0026#39;, \u0026#39;Normal\u0026#39;), (\u0026#39;2\u0026#39;, \u0026#39;High\u0026#39;)], \u0026#39;Priority\u0026#39;, default=\u0026#39;1\u0026#39;) kanban_state = fields.Selection( [(\u0026#39;normal\u0026#39;, \u0026#39;In Progress\u0026#39;), (\u0026#39;blocked\u0026#39;, \u0026#39;Blocked\u0026#39;), (\u0026#39;done\u0026#39;, \u0026#39;Ready for next stage\u0026#39;)], \u0026#39;Kanban State\u0026#39;, default=\u0026#39;normal\u0026#39;) 我们还应该在表单视图中添加这些字段，使用各自的特别组件。kanban_state字段就加在之前并在按钮框之后：。priority应添加在name 字段之前，包裹在元素中：。color字段一般不出现在表单视图中。\n既然借阅模型已有我们所需使用的所有字段，我们可以来写看板视图了。\n看板卡片元素 看板视图框架包含一个外层元素和以下基础结构：\n\u0026lt;kanban default_group_by=\u0026#34;stage_id\u0026#34; class=\u0026#34;o_kanban_small_column\u0026#34;\u0026gt; \u0026lt;!-- Fields --\u0026gt; \u0026lt;field name=\u0026#34;stage_id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;id\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;color\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;kanban_state\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;priority\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;message_partner_ids\u0026#34; /\u0026gt; \u0026lt;!-- Optional progress bar --\u0026gt; \u0026lt;progressbar field=\u0026#34;kanban_state\u0026#34; colors=\u0026#39;{\u0026#34;done\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;blocked\u0026#34;: \u0026#34;danger\u0026#34;}\u0026#39; /\u0026gt; \u0026lt;!-- Templates with HTML snippets to use --\u0026gt; \u0026lt;templates\u0026gt; \u0026lt;t t-name=\u0026#34;kanban-box\u0026#34;\u0026gt; \u0026lt;!-- HTML Qweb template --\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/kanban\u0026gt; 注意在元素中使用了default_group_by=\u0026ldquo;stage_id\u0026quot;属性，我们用它来让看板默认以 stage 分组，这也是看板通常的分组方式。在简单卡片列表的看板中，如联系人，我们不需要添加该属性，只需使用标签即可。元素支持以下属性：\ndefault_group_by设置默认列分组使用的字段 default_order设置看板项默认使用的排序 quick_create=\u0026ldquo;false\u0026quot;禁用了每列顶部的快速创建选项（大的加号符号），快速创建只需提供标题描述即可创建新项。false是 JavaScript 的语法，必须是小写字母。 class为渲染看板视图的根元素添加 CSS 类。相关类是_kanban_small_column，让列比默认的更加紧湊。其它类可由我们模块的 CSS 文件来进行提供。 group_create, group_edit, group_delete和quick_create_view可设置为 false 来禁用看板列上对应的操作。如group_create=\u0026ldquo;false\u0026quot;删除右侧添加新列的按钮。 on_create用于创建用户点击左上角 Create 按钮时弹出的自定义简单表单视图窗口。应为相应的表单视图添加.\u0026lt;xml_id\u0026gt;值。 然后我们的模板中使用了一组字段。确切地说，只有在 QWeb 表达式中明确使用的字段才需要在这里声明，用以保证从服务端抓取它们的数据。QWeb引擎在处理模板前，仅会在视图中查找 来从模型中获取数据。QWeb的属性通常使用不会被检测到的record.field引用方式。正因为如此，需在之前包含这些字段来让模板处理时有相应字段值可以使用。\nℹ️Odoo 11中的修改 引入了进度条组件。使用的时候在看板列的上方会出现一个颜色条，来提供该列各项的状态数据。在本文前面CRM Pipeline的示例图中可以查看。\n有如下属性：\nfield是对列中各项进行颜色分组的字段名 colors是一个字典，将分组字段值与以下三种颜色分别进行映射：danger (红色), warning (黄色)或success (绿色)。 sum_field是一个可选项，用于选取整列汇总的字段名。如未设置，会使用各项的计数值。 然后我们的元素包含一个或多个QWeb模板来生成要使用的 HTML 片断。必须要有一个名为kanban-box的模板，它渲染看板卡片。还可以添加其它模板，通常用于定义主模板中复用到的 HTML 片断。这些模板使用标准的 HTML 和 QWeb 模板语言。QWeb提供了一些特殊指令，用于处理动态生成最终展示的 HTML。\nℹ️Odoo 12中的修改 Odoo 现在使用 Twitter Bootstrap 4，此前版本中使用Bootstrap 3。这些样式在渲染 HTML 的地方通常都可使用，有关Bootstrap更多知识请见官方网站。\n下面就来详细了解看板视图中所使用的QWeb模板设计。\n看板卡片布局 看板卡片主内容区域在kanban-box模板内定义。这个内容区也可以有一个 footer 底部子容器。卡片右上角还可以添加按钮，点击后打开操作菜单的功能。对于footer区域，应在看板盒子模型底部使用并添加oe_kanban_bottom CSS 类。还可以通过oe_kanban_bottom_left和oe_kanban_bottom_right CSS 类进一步分割为左、右 footer 区。此外，可通过Bootstrap的pull-left和pull-right类在卡片的任意位置（包括oe_kanban_bottom底部区域）添加向左或向右对齐元素。\n以下是对看板卡片中QWeb模板的第一次迭代：\n\u0026lt;t t-name=\u0026#34;kanban-box\u0026#34;\u0026gt; \u0026lt;!-- Set the Kanban Card color --\u0026gt; \u0026lt;div t-attf-class=\u0026#34; oe_kanban_color_#{kanban_getcolor(record.color.raw_value)} oe_kanban_global_click\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;o_dropdown_kanban dropdown\u0026#34;\u0026gt; \u0026lt;!-- Top-right drop down menu here... --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;oe_kanban_body\u0026#34;\u0026gt; \u0026lt;!-- Content elements and fields go here... --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;oe_kanban_footer\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;oe_kanban_footer_left\u0026#34;\u0026gt; \u0026lt;!-- Left hand footer... --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;oe_kanban_footer_right\u0026#34;\u0026gt; \u0026lt;!-- Right hand footer... --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;oe_clear\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; 这就是看板卡片的整体结构。你可能注意到了在顶部元素中使用了color字段来动态设置卡片颜色。在后面的部分中我们会讲解t-attf QWeb指令的细节。现在来为主内容区域添加内容：\n\u0026lt;div class=\u0026#34;oe_kanban_body\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;strong\u0026gt; \u0026lt;a type=\u0026#34;open\u0026#34;\u0026gt;\u0026lt;field name=\u0026#34;member_id\u0026#34; /\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/strong\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;field name=\u0026#34;request_date\u0026#34; /\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 这个模板中大部分都是常规 HTML，但也有渲染字段值的元素和在常规表单视图按钮中使用的 type 属性，此处用在锚文本标签中。\n在左部 footer 中插入优先级组件：\n\u0026lt;div class=\u0026#34;o_kanban_record_bottom\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;oe_kanban_bottom_left\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;priority\u0026#34; widget=\u0026#34;priority\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;activity_ids\u0026#34; widget=\u0026#34;kanban_activity\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ... \u0026lt;/div\u0026gt; 这里像我们在表单视图中做的那样添加了priority字段。还添加了一个计划活动的字段，使用kanban_activity特殊组件来显示即将开始活动的指示。\n在右部footer中，放入看板状态组件和请求借阅的会员头像：\n\u0026lt;div class=\u0026#34;oe_kanban_bottom_right\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;kanban_state\u0026#34; widget=\u0026#34;kanban_state_selection\u0026#34; /\u0026gt; \u0026lt;img t-att-src=\u0026#34;kanban_image( \u0026#39;library.checkout\u0026#39;, \u0026#39;member_image\u0026#39;, record.id.raw_value)\u0026#34; t-att-title=\u0026#34;record.member_id.value\u0026#34; t-att-alt=\u0026#34;record.member_id.value\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; class=\u0026#34;oe_kanban_avatar\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; 补充：原文件使用的 CSS 类oe_kanban_footer，oe_kanban_footer_left和oe_kanban_footer_right经测试不会进行左右对齐，参照 CRM 进行了如上修改\n看板状态通过元素和kanban_state_selection组件来进行添加。用户头像使用 HTML 标签插入。图像内容使用QWeb t-att-命令动态生成，后面会详细讲解。这里使用了kanban_image()帮助函数来获取src属性的值。kanban_image() Javascript函数从 Odoo 模型中获取表单并在网页中渲染。有以下属性：\n获取图像的模型 包含图像的字段 获取的记录 ID 为看板卡片添加选项菜单 看板卡片可在右上角带有一个选项菜单。通常的操作有编辑或删除记录，但也可以为其添加和按钮调用的同样操作。还有一个设置卡片颜色的组件。以下是oe_kanban_content顶部添加的选项菜单的基础代码：\n\u0026lt;div class=\u0026#34;o_dropdown_kanban dropdown\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;dropdown-toggle btn\u0026#34; data-toggle=\u0026#34;dropdown\u0026#34; role=\u0026#34;button\u0026#34; aria-label=\u0026#34;Dropdown menu\u0026#34; title=\u0026#34;Dropdown menu\u0026#34; href=\u0026#34;#\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;fa fa-ellipsis-v\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;dropdown-menu\u0026#34; role=\u0026#34;menu\u0026#34;\u0026gt; \u0026lt;!-- Edit and Delete actions, if available: --\u0026gt; \u0026lt;t t-if=\u0026#34;widget.editable\u0026#34;\u0026gt; \u0026lt;a role=\u0026#34;menuitem\u0026#34; type=\u0026#34;edit\u0026#34; class=\u0026#34;dropdown-item\u0026#34;\u0026gt;Edit\u0026lt;/a\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-if=\u0026#34;widget.deletable\u0026#34;\u0026gt; \u0026lt;a role=\u0026#34;menuitem\u0026#34; type=\u0026#34;delete\u0026#34; class=\u0026#34;dropdown-item\u0026#34;\u0026gt;Delete\u0026lt;/a\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;!-- Color picker option --\u0026gt; \u0026lt;ul class=\u0026#34;oe_kanban_colorpicker\u0026#34; data-field=\u0026#34;color\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 下拉菜单基本上是由带有标签的 HTML 列表元素组成。Edit 和 Delete 这类选项需要满足指定条件下才会出现。这通过QWeb的t-if命令来实现。本文后续会详细讲解QWeb的命令。widget全局变量表示一个KanbanRecord() JS 对象，负责渲染当前看板卡片。有两个非常有用的属性：widget.editable和widget.deletable，让我们可以检查相应的操作是否可用。\n可以看到如何根据记录字段值来显示或隐藏选项，Set as Done仅在未设置is_done 字段时才会显示。最后一个选项添加颜色拾取器组件来使用 color 数据字段选择或修改卡片背景色。因此，除元素外，也可用于运行Odoo 操作。\n看板视图中的操作 在QWeb模板中，用于超链的标签可带有一个 type 属性。它设置链接执行的操作类型，这样链接和常规表单中的按钮可进行同样的操作。和表单视图一样，操作类型可以是action或object，并应带有一个 name 属性来标识所要执行的具体操作。此外，还有以下操作类型可以使用：\nopen打开相应的表单视图 edit在编辑模式下直接打开相应的表单视图 delete删除记录并从看板视图中删除该项 QWeb 模板语言 QWeb会查找模板中的特殊指令并替换为动态生成的 HTML。这些指令是 XML 元素属性，可以用在, 或等有效标签或元素中。有时我们要使用QWeb指令但不希望放在模板的 XML 元素中。对这种情况，可以使用能带有 QWeb 指令（如t-if或t-foreach）的特殊元素，该元组不会在最终产生的XML/HTML有任何输出。\nQWeb指令常使用运算的表达式来根据当前记录值生成不同的结果。有两种不同的QWeb实现：客户端JavaScript和服务端Python。报表和网页使用服务端QWeb的 Python 实现。看板视图使用客户端JavaScript实现。也就是说看板视图中的QWeb表达式应使用JavaScript语法书写，而不是 Python。\n在显示看板视图时，内部的步骤大致如下：\n获取模板的XML进行渲染 调用服务端read()方法来获取模板中所涉及的字段数据 定位kanban-boxs模板并使用QWeb解析它来输出最终的HTML片断 在浏览器显示(DOM)中注入 HTML 以上在技术上并不精确，仅是用于理解看板视图中如何运作的脑图。下面我们将学习QWeb表达式运行并探讨可用的QWeb指令，通过示例改进借阅看板卡片。\nQWeb JavaScript 运行上下文 许多QWeb指令使用表达式的运行来生成结果。在看板视图这类客户端的应用中，表达式应使用JavaScript书写。表达式在带有几个有用变量的上下文中进行运行。可用record 对象带有从服务端请求的字段来表示当前记录。字段值可通过raw_value或value属性来获取：\nraw_value是由服务端read()方法返回的值，因此在条件表达式中更适用 value根据用户设置来格式化，用于在用户界面中的显示。常用于date/datetime, float/monetary和关联字段。 QWeb运行上下文还可在JavaScript网页客户端中引用。要擅用这些需要对网页客户端结构有很好的理解，但这里我们不会进行深入介绍。要进行引用 ，QWeb表达式运行中有以下标识符可以使用：\nwidget是对当前KanbanRecord() 组件对象的引用 ，用于在看板卡片中渲染当前记录。它会暴露一些帮助函数供我们使用。 record是widget.record的简写形式，使用点号标记来提供对可用字段的访问。 read_only_mode表示当前视图是否为读模式（而非编辑模式）。它是widget.view.options.read_only_mode的简写形式。 instance是对全部网页客户端实例的一个引用 。 值得一提的是有些字符是不能在表达式中使用的，比如小于号(\u0026lt;) 。这是因为在 XML 标准中，这些字符具有特殊含义，不应在 XML 内容中使用。反向的\u0026gt;=是一个有效替代方式，但通常是使用以下替代符号来进行不等式运算：\nlt是小于 lte是小于等于 gt是大于 gte是大于等于 ℹ️前述的比较符号仅用于 Odoo，是引入来解决 XML 格式中的限制的。它们不是 XML 标准的一部分。\n字符串替换动态属性– t-attf 我们的看板卡片使用t-attf QWeb指令来为顶级元素动态设置一个类，这样卡片可根据 color 字段值来显示颜色。为此使用了t-attf- QWeb指令。t-attf-指令使用字符串替换动态生成标签属性。这让像 URL 地址或 CSS 类名这类较大字符串中的部分内容可动态生成。\n该指令查找表达式代码块进行运行并替换结果。它们通过{{和}} 或#{和}来进行分隔。代码块的内容可以是任意JavaScript表达式并使用QWeb表达式中的任意可用变量，如record和widget。本例中我们还使用了专门提供的kanban_color() JS 函数，用于映射索引值到类颜色名。\n作为一个更复杂的示例，我们使用这个指令来动态生成用户的颜色，红色字体表示优先级很高。下面替换看板卡片中的相应代码：\n\u0026lt;li t-attf-class=\u0026#34;oe_kanban_text_{{ record.priority.raw_value lt \u0026#39;2\u0026#39; ? \u0026#39;black\u0026#39; : \u0026#39;red\u0026#39;}}\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; 这将会根据借阅优先级的值生成class=\u0026ldquo;oe_kanban_text_red\u0026quot;或class=\u0026ldquo;oe_kanban_text_black\u0026rdquo;。请注意看板视图中是有oe_kanban_text_red这个 CSS 类的，但oe_kanban_text_black仅用于演示，实际并不存在。\nℹ️注意JavaScript表达式中使用的lt符号，是\u0026lt;的转义表达式，并不能在XML中使用。\n表达式动态属性 - t-att t-att- QWeb指令通过运行表达式动态生成属性值。我们的看板卡片中使用它来为标签动态生成属性，title 属性使用以下表达式动态渲染：\nt-att-title=\u0026#34;record.member_id.value\u0026#34; .value字段返回在屏幕上显示的值。对于many-to-one字段，这通常是相关记录的 name 值。对于用户则是用户名。运行之后在鼠标悬停于图像上时会显示相应的用户名。\n在表达式运行的结果值为假时，就不会渲染该属性。这对于特殊的 HTML 属性非常重要，比如 input 字段中的 checked，即便在没有属性值时也会有显示效果。\n循环 - t-foreach 通过循环遍历来重复同一 HTML 代码块。我们可使用它来添加记录 follower 的头像。让我们先来仅渲染记录的partner ID：\n\u0026lt;t t-foreach=\u0026#34;record.message_partner_ids.raw_value\u0026#34; t-as=\u0026#34;rec\u0026#34;\u0026gt; \u0026lt;t t-esc=\u0026#34;rec\u0026#34; /\u0026gt;; \u0026lt;/t\u0026gt; t-foreach指令接收一个JavaScript表达式，运行来遍历集合。在大多数情况下，这会是 一个to-many关联字段的名称。与t-as指令一同使用来设置用于引用遍历各项的名称。下面使用的t-esc指令运行所提供的表达式，本处仅为 rec 变量名，将其渲染为已转译的安全 HTML。\n在上例中，我们遍历了存储在message_partner_ids 字段中的 follower。因为在看板卡片上的空间有限，我们使用JS 的slice()函数来限定所显示的follower数量，如下所示：\nt-foreach=\u0026#34;record.message_partner_ids.raw_value.slice(0, 3)\u0026#34; rec变量存储每个遍历值，本例中为partner ID。这样我们可以将循环改写为：\n\u0026lt;t t-foreach=\u0026#34;record.message_partner_ids.raw_value.slice(0,3)\u0026#34; t-as=\u0026#34;rec\u0026#34;\u0026gt; \u0026lt;img t-att-src=\u0026#34;kanban_image(\u0026#39;res.partner\u0026#39;, \u0026#39;image_small\u0026#39;, rec)\u0026#34; class=\u0026#34;oe_avatar\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/t\u0026gt; 比如可将其添加在右侧 footer 的用户头像旁。还包含一些帮助变量，它们的名称以t_as 中定义的变量名为前缀。本例中使用了rec，因此可用的帮助变量如下：\nrec_index是迭代索引，从0开始 rec_size是集合中的元素数量 rec_first在迭代的第一个元素中为真 rec_last在迭代的最后一个元素中为真 rec_even在索引为偶数时为真 rec_odd在索引为奇数时为真 rec_parity根据当前索引为odd或even rec_all表示进行迭代的对象 rec_value在迭代{key:value} 字典时，存储value (rec存储键名) 例如可通过如下代码去除ID 列表最后逗号：\n\u0026lt;t t-foreach=\u0026#34;record.message_parter_ids.raw_value.slice(0, 3)\u0026#34; t-as=\u0026#34;rec\u0026#34;\u0026gt; \u0026lt;t t-esc=\u0026#34;rec\u0026#34; /\u0026gt; \u0026lt;t t-if=\u0026#34;!rec_last\u0026#34;\u0026gt;;\u0026lt;/t\u0026gt; \u0026lt;/t\u0026gt; 条件判断 - t-if 我们的看板视图在卡片选项菜单中使用了t-if指令来根据不同条件显示不同选项。t-if指令在客户端渲染看板视图时需传入在 JS 中运行的表达式。标签和其内容仅在条件运行值为true 时才会渲染。作为示例，仅在借出有值时显示图书借出数量，在request_date字段后加入如下代码：\n\u0026lt;t t-if=\u0026#34;record.num_books.raw_value gt 0\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;field name=\u0026#34;num_books\u0026#34; /\u0026gt; books\u0026lt;/li\u0026gt; \u0026lt;/t\u0026gt; 我们使用了元素，这样在条件为 false 时，元素不会有任何输出。在为 true 时，仅会渲染其所包含的元素来进行输出。注意条件表达式中使用gt符号来替代\u0026gt;以表示大于运算符。可通过t-elif和t-else来支持else if和else条件语句，使用示例如下：\n\u0026lt;t t-if=\u0026#34;record.num_books.raw_value == 0\u0026#34;\u0026gt; \u0026lt;li\u0026gt;No books.\u0026lt;/li\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-elif=\u0026#34;record.num_books.raw_value gt 9\u0026#34;\u0026gt; \u0026lt;li\u0026gt;A lot of books!\u0026lt;/li\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-else=\u0026#34;\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;field name=\u0026#34;num_books\u0026#34; /\u0026gt; books.\u0026lt;/li\u0026gt; \u0026lt;/t\u0026gt; Javascript表达式中，AND和OR的运算符分别为\u0026amp;\u0026amp;和 ||。但在 XML 中不支持\u0026amp;符号，我们可以使用 and 和 or 运算符来规避这一问题。\n渲染值 - t-esc和t-raw 我们使用了元素来渲染值，但也可以无需标签直接显示字段值。t-esc指令运行表达式并将其渲染为转义后的 HTML 值，如下所示：\n\u0026lt;t t-esc=\u0026#34;record.message_partner_ids.raw_value\u0026#34; /\u0026gt; 有些情况下，如果确定源数据是安全的，可以无需转义使用t-raw 来渲染原始值，如下例所示：\n\u0026lt;t t-raw=\u0026#34;record.message_partner_ids.raw_value\u0026#34; /\u0026gt; **小贴士：**出于安全考虑，应尽量避免使用t-raw。它应严格用于输出特别准备不包含用户数据的HTML 数据，或者是已明确对 HTML 特殊字符转义的用户数据。\n为变量设置值 - t-set 对于更复杂的逻辑，我们可以将表达式结果存储在变量中，在模板中随后使用。这通过t-set指令来实现，它设置变量名，紧接着使用t-value指令来添加表达式计算分配的值。作为示例，以下代码将优先级较高的和前面一节一样渲染为红色，但使用red_or_black 变量来作为 CSS 类使用的变量，如下所示：\n\u0026lt;t t-set=\u0026#34;red_or_black\u0026#34; t-value=\u0026#34;record.priority.raw_value gte \u0026#39;2\u0026#39; ? \u0026#39;oe_kanban_text_red\u0026#39; :\u0026#39;\u0026#39;\u0026#34; /\u0026gt; \u0026lt;li t-att-class=\u0026#34;red_or_black\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;/li\u0026gt; 变量中也可分配 HTML内容，示例如下：\n\u0026lt;t t-set=\u0026#34;calendar_sign\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-calendar\u0026#34; /\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;t t-raw=\u0026#34;calendar_sign\u0026#34; /\u0026gt; 调用和复用其它模板 - t-call QWeb模板可作为可复用的 HTML 片段插入到其它模板中。我们无需重复相同的 HTML 代码块，可以设计构成部分来组成更为复杂的用户界面视图，可复用的模板在标签中定义，通过顶级元素中 kanban-box 以外的 t-name值进行标识。这些模板可通过t-call来进行包含，在当前看板视图、相同模块的其它地方以及其它插件模块中均可。\nfollower头像列表可以通过可复用代码段来进行分离，下面通过子模板重写代码。首先应在 XML 文件中添加另一个模板，在元素内，节点之后，添加如下代码：\n\u0026lt;t t-name=\u0026#34;follower_avatars\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;t t-foreach=\u0026#34;record.message_partner_ids.raw_value.slice(0,3)\u0026#34; t-as=\u0026#34;rec\u0026#34;\u0026gt; \u0026lt;img t-att-src=\u0026#34;kanban_image(\u0026#39;res.partner\u0026#39;, \u0026#39;image_small\u0026#39;, rec)\u0026#34; class=\u0026#34;oe_avatar\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; 在kanban-box主模板调用它就简单明了了，将原来包含 for each 指令的元素修改为如下代码：\n\u0026lt;t t-call=\u0026#34;follower_avatars\u0026#34; /\u0026gt; 调用其它插件模块中定义的模板，和视图类似，我们需要使用完整的module.name标识符。比如，以上代码片断可使用library_checkout.follower_avatars完整标识符来进行引用 。调用的模板和调用者运行在同一上下文中，所以调用方中的变量名在处理调用模板时同样可用。\n一种更优雅的实现方式是向调用模板传递参数，这通过在 t-call 标签中设置变量来完成。这些仅在子模板上下文中运行和使用，在调用方上下文中并不存在。我们将使用这个方法来让调用方设置follower 头像的最大数，而不是在子模板中硬编码。首先，我们将原固定值3修改为一个变量 arg_max：\n\u0026lt;t t-name=\u0026#34;follower_avatars\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;t t-foreach=\u0026#34;record.message_partner_ids.raw_value.slice(0, arg_max)\u0026#34; t-as=\u0026#34;rec\u0026#34;\u0026gt; \u0026lt;img t-att-src=\u0026#34;kanban_image(\u0026#39;res.partner\u0026#39;, \u0026#39;image_small\u0026#39;, rec)\u0026#34; class=\u0026#34;oe_avatar\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; 然后像下面这样在执行子模板调用时定义该变量：\n\u0026lt;t t-call=\u0026#34;follower_avatars\u0026#34;\u0026gt; \u0026lt;t t-set=\u0026#34;arg_max\u0026#34; t-value=\u0026#34;3\u0026#34; /\u0026gt; \u0026lt;/t\u0026gt; t-call元素内的整个内容可通过0（数字零）这个魔法变量在子模板中使用。不使用参数变量，我们还可以定义代码片断并在子模板中通过使用。这对以模块化的方式创建布局、合并/嵌套 QWeb 模板尤为有用。\n字典和列表动态属性 我们已经学习最重要的那些QWeb指令，但还有一部分我们也应该了解。下面简短地进行讲解。\n前面我们看到t-att-NAME和t-attf-NAME样式的动态标签属性，此外还可以使用固定的t-att指令。它接收键值对字典或pair（两个元素的列表）。\n使用如下映射：\n\u0026lt;p t-att=\u0026#34;{\u0026#39;class\u0026#39;: \u0026#39;oe_bold\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Hello\u0026#39;}\u0026#34; /\u0026gt; 将生成如下结果：\n\u0026lt;p class=\u0026#34;oe_bold\u0026#34; name=\u0026#34;Hello\u0026#34; /\u0026gt; 使用如下 pair：\n\u0026lt;p t-att=\u0026#34;[\u0026#39;class\u0026#39;, \u0026#39;oe_bold\u0026#39;]\u0026#34; /\u0026gt; 将生成如下结果：\n\u0026lt;p class=\u0026#34;oe_bold\u0026#34; /\u0026gt; 看板视图的继承 看板视图和报表中使用的模板可通过视图相同的常规方法来进行继承，例如，使用XPath表达式，参见第四章 Odoo 12 开发之模块继承。\n常见的情况是使用元素作为选择器，然后在其前或后添加其它元素。对于看板视图，同一字段可声明多次，例如在模板前和模板内分别声明。这时，选择器将匹配第一个字段元素，不会将修改我们希望修改的模板内的字段。要规避这一问题，我们需使用XPath来确保匹配的是模板内的字段，例如：\n\u0026lt;record id=\u0026#34;res_partner_kanban_inherit\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Contact Kanban modification\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;res.partner\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;inherit_id\u0026#34; ref=\u0026#34;base.res_partner_kanban_view\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;xpath expr=\u0026#34;//t[@t-name=\u0026#39;kanban-box\u0026#39;]//field[@name=\u0026#39;display_name\u0026#39;]\u0026#34; position=\u0026#34;before\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Name:\u0026lt;/span\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 在上例中，XPath 查找元素内的元素。这条规则会排除掉版块之外的相同字段元素。对于更 复杂的XPath表达式，我们可以使用命令行工具来研究出正确的语法。你的 Linux 系统中可能已有安装了xmllint工具（sudo apt install libxml2-utils），它有一个\u0026ndash;xpath 选项可对 XML 文件执行查询。\n另一个输出更好看的选项是Debian/Ubuntu包中的libxml-xpath-perl，带有一个xpath 命令：\n$ sudo apt-get install libxml-xpath-perl $ xpath -e \u0026#34;//record[@id=\u0026#39;res_partner_kanban_view\u0026#39;]\u0026#34; -e \u0026#34;//field[@name=\u0026#39;display_name\u0026#39;]]\u0026#34; /path/to/myfile.xml 自定义 CSS 和 JavaScript 如前所见，看板视图大多数为 HTML 并重度使用了 CSS 类。我们介绍了标准产品中提供的一些常用 CSS 类，但要实现最佳效果，我们还可以为模块添加自己的 CSS。我们这里不会详细讲解 CSS 代码的写法，但相应地需要讲解如何为模块添加自己的 CSS (JavaScript)这些前端资源。Odoo 中后台的前端资源在assets_backend模块中声明。要在模块中添加前端资源，需要对模块进行继承。进行这一操作的 XML 文件通常放在views/ 模块子目录内。\n以下是在library_checkout模块中添加一个 CSS 和 JavaScript文件的示例，对应文件为library_checkout/views/checkout_kanban_assets.xml：\n\u0026lt;odoo\u0026gt; \u0026lt;template id=\u0026#34;assets_backend\u0026#34; inherit_id=\u0026#34;web.assets_backend\u0026#34; name=\u0026#34;Library Checkout Kanban Assets\u0026#34;\u0026gt; \u0026lt;xpath expr=\u0026#34;.\u0026#34; position=\u0026#34;inside\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/library_checkout/static/src/css/checkout_kanban.css\u0026#34; /\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/library_checkout/static/src/js/checkout_kanban.js\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; 和平常一样，需要在__manifest__.py描述文件中对其进引用，注意这些前端文件放在/static/src 子目录中，这不是强制要求，但是约定俗成如此。\n总结 我们学习了看板和如何创建看板视图来实现这些看板。我们还介绍了QWeb模板以及使用它来设计看板卡片。QWeb同时还是 CMS 网站的渲染引擎，因此它在 Odoo 工具集中的重要性越来越高。\n看板视图可通过其它视图中使用的相同XML语法来进行继承。看板的 XML 结构可能会更为复杂，我们经常需要使用XPath表达式来定义需继承的元素。\n最后，高级看板视图可以使用独有的 CSS 和 JavaScript 文件。可作为模块文件来进行添加，然后应在web.assets_backend QWeb模板中添加这些文件，以在客户端页面中包含。\n在下一篇文章中，我们将继续使用QWeb，但是是在服务端创建自定义报表 。\n☞☞☞第十二章 Odoo 12开发之报表和服务端 QWeb\n扩展阅读 以下参考材料是对本文所学习课题的补充：\nOdoo官方文档QWeb的介绍 Bootstrap样式文档 Font Awesome图标索引 "
},
{
	"uri": "/odoo/12/",
	"title": "第十二章 Odoo 12开发之报表和服务端 QWeb",
	"tags": [],
	"description": "",
	"content": "本文为最好用的免费ERP系统Odoo 12开发手册系列文章第十二篇。\n报表是业务应用非常有价值的功能，内置的 QWeb 引擎是报表的默认引擎。使用 QWeb 模板设计的报表可生成 HTML 文件并被转化成 PDF。也就是说我们可以很便捷地利用已学习的 QWeb 知识，应用到业务报表中。本文中我们将为图书馆应用添加一个报表，复习 QWeb生成报表的关键技巧。包括像汇总一类计算、翻译和纸张样式打印。\n本文主要内容有：\n安装wkhtmltopdf 创建业务报表 QWeb 报表模板 在报表中展示数据 渲染图片 报表汇总 定义纸质格式 在报表中启用语言翻译 使用自定义 SQL 建立报表 开发准备 我们将继续使用library_app插件模块进行学习，该模块在第三章 Odoo 12 开发之创建第一个 Odoo 应用中初次创建，然后在第五章 Odoo 12开发之导入、导出以及模块数据和第六章 Odoo 12开发之模型 - 结构化应用数据中进行了改进。相关代码请参见 GitHub 仓库。本文完成后代码也请参见GitHub 仓库。\n安装wkhtmltopdf 要正确地生成报表，应安装wkhtmltopdf工具的推荐版本，该工具的名称表示Webkit HTML to PDF。Odoo使用它来将渲染的 HTML 页面转化为 PDF 文档。有些版本的wkhtmltopdf库已知存在问题，比如不打印页面头部和底部，所以需挑选使用的版本。从Odoo 10开始，官方支持了0.12.5版本，这也是官方推荐的版本。\n**小贴士：**官方Odoo项目有一个 wiki 页面，保持了对于wkthtmltopdf使用的信息和推荐。可通过 GitHub 进行查看。\n不幸的是你的主机系统，不论是Debian/Ubuntu或其它系统，所提供的安装包版本都不太一致。所以我们应下载和安装对于当前操作系统和 CPU 类型的推荐版本包。下载链接请见 GitHub。\n首先应确保系统中所安装的不是错误的版本：\nwkhtmltopdf --version 如果上述命令打印的结果不是我们需要的版本，应对其进行卸载。在Debian/Ubuntu系统中，使用的命令如下：\nsudo apt-get remove --purge wkhtmltopdf 下一步我们需要下载适合我们系统的安装包并进行安装。通过GitHub下载链接进行查看。对于0.12.5，最新 Ubuntu 安装版本是针对Ubuntu 14.04 LTS稳定版，但对其后的Ubuntu系统应该同样生效。我们在最近发布的Ubuntu 64系统中进行安装，下载命令如下：\nwget \u0026#34;https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.5/wkhtmltox_0.12.5-1.bionic_amd64.deb\u0026#34; -O /tmp/wkhtml.deb 下一步应进行安装。安装本地deb文件并不会自动安装依赖，因此需要执行第二步来完成安装：\nsudo dpkg -i /tmp/wkhtml.deb 这时可能会显示缺少依赖的错误，以下命令可解决这一问题：\nsudo apt-get -f install 现在，我们可以检查wkhtmltopdf库是否正确安装并确认是否为所需版本：\n$ wkhtmltopdf --version wkhtmltopdf 0.12.5 (with patched qt) 此时Odoo服务的启动日志就不会再提示You need Wkhtmltopdf to print a pdf version of the report的信息了。\n创建业务报表 我们会继续使用前面文章所使用的library_app模块，进添加实现报表的文件。我们将创建的报表会长成这样\n报表文件应放在模块子文件夹/reports中。首先我们来添加一个reports/library_book_report.xml数据文件，不要忘记在__manifest__.py文件的 data 下导入该文件。先在reports/library_book_report.xml文件中声明一个新报表：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;report id=\u0026#34;action_library_book_report\u0026#34; string=\u0026#34;Library Books\u0026#34; model=\u0026#34;library.book\u0026#34; report_type=\u0026#34;qweb-pdf\u0026#34; name=\u0026#34;library_app.report_library_book_template\u0026#34; /\u0026gt; \u0026lt;/odoo\u0026gt; 标签是对向ir.actions.report.xml写入数据的简写形式，这个模型是客户操作的特殊类型。它的数据可通过Settings \u0026gt; Technical \u0026gt; Actions \u0026gt;Reports菜单进行查看。\n**小贴士：**在设计报表时，我们可能更倾向保留为report_type=\u0026ldquo;qweb-html\u0026quot;然后在完成时再修改为qweb-pdf文件。这样在QWeb模板中可更快速的生成报表并且更易于检查 HTML 结果。\n执行完模块升级（~/odoo-dev/odoo/-bin -d dev12 -u library_app）后，图书表单视图中会在顶部显示一个 Print 按钮（列表视图中也有），它在Actions按钮的左侧，其中包含添加的运行报表的选项(Library Books)。\n现在还无法生成报表，因为我们还没有进行定义。这是一个QWeb报表，因此需要用到QWeb模板。name 属性标识所使用的模板。与其它标识符引用不同，name 属性中需要添加模块前缀，我们必须使用完整的引用名称\u0026lt;module_name\u0026gt;.\u0026lt;identifier_name\u0026gt;。\nQWeb 报表模板 在下面的代码可以看出，这个报表遵循一个基本框架。仅需在reports/library_book_report.xml文件元素后添加如下代码：\n\u0026lt;template id=\u0026#34;report_library_book_template\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;web.html_container\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;web.external_layout\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;!-- Report header content --\u0026gt; \u0026lt;t t-foreach=\u0026#34;docs\u0026#34; t-as=\u0026#34;o\u0026#34;\u0026gt; \u0026lt;!-- Report row content --\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;!-- Report footer content --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; 这里最重要的元素是使用标准报表结构的t-call指令。web.html_container模板进行支持 HTML 文档的基本设置。web.external_layout模板使用相应公司的相关设置处理报表头部和底部。可将其替换为web.internal_layout模板，它将只使用一个基本的头部。\nℹ️ Odoo 11中的修改 对报表的支持布局从report 模块移到了 web 模块中。也就是说此前版本中使用report.external_layout或report.internal_layout的引用 ，在11.0中引用应修改为web.\u0026lt;\u0026hellip;\u0026gt;。\nexternal_layout模板可由用户自定义，Odoo 11引入了这一选项，在Settings \u0026gt; General Settings菜单中，然后相关内容在Business Documents \u0026gt; Document Template版块：\n这里我们可以点击Change Document Template来从几个可用的模板中选取，甚至是点击Edit Layout来自定义所选模板的 XML。这一个报表框架适用于列表式报表，即报表中每条记录显示为一行。报表头部通常显示标题，底部区域则显示汇总。\n另一种格式是文档报表，每条记录是单独一页，比如邮件。这种情况报表结构如下：\n\u0026lt;template id=\u0026#34;report_todo_task_template\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;web.html_container\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;web.external_layout\u0026#34;\u0026gt; \u0026lt;t t-foreach=\u0026#34;docs\u0026#34; t-as=\u0026#34;o\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;!-- Report content --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; 我们会创建一个列表式报表，所以还会使用此前的框架。现在我们已经有了基本框架。既然报表是QWeb模板，那么它也可以像其它视图那样进行继承。报表中使用的QWeb模板可使用常规视图继承使用的 XPath 表达式来进行继承。\n补充：此时点击打印会输出一个空白的 PDF 文件。\n在报表中展示数据 与看板视图不同，报表中的QWeb模板在服务端进行渲染，因此使用Python QWeb来实现。我们可以将其看作相同规格的两种实现，需要注意其中的一些区别。\n首先这里的QWeb表达式由 Python 语法运行，而非JavaScript。对于最简的表达式几乎没有区别，但更为复杂的运算则可能存在差别。表达式运行上下文也不同，对于报表可使用如下变量：\ndocs是要打印记录的可迭代集合 doc_ids是一个要打印记录的 ID 列表 doc_model指定记录的模型，如library.book time是对Python时间库的引用 user是运行报表的用户记录 res_company是当前用户的公司记录 可使用t-field来引用字段值，并可使用t-options来进行补充指定渲染字段内容的具体组件。\nℹ️Odoo 11中的修改 在此前的 Odoo 版本中，使用的是t-field-options属性，但在 Odoo 11中淘汰了该属性，改用t-options属性。\n例如，假设doc表示一条具体记录，代码如下：\n\u0026lt;t t-field=\u0026#34;doc.date_published\u0026#34; t-options=\u0026#34;{\u0026#39;widget\u0026#39;: \u0026#39;date\u0026#39;}\u0026#34; /\u0026gt; 现在我们可以开始设计报表的页面内容了。\n**小贴士：**不幸的是官方文档中并没有涉及QWeb支持的组件及其选项。所以当前对其做进一步的了解只能是通过阅读相应源码。可访问ir_qweb_fields.py，查找继承ir.qweb.field的类，get_available_options() 方法可有助了解支持的选项。\n报表内容由HTML书写，并且使用了Twitter Bootstrap 4来帮助设计报表布局。在网页开发中大量使用了Bootstrap，有关Bootstrap的完整指南请见官方网站。\n以下为渲染报表头部的 XML 代码，应放在中并替换掉现有的元素：\n\u0026lt;!-- Report header content --\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row bg-primary\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-3\u0026#34;\u0026gt;Title\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34;\u0026gt;Publisher\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34;\u0026gt;Date\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-3\u0026#34;\u0026gt;Publisher Address\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34;\u0026gt;Authors\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;t t-foreach=\u0026#34;docs\u0026#34; t-as=\u0026#34;o\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;!-- Report row content --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;!-- Report footer content --\u0026gt; \u0026lt;/div\u0026gt; 内容的布局使用了Twitter Bootstrap的HTML网格系统。总的来说Bootstrap使用12列的网格布局，此处网格在元素中。\nℹ️Odoo 12中的修改 现在Odoo使用Bootstrap 4，它对此前 Odoo 版本中使用的Bootstrap 3并没有保持向后兼容。对于从Bootstrap 3改为Bootstrap 4的小技巧，可参照 Odoo 中关于这一话题的 Wiki 页面。\n可使用来添加行。每行中还有多个单元格，分别占用不同列数，总计应为12列。每个单元格可通过 来进行定义，其中 N 表示占用列的数量。\n**小贴士：**Bootstrap 4 在其大部分构件中使用了 CSS 弹性盒子布局，已知wkhtmltopdf 对弹性盒子的功能并不都能很好的支持。因此如果有些地方效果不对，请尝试使用其它元素或方法，如 HTML 表格。\n此处我们为头部行添加了标题，然后t-foreach循环遍历每条记录并在各行中进行渲染。因为渲染由服务端完成，记录都是对象，我们可使用点号标记来从关联数据记录中访问字段。这也让关联字段的数据访问变得更为容易。注意这在客户端渲染的QWeb视图中是无法使用的，比如网页客户端的看板视图。\n以下是在元素中的记录行内容XML：\n\u0026lt;!-- Report row content --\u0026gt; \u0026lt;div class=\u0026#34;col-3\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;\u0026lt;span t-field=\u0026#34;o.name\u0026#34; /\u0026gt;\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;o.publisher_id\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;o.date_published\u0026#34; t-options=\u0026#34;{\u0026#39;widget\u0026#39;: \u0026#39;date\u0026#39;}\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-3\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;o.publisher_id\u0026#34; t-options=\u0026#39;{ \u0026#34;widget\u0026#34;: \u0026#34;contact\u0026#34;, \u0026#34;fields\u0026#34;: [\u0026#34;address\u0026#34;, \u0026#34;email\u0026#34;, \u0026#34;phone\u0026#34;, \u0026#34;website\u0026#34;], \u0026#34;no_marker\u0026#34;: true}\u0026#39;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34;\u0026gt; \u0026lt;!-- Render authors --\u0026gt; \u0026lt;/div\u0026gt; 可以看到字段可通过t-options属性添加额外的选项，内容为包含带有widget键的 JSON 字典。更为复杂的示例是contact组件，用于格式化地址。我们使用它来渲染出版商地址o.publisher_id。默认contact 组件显示地址时带有图像，类似电话图标。no_marker=\u0026ldquo;true\u0026quot;选项禁用了这一显示。\n补充：no_marker=\u0026ldquo;true\u0026quot;禁用的地址图标如上所示\n渲染图片 我们报表最后一列为一组带有头像的作者。我们将通过遍历来渲染出每个作者，并使用Bootstrap媒体对象：\n\u0026lt;!-- Render authors --\u0026gt; \u0026lt;ul class=\u0026#34;list-unstyled\u0026#34;\u0026gt; \u0026lt;t t-foreach=\u0026#34;o.author_ids\u0026#34; t-as=\u0026#34;author\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;media\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;author.image_small\u0026#34; t-options=\u0026#34;{\u0026#39;widget\u0026#39;: \u0026#39;image\u0026#39;}\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;media-body\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;mt-0\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;author.name\u0026#34; /\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/ul\u0026gt; 此处我们遍历了author_ids，使用字段图像组件对每个作者的头像进行了渲染，然后还有姓名。\n注：以上头像来自各位大神 Twitter 的真实头像\n报表汇总 报表中经常需要提供汇总。这可借由 Python 表达式来计算总额。在闭合标签之后，我们添加最后一行用于汇总：\n\u0026lt;!-- Report footer content --\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;col-3\u0026#34;\u0026gt; Count: \u0026lt;t t-esc=\u0026#34;len(docs)\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;col-3\u0026#34; /\u0026gt; \u0026lt;div class=\u0026#34;col-2\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; len() Python函数用于计算集合元素的数量。类似地，汇总也可以使用sum()来对一组值进行求和运算。例如，可使用如下列表推导式来进行总额运算：\n\u0026lt;t t-esc=\u0026#34;sum([x.price for x in docs])\u0026#34; /\u0026gt; 可以把这个列表推导式看作一个内嵌的循环。有时我们需要贯穿报表执行一些计算，如流动汇总（running total），汇总至当前记录。这可通过t-set 来定义累加变量在每一行进行更新来实现。为描述这一功能，我们来计算作者数的累加。首先在docs 记录集 t-foreach 循环前初始化变量：\n\u0026lt;!-- Running total: initialize variable --\u0026gt; \u0026lt;t t-set=\u0026#34;author_count\u0026#34; t-value=\u0026#34;0\u0026#34; /\u0026gt; 然后在循环内，将记录的作者数添加到变量中。我们这里显示在书名之后，并在每行打印出当前总数：\n\u0026lt;!-- Running total: increment and present --\u0026gt; \u0026lt;t t-set=\u0026#34;author_count\u0026#34; t-value=\u0026#34;author_count + len(o.author_ids)\u0026#34; /\u0026gt; (Accum. authors: \u0026lt;t t-esc=\u0026#34;author_count\u0026#34; /\u0026gt;) 定义纸张样式 到这里我们的报表的 HTML 显示没有问题了，但在打印的 PDF 页面中还不够美观。使用横向页面显示结果会更好，因此下面就来添加纸张样式。在报表 XML 文件的最上方添加如下代码：\n\u0026lt;record id=\u0026#34;paperformat_euro_landscape\u0026#34; model=\u0026#34;report.paperformat\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;European A4 Landscape\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;default\u0026#34; eval=\u0026#34;True\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;format\u0026#34;\u0026gt;A4\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;page_height\u0026#34;\u0026gt;0\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;page_width\u0026#34;\u0026gt;0\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;orientation\u0026#34;\u0026gt;Landscape\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;margin_top\u0026#34;\u0026gt;40\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;margin_bottom\u0026#34;\u0026gt;23\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;margin_left\u0026#34;\u0026gt;7\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;margin_right\u0026#34;\u0026gt;7\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;header_line\u0026#34; eval=\u0026#34;False\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;header_spacing\u0026#34;\u0026gt;35\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;dpi\u0026#34;\u0026gt;90\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; 这是对European A4格式的一个拷贝，这在data/report_paperformat_data.xml文件中定义的base 模块中，但这里将排列方向由纵向改为了横向。定义的纸张样式可通过后台Settings \u0026gt; Technical \u0026gt; Reporting \u0026gt; Paper Format菜单进行查看。\n现在就可在报表中使用它了。默认的纸张样式在公司设置中定义，但我们也可以为特定报表指定纸张样式。这通过在报表操作中的paperfomat属性来实现。下面来编辑打开报表使用的操作，添加这一属性：\n\u0026lt;report id=\u0026#34;action_library_book_report\u0026#34; ... paperformat=\u0026#34;paperformat_euro_landscape\u0026#34; /\u0026gt; 在报表中启用语言翻译 要在报表中启用翻译，需要使用带有t-lang属性的元素在模板中调用翻译方法。t-lang需传入一个语言代码来运行，如es或en_US。它需要可以找到所需使用语言的字段名。一种方式是使用当前用户的语言，为此，我们定义一个外层翻译报表来调用要翻译的报表，使用t-lang属性来设置语言来源：\n\u0026lt;report id=\u0026#34;action_library_book_report\u0026#34; ... name=\u0026#34;library_app.report_library_book_translated\u0026#34; paperformat=\u0026#34;paperformat_euro_landscape\u0026#34; /\u0026gt; \u0026lt;template id=\u0026#34;report_library_book_template\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;library_app.report_library_book_translated\u0026#34; t-lang=\u0026#34;user.lang\u0026#34; /\u0026gt; \u0026lt;/template\u0026gt; 本例中，每本书都使用了用户的语言user_id.lang来进行渲染。\n有些情况下，我们可能需要每条记录以指定语言进行渲染。比如在销售订单中，我们可能要各条记录按照对应合作方/客户的首选语言进行打印。假设我们需要每本书按照对应出版商的语言进行渲染，QWeb模板可以这么写：\n\u0026lt;template id=\u0026#34;report_library_book_translated\u0026#34;\u0026gt; \u0026lt;t t-foreach=\u0026#34;docs\u0026#34; t-as=\u0026#34;o\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;library_app.report_library_book_template\u0026#34; t-lang=\u0026#34;o.publisher_id.lang\u0026#34;\u0026gt; \u0026lt;t t-set=\u0026#34;docs\u0026#34; t-value=\u0026#34;o\u0026#34; /\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; 以上我们对记录进行了迭代，然后每条记录根据记录上的数据使用相应的语言进行报表模板的调用，本例为出版商的语言publisher_id.lang。\n补充：以上代码运行时每条记录都会带有一个头部，如需按列表显示还需将头部抽象到循环之外\n使用自定义 SQL 创建报表 前面我们所创建的报表都是基于常规记录集，但在有些情况下我们需要执行一些在QWeb模板中不易于处理的数据转换或累加。一种解决方法是写原生 SQL 查询来创建我们所需的数据集，将结果通过特殊的模型进行暴露，然后基于这一数据集来生成报表。\n我们创建reports/library_book_report.py文件来讲解这一情况，代码如下：\nfrom odoo import models, fields class BookReport(models.Model): _name = \u0026#39;library.book.report\u0026#39; _description = \u0026#39;Book Report\u0026#39; _auto = False name = fields.Char(\u0026#39;Title\u0026#39;) publisher_id = fields.Many2one(\u0026#39;res.partner\u0026#39;) date_published = fields.Date() def init(self): self.env.cr.execute(\u0026#34;\u0026#34;\u0026#34; CREATE OR REPLACE VIEW library_book_report AS (SELECT * FROM library_book WHERE active=True) \u0026#34;\u0026#34;\u0026#34;) 要加载以上文件，需要在模块的顶级__init__.py文件中添加from . import reports，并在reports/init.py文件中添加from . import library_book_report。\n_auto属性用于阻止数据表的自动创建。我们在模型的init()方法中添加了替代的 SQL。它会创建数据库视图，并提供报表所需数据。以上 SQL 查询非常简单，旨在说明我们为视图可以使用任意有效的 SQL查询，如对额外数据执行累加或计算。\n我们还需要声明模型字段来让 Odoo 知道如何正确处理每一条记录中的数据。同时不要忘记为新模型添加安全访问规则，否则将无法使用该模型。下面在security/ir.model.access.csv文件中添加下行：\naccess_library_book_report,access_library_book_report,model_library_book_report, library_group_user,1,0,0,0 还应注意这是一个全新的不同模型，与图书模型的访问规则并不相同。下一步基于该模型我们可以使用reports/library_book_sql_report.xml新增一个报表：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;report id=\u0026#34;action_library_book_sql_report\u0026#34; string=\u0026#34;Library Book SQL Report\u0026#34; model=\u0026#34;library.book.report\u0026#34; report_type=\u0026#34;qweb-html\u0026#34; name=\u0026#34;library_app.report_library_book_sql\u0026#34; /\u0026gt; \u0026lt;template id=\u0026#34;report_library_book_sql\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;web.html_container\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;web.external_layout\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;page\u0026#34;\u0026gt; \u0026lt;!-- Report page content --\u0026gt; \u0026lt;table class=\u0026#34;table table-striped\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Title\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Published\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Date\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;t t-foreach=\u0026#34;docs\u0026#34; t-as=\u0026#34;o\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td class=\u0026#34;col-xs-6\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;o.name\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;col-xs-3\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;o.publisher_id\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;td class=\u0026#34;col-xs-3\u0026#34;\u0026gt; \u0026lt;span t-field=\u0026#34;o.date_published\u0026#34; t-options=\u0026#34;{\u0026#39;widget\u0026#39;: \u0026#39;date\u0026#39;}\u0026#34; /\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; 对于更为复杂的情况，我们还会需要用户输入参数，这时可以使用不同的方案：向导。为此我们应创建一个临时模型来存储用户的报表参数。因为这是由代码生成的，所以我们可以使用所需的任意逻辑。\n强烈推荐学习已有的相似报表来获取灵感。一个不错的例子是Leaves菜单选项下的Leaves by Department，相应的临时模型定义可以参见addons/hr_holidays/wizard/hr_holidays_summary_employees.py。\n补充：原书未对这一部分进行验证，Alan 下面通过添加菜单项的方式来进行验证，还有其它方式，欢迎读者留言讨论\n首先在views/library_menu.xml文件中添加如下内容：\n\u0026lt;act_window id=\u0026#34;action_library_book_report\u0026#34; name=\u0026#34;Book Report\u0026#34; res_model=\u0026#34;library.book.report\u0026#34; view_mode=\u0026#34;tree,form\u0026#34; /\u0026gt; \u0026lt;menuitem id=\u0026#34;menu_library_book_report\u0026#34; name=\u0026#34;Book Report\u0026#34; parent=\u0026#34;menu_library\u0026#34; action=\u0026#34;action_library_book_report\u0026#34; /\u0026gt; 在__manifest__.py 文件中引入前述的 XML 文件后更新模块\n总结 前面一篇文章中，我们学习了QWeb以及如何使用它来设计看板视图。本文中我们学习了QWeb报表引擎，以及使用QWeb模板语言创建报表最为重要的一些技术。\n下一篇文章中，我们将继续使用QWeb，这次是创建网页。我们将学习书写网页控制器，为我们的网页提供更丰富的功能。\n☞☞☞第十三章 Odoo 12开发之创建网站前端功能\n扩展阅读 本文所学习课题的补充参考材料有：\nOdoo官方文档对应专区： 报表 QWeb语言 Bootstrap样式文档 "
},
{
	"uri": "/odoo/13/",
	"title": "第十三章 Odoo 12开发之创建网站前端功能",
	"tags": [],
	"description": "",
	"content": "本文为最好用的免费ERP系统Odoo 12开发手册系列文章第十三篇。\nOdoo 起初是一个后台系统，但很快就有了前端界面的需求。早期基于后台界面的门户界面不够灵活并且对移动端不友好。为解决这一问题，Odoo 引入了新的网站功能，为系统添加了 CMS(Content Management System)内容管理系统。这使得我们无需集成第三方 CMS 便可创建美观又高效的前端。本文中我们将学习如何利用 Odoo 自带的网站功能开发面向前端的插件模块。\n本文主要内容有：\n学习项目 - 自助图书馆 第一个网页 创建网站 开发准备 我将用第十一章 Odoo 12开发之看板视图和用户端 QWeb中最后编辑的library_checkout插件模块，代码请见GitHub 仓库。本文完成后的代码也请参见GitHub 仓库。\n学习项目 - 自助图书馆 本文中我们将为图书会员添加一个自助服务功能。可供会员分别登录账号来访问他们的借阅请求列表。这样我们就可以学习网站开发的基本技术：创建动态页面、在页面间传递参数、创建表单以及处理表单数据验证。对这些新的图书网站功能，我们要新建一个插件模块library_website。\n大家应该已经轻车熟路了，首先创建插件的声明文件ibrary_website/manifest.py，代码如下：\n{ \u0026#39;name\u0026#39;: \u0026#39;Library Website\u0026#39;, \u0026#39;description\u0026#39;: \u0026#39;Create and check book checkout requests.\u0026#39;, \u0026#39;author\u0026#39;: \u0026#39;Alan Hou\u0026#39;, \u0026#39;depends\u0026#39;: [ \u0026#39;library_checkout\u0026#39; ], \u0026#39;data\u0026#39;: [ \u0026#39;security/ir.model.access.csv\u0026#39;, \u0026#39;security/library_security.xml\u0026#39;, \u0026#39;views/library_member.xml\u0026#39;, ], } 网站功能将会依赖于library_checkout。我们并没有添加对website核心插件模块的依赖。website插件为创建完整功能的网站提供了有用的框架，但现在我们仅探讨核心框架自带的基础网站功能，尚无需使用website。我们想要图书会员通过登录信息在图书网站上访问自己的借阅请求。为此需要在图书会员模型中添加一个user_id字段，需要分别在模型和视图中添加，下面就开始进行网站的创建：\n1、添加library_website/models/library_member.py文件\nfrom odoo import fields, models class Member(models.Model): _inherit = \u0026#39;library.member\u0026#39; user_id = fields.Many2one(\u0026#39;res.users\u0026#39;) 2、添加library_website/models/init.py文件：\nfrom . import library_member 3、添加library_website/init.py文件：\nfrom . import models 4、添加library_website/views/library_member.xml文件：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;record id=\u0026#34;view_form_member\u0026#34; model=\u0026#34;ir.ui.view\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Member Form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model\u0026#34;\u0026gt;library.member\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;inherit_id\u0026#34; ref=\u0026#34;library_member.view_form_member\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;arch\u0026#34; type=\u0026#34;xml\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;card_number\u0026#34; position=\u0026#34;after\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;user_id\u0026#34; /\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt; 访问这些网页的都是门户用户，无需访问后台菜单。我们需要为这个用户组设置安全访问权限，否则会在使用图书网站功能时报权限错误。\n5、添加library_website/security/ir.model.access.csv文件，添加对图书模型的读权限：\nid,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink access_book_portal,Book Portal Access,library_app.model_library_book,base.group_ portal,1,0,0,0 access_member_portal,Member Portal Access,library_member.model_library_member,ba se.group_portal,1,0,0,0 access_checkout_portal,Checkout Portal Access,library_checkout.model_library_che ckout,base.group_portal,1,0,0,0 6、在library_website/security/library_security.xml文件中添加记录规则来限制门户用户所能访问的记录：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;data noupdate=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;record id=\u0026#34;member_portal_rule\u0026#34; model=\u0026#34;ir.rule\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Member Portal Access\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model_id\u0026#34; ref=\u0026#34;library_member.model_library_member\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;domain_force\u0026#34;\u0026gt; [(\u0026#39;user_id\u0026#39;, \u0026#39;=\u0026#39;, user.id)] \u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;groups\u0026#34; eval=\u0026#34;[(4,ref(\u0026#39;base.group_portal\u0026#39;))]\u0026#34; /\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;record id=\u0026#34;checkout_portal_rule\u0026#34; model=\u0026#34;ir.rule\u0026#34;\u0026gt; \u0026lt;field name=\u0026#34;name\u0026#34;\u0026gt;Library Checkout Portal Access\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;model_id\u0026#34; ref=\u0026#34;library_checkout.model_library_checkout\u0026#34; /\u0026gt; \u0026lt;field name=\u0026#34;domain_force\u0026#34;\u0026gt; [(\u0026#39;member_id.user_id\u0026#39;, \u0026#39;=\u0026#39;, user.id)] \u0026lt;/field\u0026gt; \u0026lt;field name=\u0026#34;groups\u0026#34; eval=\u0026#34;[(4,ref(\u0026#39;base.group_portal\u0026#39;))]\u0026#34; /\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt; base.group_portal是门户用户组的标识符。在创建门户用户时，应设置他们的用户类型为 Portal，而不是Internal User。这会让他们属于门户用户组并继承我们上面定义的访问权限：\n补充：以上内容需开启开发者模式才可见\n一旦为图书会员创建了一个门户用户，就应在我们会员表单中的用户字段中使用。该登录信息将可以访问相应会员的借阅请求。\n**小贴士：**在模型中使用 ACL 和记录规则来实现安全权限比使用控制器的逻辑要更为安全。这是因为攻击者有可能跳过网页控制器直接使用RPC 来访问模型 API 。\n了解了这些，我们就可以开始实现图书网站的功能了。但首先我们来使用简单的Hello World网页简短地介绍下基本网站概念。\n第一个网页 要开始了解 Odoo 网页开发的基础，我们将先实现一个Hello World网页来展示基本概念和技术。很有想象空间，是不是？\n要创建第一个网页，我们需要一个控制器对象。首先来添加controllers/hello.py文件：\n1、在library_website/init.py文件中添加如下行：\nfrom . import controllers 2、在library_website/controllers/init.py文件中添加如下行：\nfrom . import hello 3、添加实际的控制器文件 library_website/controllers/hello.py，代码如下：\nfrom odoo import http class Hello(http.Controller): @http.route(\u0026#39;/helloworld\u0026#39;, auth=\u0026#34;public\u0026#34;) def helloworld(self): return(\u0026#39;\u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt;\u0026#39;) odoo.http模块提供 Odoo 网页相关的功能。我们用于渲染页面的控制器，应该是一个继承了odoo.http.Controller类的对象。实际使用的名称并不是太重要，这里选择了 Hello()，一个常用的选择是 Main()。\n在控制器类中使用了匹配 URL 路由的方法。这些路由用于做一些处理并返回结果，通常是返回用户网页浏览器的 HTML 页面。odoo.http.route装饰器用于为 URL 路由绑定方法，本例中使用的是/helloworld 路由。\n安装library_website模块（~/odoo-dev/odoo/odoo-bin -d dev12 -i library_website）就可以在浏览器中打开http://xxx:8069/helloworld，我们应该就可以看到Hello World问候语了。\n本例中方法执行的处理非常简单，它返回一个带有 HTML 标记的文本字符串，Hello World。\nℹ️使用这里的简单 URL 访问按制器，如果同一 Odoo 实例有多个数据库时，在没有指定目标数据库的情况下将会失败。这可通过在启动配置中设置-d或\u0026ndash;db-filter来解决，参见第二章 Odoo 12开发之开发环境准备。\n你可能注意到在路由装饰中使用了auth=\u0026lsquo;public\u0026rsquo;参数，对于无需登录的用户开放的页面就需要使用它。如果删除该参数，仅有登录用户方可浏览此页面。如果没有活跃会话(session)则会进入登录页面。\n**小贴士：**auth=\u0026lsquo;public\u0026rsquo;参数实际表示如果访客未登录则使用public特殊用户运行网页控制器。如果登录了，则使用登录用户来代替public。\n使用 QWeb 模板的 Hello World 使用 Python 字符串来创建 HTML 很快就会觉得乏味。QWeb可用来增添色彩，下面就使用模板来写一个改进版的Hello World网页。QWeb模板通过 XML 数据文件添加，技术层面上它是与表单、列表视图类似的一种视图类型。它们甚至存储在同一个技术模型ir.ui.view中。\n老规矩，需要在声明文件中添加声明来加载文件，编辑library_website/manifest.py文件并添加内容如下：\n\u0026#39;data\u0026#39;: [ ... \u0026#39;views/helloworld_template.xml\u0026#39;, ], 然后添加实际的数据文件views/helloworld_template.xml，内容如下：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;template id=\u0026#34;helloworld\u0026#34; name=\u0026#34;Hello World Template\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello again World!\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; 实际上是一种简写形式，它声明将数据以type=\u0026ldquo;qweb\u0026quot;类型加载到ir.ui.view模型中。现在，我们需要修改控制器方法来使用这个模板：\nfrom odoo import http from odoo.http import request class Hello(http.Controller): @http.route(\u0026#39;/helloworld\u0026#39;, auth=\u0026#34;public\u0026#34;) def helloworld(self, **kwargs): return request.render(\u0026#39;library_website.helloworld\u0026#39;) 模板的渲染是通过render()函数的 request 对象来实现的。\n**小贴士：注意我们添加了kwargs方法参数。使用该参数，HTTP 请求中的任意附加参数，如GET 或 POST 请求参数，可通过 kwargs 字典捕获。这会让我们的方法更加健壮，因为即便添加了未预期的参数也不会产生错误。\nHelloCMS! 下面我们来增加点趣味性，创建我们自己的简单 CMS。为此我们可以通过 URL在路由中使用模板名（一个页面），然后对其进行渲染。然后就可以动态创建网页，通过我们的 CMS 来提供服务。实现方法很简单：\n@http.route(\u0026#39;/hellocms/\u0026lt;page\u0026gt;\u0026#39;, auth=\u0026#39;public\u0026#39;) def hello(self, page, **kwargs): return http.request.render(page) 以上page 参数应匹配一个模板的外部ID，如果在浏览器中打开http://xxx:8069/hellocms/library_website.helloworld，应该又可以看到熟悉的Hello World 页面了。实际上内置的website模块提供了CMS功能，在 /page路径(endpoint)下还包含更为健壮的实现。\nℹ️在werkzeug的行话中，endpoint是路由的别名，由其静态部分（不含占位符）来表示。比如，CMS 示例中的 endpoint为/hellocms。\n大多数情况下，我们要将页面集成到 Odoo 网站中，因此接下来的示例将使用website插件模块。\n创建网站 前面的示例并未集成到 Odoo 网站中，并有页面 footer 和网站菜单。Odoo 的website插件模板为方便大家提供这些功能。\n要使用网站功能，我们需要在工作实例中安装website插件模块。应当在library_website插件模块中添加这一依赖，修改__manifest__.py的 depends 内容如下：\n\u0026#39;depends\u0026#39;: [ \u0026#39;library_checkout\u0026#39;, \u0026#39;website\u0026#39;, ], 要使用网站功能，我们需要对控制器和 QWeb模板进行一些修改。控制器中可在路由上添加一个额外的website=True参数：\n@http.route(\u0026#39;/helloworld\u0026#39;, auth=\u0026#34;public\u0026#34;, website=True) def helloworld(self, **kwargs): return request.render(\u0026#39;library_website.helloworld\u0026#39;) 集成website模块并非严格要求website=True参数，不添加它也可以在模板视图中添加网站布局。但是通过添加可以让我们在网页控制器中使用一些功能：\n路由会自动变成支持多语言并且会从网站安装的语言中自动检测最接近的语言。需要说明这可能会导致重新路由和重定向。 控制器抛出的任何异常都会由网站代码进行处理，这会将默认的错误码变成更友好的错误页面向访客展示。 带有当前网站浏览记录的request.website变量，可在请求中进行使用。 auth=public路由的 public用户将是由后台网站配置中选择的用户。这可能会和本地区、时区等相关。 如果在网页控制器中无需使用上述功能，则可省略website=True参数。但大多数网站QWeb模板需要使用website=True开启一些数据，比如底部公司信息，所以最好还是添加上。\nℹ️传入QWeb运行上下文语言的网站数据由website/model/ir_ui_view.py文件中的_prepare_qcontext方法设定。\n要在模板中添加网站的基本布局，应为QWeb/HTML包裹一个t-call=\u0026ldquo;website.layout\u0026quot;指令，如下所示：\n\u0026lt;template id=\u0026#34;helloworld\u0026#34; name=\u0026#34;Hello World Template\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;website.layout\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; t-call运行QWeb模板website.layout并向其传递 XML 内的tcall 节点。website.layout设计用于渲染带有菜单、头部和底部的完整网页，交将传入的内容放在对应的主区域内。这样，我们的Hello World!示例内容就会显示在 Odoo 网站页面中了。\n添加 CSS 和 JavaScript 资源 我们的网站页面可能需要一些其它的 CSS 或JavaScript资源。这方面的网页由website 管理，因此需要一个方式来告诉它使用这些文件。我们将使用 CSS 来添加一个简单的删除线效果，创建library_website/static/src/css/library.css文件并添加如下内容：\n.text-strikeout { text-decoration: line-through; } 接下来需要在网站页面中包含该文件。通过在website.assets_frontend模板中添加来实现，该模板用于加载网站相关的资源。添加library_website/views/website_assets.xml数据文件来继承该模板：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;template id=\u0026#34;assets_frontend\u0026#34; name=\u0026#34;library_website_assets\u0026#34; inherit_id=\u0026#34;website.assets_frontend\u0026#34;\u0026gt; \u0026lt;xpath expr=\u0026#34;.\u0026#34; position=\u0026#34;inside\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;/library_website/static/src/css/library.css\u0026#34; /\u0026gt; \u0026lt;/xpath\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; 很快我们就会使用text-strikeout这个新的样式类。当然，可以使用相似的方法来添加JavaScript资源。\n借阅列表控制器 既然我们已经过了一遍基础知识，就来一起实现借阅列表吧。我们需要使用/checkout URL来显示借阅列表的网页。为此我们需要一个控制器方法来准备要展示的数据，以及一个QWeb模板来向用户进行展示。\n在模块中添加library_website/controllers/main.py文件，代码如下：\nfrom odoo import http from odoo.http import request class Main(http.Controller): @http.route(\u0026#39;/checkouts\u0026#39;, auth=\u0026#39;user\u0026#39;, website=True) def checkouts(self, **kwargs): Checkout = request.env[\u0026#39;library.checkout\u0026#39;] checkouts = Checkout.search([]) return request.render( \u0026#39;library_website.index\u0026#39;, {\u0026#39;docs\u0026#39;: checkouts}) 控制器获取要使用的数据并传给渲染的模板。本例中控制器需要一个登录了的会话，因为路由中有一个auth=\u0026lsquo;user\u0026rsquo;属性。这是默认行为，推荐明确指出需要用户会话。登录了的用户存储在环境对象中，通过 request.env来使用。search()语句使用它来过滤出相应的借阅记录。\n对于无需登录即可访问的控制器，所能读取的数据也是非常有限的。这种情况下，我们经常需要对部分代码采用提权上下文运行。这时我们可使用sudo()模型方法，它将权限上下文权限修改为内部超级用户，突破大部分限制。权力越大，责任越大，我们要小心这种操作带来的安全风险。需要特别注意在提权时输入的参数以及执行的操作的有效性。建议将sudo() 记录集操作控制在最小范围内。\n回到我们的代码，它以request.render()方法收尾。和之前一样，我们传入了QWeb模板渲染的标识符，和模板运行用到的上下文字典。本例中我们向模板传入 docs 变量，该变量包含要渲染借阅记录的记录集。\n借阅 QWeb 模板 QWeb模板使用数据文件来添加，我们可以使用library_website/views/checkout_template.xml文件并添加如下代码：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;template id=\u0026#34;index\u0026#34; name=\u0026#34;Checkout List\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;website.layout\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;wrap\u0026#34; class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;Checkouts\u0026lt;/h1\u0026gt; \u0026lt;!-- List of Checkouts --\u0026gt; \u0026lt;t t-foreach=\u0026#34;docs\u0026#34; t-as=\u0026#34;doc\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; disabled=\u0026#34;True\u0026#34; t-att-checked=\u0026#34;\u0026#39;checked\u0026#39; if doc.stage_id.fold else None\u0026#34; /\u0026gt; \u0026lt;a t-attf-href=\u0026#34;/checkout/{{slug(doc)}}\u0026#34;\u0026gt; \u0026lt;h3 t-field=\u0026#34;doc.request_date\u0026#34; t-att-class=\u0026#34;\u0026#39;text-strikeout\u0026#39; if doc.stage_id.fold else \u0026#39;\u0026#39;\u0026#34; /\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/odoo\u0026gt; 以上代码使用t-foreach指令来迭代 docs 记录集。我们使用了复选框 input 并在借阅完成时保持为已选状态。在 HTML 中，复选框是否被勾选取决于是否有 checked 属性。为此我们使用了t-att-NAME指定来根据表达式动态渲染 checked 属性。当表达式运行结果为 None（或任意其它 false 值）时，QWeb会忽略该属性，本例用它就非常方便了。\n在渲染任务名时，t-attf指令用于动态创建打开每个指定任务的明细表单的URL。我们使用一个特殊函数slug()来为每条记录生成易于阅读的 URL。该链接目前尚无法使用，因为我们还没有创建对应的控制器。\n在每条借阅记录上，我们还使用了t-att 指令来在借阅为最终状态时应用text-strikeout样式。\n借阅明细页面 借阅列表中的每一项都有一个相应明细页面的链接。我们就为这些链接实现一个控制器，以及实现一个QWeb模板来用于展示。说到这里应该已经很明朗了。\n在library_website/controllers/main.py文件中添加如下方法：\nclass Main(http.Controller): ... @http.route(\u0026#39;/checkout/\u0026lt;model(\u0026#34;library.checkout\u0026#34;):doc\u0026gt;\u0026#39;, auth=\u0026#39;user\u0026#39;, # 默认值，但此处明确指定 website=True) def checkout(self, doc, **kwargs): return http.request.render( \u0026#39;library_website.checkout\u0026#39;, {\u0026#39;doc\u0026#39;: doc}) 注意这里路由使用了带有model(\u0026ldquo;library.checkout\u0026rdquo;)转换器的占位符，会映射到方法的 doc 变量中。它从 URL 中捕获借阅标识符，可以是简单的 ID 数值或链接别名，然后转换成相应的浏览记录对象。\n对于QWeb模板，应在library_website/views/checkout_template.xml数据文件中添加如下代码：\n\u0026lt;template id=\u0026#34;checkout\u0026#34; name=\u0026#34;Checkout Form\u0026#34;\u0026gt; \u0026lt;t t-call=\u0026#34;website.layout\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;wrap\u0026#34; class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 t-field=\u0026#34;doc.request_date\u0026#34; /\u0026gt; \u0026lt;h5\u0026gt;Member: \u0026lt;span t-field=\u0026#34;doc.member_id\u0026#34; /\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;h5\u0026gt;Stage: \u0026lt;span t-field=\u0026#34;doc.stage_id\u0026#34; /\u0026gt;\u0026lt;/h5\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/t\u0026gt; \u0026lt;/template\u0026gt; 这里值得一提的是使用了元素。和在后台中一样，它处理字段值的相应展示。比如，它正确地展示日期值和many-to-one值。\n补充：controllers/init.py和__mainfest__.py 中请自行添加控制器文件和数据文件的引用\n总结 读者现在应该对网站功能的基础有了不错的掌握。我们学习了如何使用网页控制器和QWeb模板来动态渲染网页。然后学习了如何使用website插件并使用它来创建我们自己页面。最后，我们介绍了网站表单插件来帮助我们来创建网页表单。这些都是创建网站功能的核心能技巧。\n我们已经学习了Odoo 主要构件的开发，是时候学习如何将Odoo 服务部署到生产环境了。\n☞☞☞第十四章 Odoo 12开发之部署和维护生产实例\n扩展阅读 Odoo 官方文档中有一些对本文讲解课题的补充参考材料：\n网页控制器 QWeb语言 JavaScript API指南 Bootstrap样式文档 还可以在Packt上找到更多的 Bootstrap学习资源 "
},
{
	"uri": "/odoo/14/",
	"title": "第十四章 Odoo 12开发之部署和维护生产实例",
	"tags": [],
	"description": "",
	"content": "本文为最好用的免费ERP系统Odoo 12开发手册系列文章第十四篇暨完结篇。\n本文中将学习将 Odoo 服务器作为生产环境的基本准备。安装和维护服务器是一个复杂的话题，应该由专业人员完成。本文中所学习的不足以保证普通用户创建应对包含敏感数据和服务的健壮、安全环境。\n本文旨在介绍 Odoo 部署的重要配置和最佳实践，这样系统管理员可以更好地准备 Odoo 服务器主机。通过本文的学习，我们将能创建一个相对安全的 Odoo 服务器，足够应对普通的生产环境使用。本文所述并非部署 Odoo 的唯一方法，其它的方法也会同样适用。\n本文主要内容有：\n通过源码安装 Odoo，主要包含： 安装依赖 准备一个独立的系统用户 通过源码安装 设置配置文件 多进程 设置 Odoo 为系统服务，主要包含： 创建 systemd 服务 创建自启动或 sysvinit 服务 通过命令行查看 Odoo 服务 设置 Nginx 反向代理 配置HTTPS安全服务, 主要包含 : 创建自签名SSL证书 在 Nginx 上配置 HTTPS访问 缓存静态内容 服务器和模块更新，主要包含： 创建模拟环境 更新 Odoo 源码 开发准备 本章无需使用前面开发的代码，相关代码和脚本请见 GitHub 仓库。\n通过源码安装 Odoo Odoo 有 Debian 或 Ubuntu的安装包，使用它可以实现工作服务进程以及在系统启动时自动开启服务。安装过程按步骤即可，在https://nightly.odoo.com/上可以找到相关信息。上面还有CentOS的rpm文件以及 Windows 的.exe 安装包。\n虽然这样安装 Odoo 很容易也很方便，大多数人倾向于部署和运行版本控制的源码来进行集成。这样能更好地控制部署内容，并且在生产环境中也更易于管理代码的变更和修复。\n安装依赖 使用Debian发行版时，默认登录用户为带有管理员权限的 root，这时命令行显示的为#。在Ubuntu系统中，禁用了 root 账号，在安装时配置的初始用户可通过 sudo 来运行 root 权限的命令。首先我们应更新包索引，然后执行升级来确保所有安装的程序是最新的，命令如下：\nsudo apt update sudo apt upgrade -y 下一步，我们将安装PostgreSQL数据库，并让当前用户成为数据库超级用户，命令如下：\nsudo apt install postgresql -y sudo su -c \u0026#34;createuser -s $USER\u0026#34; postgres 我们将通过源码运行 Odoo，但在那之前，我们需要安装所需依赖。以下是所需的Debian包：\nsudo apt-get install git python3-dev python3-pip -y sudo apt install build-essential libxslt-dev libzip-dev libldap2-dev libsasl2-dev libssl-dev -y 还应记得安装打印报表所需的wkhtmltox，命令如下：\nwget \u0026#34;https://github.com/wkhtmltopdf/wkhtmltopdf/releases/download/0.12.5/wkhtmltox_0.12.5-1.xenial_amd64.deb\u0026#34; -O /tmp/wkhtml.deb sudo dpkg -i /tmp/wkhtml.deb sudo apt-get -fy install # 处理依赖错误 注意安装包时可能报依赖错误，像这里最一条命令会强制这些依赖的安装并正确完成安装。\n# 错误信息 ... dpkg: error processing package wkhtmltox (--install): dependency problems - leaving unconfigured Errors were encountered while processing: wkhtmltox 现在我们就只缺少 Odoo 所需要的 Python 包了，它们大多数都有Debian或Ubuntu系统包。官方Debian安装包使用到这些，可在Odoo 源码debian/control文件中找到这些包名。但是这些 Python 依赖也可以通过PyPI（Python Package Index）直接安装。所要求的包和通常基于 Python 的项目一样在 Odoo 的requirements.txt文件中。我们可以使用如下命令安装这些包：\nwget https://raw.githubusercontent.com/odoo/odoo/12.0/requirements.txt sudo -H pip3 install -r requirements.txt 在Ubuntu 18.04中，最后一条命令可能会打印了红色的警告，内容是PyYAML 和pySerial的卸载，这在系统中通过包安装了老版本时会发生。这种警告可以安全的略过。\n既然我们有了所有的依赖，安装了数据库服务、系统包和 Python 包，我们就可以安装 Odoo 了。\n准备独立的系统用户 从安全角度建议使用独立的用户运行 Odoo，这一用户不带有任何系统的特权。为此我们需要创建系统和数据库用户，使用命令如下：\nsudo adduser --disabled-password --gecos \u0026#34;Odoo\u0026#34; odoo sudo su -c \u0026#34;createuser odoo\u0026#34; postgres createdb --owner=odoo odoo-prod 以上odoo 为用户名，odoo-prod用于运行 Odoo 实例的数据库名。odoo用户成为了odoo-prod数据库的所有者。也就说它对该数据库有创建和删除的权限，包括删除整个数据库的权限。如果你运行的是多租户服务器，应为每个租户创建一个类似 odoo 的指定系统用户。\n**小贴士：**Odoo的设计即使在系统用户不是数据库所有者时也可以正确运行。但这可能会让设置变复杂，并且固化安全的好习惯是有一个主系统用户作为数据库的所有者、为每个实例创建一个指定的不带有超级用户权限的系统用户来运行服务。\n注意这些是没有管理权限的普通用户，新建系统用户时会自动创建一个家目录。比如/home/odoo，用户可通过~快捷符号来表示自己的家目录。我们在用户 Odoo 对应的配置和文件中会使用到它。我们可以使用如下命令来以该用户打开一个会话：\nsudo su odoo exit exit命令终止会话并回到原用户。\n源码安装 要不了多久，你的服务就会需要升级、打补丁。这时版本控制仓库会很有帮助。我们使用 git来从仓库中获取代码，就像我们在安装开发环境时的操作一样。下面我将使用 odoo 用户并将代码下载家目录中：\nsudo su odoo git clone https://github.com/odoo/odoo.git /home/odoo/odoo-12 -b 12.0 --depth=1 -b 选项确保获取的是正确的分支，\u0026ndash;depth=1选项会忽略修改历史并仅获取最新修订的代码，这样下载内容更精简，速度也更快。\n**小贴士：**git在管理 Odoo 部署版本时是一个非常有价值的工具。注意本系列文章中仅仅涉及到代码版本管理的冰山一角。想要更加熟悉 git，值得花时间进一步学习，可从http://git-scm.com/doc开始。\n到此为止，我们应该已经拥有源码安装 Odoo 的所有内容。可通过如下命令以指定用户会话检查是否正确启动并退出：\n$ /home/odoo/odoo-12/odoo-bin --version Odoo Server 12.0 $ exit 下面我们将设置一些在系统中使用的系统级别的文件和目录。\n设置配置文件 在启动 Odoo 服务时添加\u0026ndash;save参数会将配置保存到~/.odoorc文件中。我们将以这个文件作为服务配置的初始文件，将其保存到/etc/odoo下，使用命令如下：\nsudo su -c \u0026#34;~/odoo-12/odoo-bin -d odoo-prod --db-filter=\u0026#39;^odoo-prod$\u0026#39; --without-demo=all -i base --save --stop-after-init\u0026#34; odoo 这行命令中也会包含服务实例所使用的配置参数。\n**小贴士：**老版本中的.openerp_serverrc配置文件还被支持，找到后会进行使用。如果安装 Odoo 10或之后版本的服务器上同时还安装了老版本的 Odoo，可能会引起混淆。这时你会发现\u0026ndash;save选项没有更新.odoorc，而是更新了.openerp_serverrc文件。\n下一步我们需要将配置文件放到系统的配置文件目录/etc 下，命令如下：\nsudo mkdir /etc/odoo sudo cp /home/odoo/.odoorc /etc/odoo/odoo.conf sudo chown -R odoo /etc/odoo sudo chmod u=r,g=rw,o=r /etc/odoo/odoo.conf # 安全加固使用 以上命令最后一行是可选的，但它提升了系统的安全性。它确保运行 Odoo 进程的用户可以读取但无法修改配置文件。这时你将无法修改数据库主密码，但在生产服务下这不是什么问题，因为应使用list_db=False服务配置来禁用网页数据库管理员。我们还需为 Odoo 服务创建一个存储日志文件的目录。这通常放在/var/log目录下，命令如下：\nsudo mkdir /var/log/odoo sudo chown odoo /var/log/odoo 现在让我们通过如下命令编辑配置文件并确保已配置了一些重要参数：\nsudo nano /etc/odoo/odoo.conf 以下是大部分重要参数的推荐值：\n[options] addons_path = /home/odoo/odoo-12/odoo/addons,/home/odoo/odoo-12/addons admin_passwd = False db_name = odoo-prod dbfilter = ^odoo-prod$ http_port = 8069 list_db = False logfile = /var/log/odoo/odoo-server.log proxy_mode = True without_demo = all workers = 6 下面逐一讲解：\naddons_path是一组逗号分隔的用于查找插件模块的路径。读取顺序为从左到右，最左边目录的优先级最高。 admin_passwd是访问网页客户端数据库管理功能的主密码。一定要设置复杂的密码，或者最好是设为 False来关闭这一功能。 db_name是在服务启动时初始化的数据库实例。 dbfilter用于过滤可访问的数据库，它是一个 Python 解释的正则表达式。为使用户无需弹出窗口选择数据库，并使未经身份验证的 URL 可正常运作，应设置为^dbname$，比如dbfilter=^odoo-prod$。它支持%h和%d占位符，由 HTTP 请求主机名和子域名进行替换。 http_port是服务器监听的端口号，默认使用的是8069 list_db = False在 RPC级别和 UI 上屏蔽数据库列表，并屏蔽数据库管理界面以及相应的 RPC 功能。 logfile是服务日志写入的位置。对于系统服务，一般位于/var/log文件夹内。如果留空，日志会转而在标准输出中打印。 proxy_mode在需要反向代理访问时应设为True，我们需要用到反向代理。 without_demo在生产环境中应进行设置，这样新建的数据库中不会带有演示数据。 workers的值在大于等于2时启用多进程，一会儿我们会进一步的讨论。 ℹ️Odoo 10中引入http_port参数来替代老版本中使用但现在已淘汰了的xmlrpc_port参数。\n从安全角度看，admin_passwd=False和list_db=False选项尤为重要。它们屏蔽掉对数据库管理功能的网页端访问，在生产环境和面向外网的 Odoo 服务中都应进行设置。\n以下也是会用到的参数：\ndata_dir是会话数据和附件存储的路径，记住将备份放在这里 http_interface设置监听的地址。默认监听0.0.0.0，但在使用反向代理时应设置为127.0.0.1来仅响应本地请求。Odoo 11中引入它来代替淘汰了的xmlrpc_interface参数。 我们可通过-c或\u0026ndash;config选项来检查运行服务的设置：\nsudo su -c \u0026#34;~/odoo-12/odoo-bin -c /etc/odoo/odoo.conf\u0026#34; odoo 通过上述设置运行 Odoo 不会在终端中有任何输出，因为修改都写到了配置文件中定义的日志文件中了。要追踪服务的操作，我们需要在终端中运行如下命令：\nsudo tail -f /var/log/odoo/odoo-server.log 有时可能会需要将日志输出到标准输出中，最好的方法是复制一份不带logfile选项的配置文件。\n**小贴士：**要在同一个终端窗口中运行多个终端会话，可以使用tmux这样的应用或者GNU Screen。可以使用Byobu，它基于GNU Screen或Tmux提供了好看的用户界面。\n多进程工作进程 生产实例可能会处理大量的工作负载。默认服务运行单进程并只能使用CPU 的一个核心来处理请求，这是因为Python语言的全局解释器锁（GIL）。但是可使用多进程模式来处理并发请求，来充分利用多核的优势。workers=N选项设置使用的工作进程数，作为一个参照，可设置为1+2*P，其中 P为处理器的核数。最佳设置需要根据具体情况进行调优，因为这取决于服务器的负载以及多少其它像PostgreSQL这样大负载服务在运行。\n为负载将workers设置高比低好，最低值应为6，因为这是大多数浏览器的并行连接数，最大值通常受服务器的 RAM 所限。普通使用模式的经验是，Odoo服务应能处理(1+2*P)*6个并发用户。\n还有一些limit-配置参数可用于调优工作进程。在达到这些值时工作进程会被回收，相应的进程会停止并启动一个新进程。这可以防止服务器内存溢出以及防止某一进程过度使用服务器资源。\n官方文档中对工作进程参数调优也给出了一些很好的建议，欲知详情，请参照官方文档Odoo 部署。\n设置 Odoo 为系统服务 现在我们需要将 Odoo 设为系统服务，并在系统启动时自动开启。\n在Ubuntu或Debian中，init程序负责服务的启动。Debian或其分支操作系统曾使用过sysvinit，Ubuntu曾使用过兼容的名为Upstart的启动程序。但最近都进行了修改，最新的Debian和Ubuntu发行版的init程序都使用了systemd。这表示现在有两种方式来安装系统服务，你需要根据操作系统的版本来选择正确的方法。Ubuntu 16.04或之后的版本中应使用systemd，但是很多云服务商还在使用更早的版本，所以很有可能你也会使用到这些老版本。要检查系统中是否使用systemd，可使用如下命令：\nman init 这条命令会打印当前使用的 init 程序的文档，然后就可以查看所使用的启动服务。\nℹ️Window的子系统(WSL) 中的 Ubuntu环境仅适用于开发，它有可能发生些异常问题，完全不适合用于运行生产环境。在写本文时，man init显示启动服务为systemd，但并不能安装systemd服务，反而安装sysvinit服务时是正常的。\n补充：如出现-bash: man: command not found，则通过sudo apt install man -y来执行安装\n创建systemd服务 如果你使用的是较近的操作系统，如Debian 8或Ubuntu 16.04，你的启动服务就应该是systemd。要在系统中添加服务，只需创建一个描述服务的文件。我们创建/lib/systemd/system/odoo.service文件并加入如下内容：\n[Unit] Description=Odoo After=postgresql.service [Service] Type=simple User=odoo Group=odoo ExecStart=/home/odoo/odoo-12/odoo-bin -c /etc/odoo/odoo.conf [Install] WantedBy=multi-user.target **小贴士：**Odoo源码中在debian/下包含一个odoo.service文件示例。你可以不用新建方件，直接把拷贝该文件然后进行所需修改。至少需要根据设置来修改ExecStart选项。\n下一步我们需要使用如下命令来注册这个新服务：\nsudo systemctl enable odoo.service 使用如下命令启动该服务：\nsudo systemctl start odoo 使用如下命令检查该服务状态：\nsudo systemctl status odoo 最后，如需停止服务，请使用如下命令：\nsudo systemctl stop odoo 创建Upstart或sysvinit 服务 如果你使用更老的操作系统，如Debian 7或Ubuntu 15.04，那么很有可能需要使用sysvinit或Upstart启动服务。就创建系统服务而言，两者的作用一致。一些虚拟专用服务器(VPS)服务还在使用老的Ubuntu镜像，所以在碰到这种情况时可以通过以下方式部署Odoo服务。\nOdoo源码中有一个init脚本用于Debian发行包，我们仅需做一些小修改来使用它创建启动服务：\nsudo cp /home/odoo/odoo-12/debian/init /etc/init.d/odoo sudo chmod +x /etc/init.d/odoo 现在你可能需要查看一下init脚本的内容，主要的参数都在文件上方定义的变量中，如下例所示：\nPATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin DAEMON=/usr/bin/odoo NAME=odoo DESC=odoo CONFIG=/etc/odoo/odoo.conf LOGFILE=/var/log/odoo/odoo-server.log PIDFILE=/var/run/${NAME}.pid USER=odoo 这些变量应该足够使用了，接下来我们将使用它们的默认值进行设置，但你可以根据自己的需要进行修改。变量USER是运行服务的系统用户，我们前面已经创建了一个odoo用户。变量DAEMON是可执行服务的路径，我们启动 Odoo 的文件在不同的路径下，但可创建以下软链接：\nsudo ln -s /home/odoo/odoo-12/odoo-bin /usr/bin/odoo sudo chown -h odoo /usr/bin/odoo 变量CONFIG是我们需要使用的配置文件。在前面一节中，我们在默认配置的路径/etc/odoo/odoo.conf下创建了配置文件。最后变量LOGFILE是存储日志文件的路径。配置的路径/var/log/odoo我们在定义配置文件时进行了创建。\n现在我们应该可以像下面这样来启动和关闭 Odoo 服务了：\n$ sudo /etc/init.d/odoo start Starting odoo: ok 关闭服务方法相似，命令如下：\n$ sudo /etc/init.d/odoo stop Stopping odoo: ok Ubuntu中可使用 service 命令：\nsudo service odoo start sudo service odoo status sudo service odoo stop 现在我们需要在系统启动时自动开启服务，通过如下命令实现：\nsudo update-rc.d odoo defaults 这时，重启服务器 Odoo 服务就会正常地自动启动了。是时候测试下一切是否都如预期一样了。\n使用命令行检查 Odoo 服务 现在我们可以确定Odoo实例是否运行以及是否能正常对请求进行响应。如果Odoo正常运行，我们应该可以得到响应并且日志文件中不会报错。在服务器上通过如下命令可检测 Odoo 是否对HTTP请求进行响应：\ncurl http://localhost:8069 \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;script\u0026gt;window.location = \u0026#39;/web\u0026#39; + location.hash;\u0026lt;/script\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;/html\u0026gt; 此外通过如下命令可查看日志文件的内容：\nsudo less /var/log/odoo/odoo-server.log 你还可以使用tail -f 来实时查看日志文件中新增的内容：\nsudo tail -f /var/log/odoo/odoo-server.log 设置 Nginx 反向代理 虽然 Odoo 自身可以输出网页，但强烈建议在其上加一层反向代理。反向代理作为一个中间层来管理客户端所发送请求以及 Odoo 服务作出响应之间的数据流。使用反向代理有诸多好处。\n从安全角度考虑，有以下几点：\n处理并加固HTTPS协议来对数据流加密 隐藏内部网络特征 作为应用防火墙，限制所接受处理的 URL 然后从性能角度考虑，反向代理可提供如下显著的改进：\n缓存静态内容，因而降低 Odoo 服务器的负载 压缩内容来加快加载时间 作为负载均衡器，在多台服务间分配负载 Apache是在考虑反向代理时的一个常用选择，Nginx 是近期在技术圈被热议的对其的替代。此处我们使用Nginx作为反向代理，并展示如何使用它来实现上述讨论的安全和性能方面的功能。\n首先，我们应当安装Nginx，我们需要它监听默认的HTTP端口，所以需要确保没有被其它服务所占用。执行如下命令应该会报错：\n$ curl http://localhost curl: (7) Failed to connect to localhost port 80: Connection refused 如果没有收到错误，应当禁用相应服务来让Nginx使用该端口。例如，关闭已有的Apache服务，使用sudo service apache2 stop。更好的选择是从服务器上删除该服务或重新配置让其监听其它端口，这样Nginx就可以正常使用HTTP和HTTPS端口(80 and 443) 了。\n一旦完成上述操作，就可以安装Nginx了：\nsudo apt-get install nginx -y sudo service nginx start # 如尚未启动，启动Nginx服务 要确定Nginx是否正确运行，通过浏览器访问或在服务上执行curl http://localhost应该可以得到一个Welcome to nginx页面。\nNginx配置文件和Apache的方式基本相同，存储在/etc/nginx/available-sites/中，并可通过在/etc/nginx/enabled-sites/中添加软链接来激活。注意应同时关闭Nginx安装时默认带有的配置：\nsudo rm /etc/nginx/sites-enabled/default sudo touch /etc/nginx/sites-available/odoo sudo ln -s /etc/nginx/sites-available/odoo /etc/nginx/sites-enabled/odoo 使用nano或vi等编辑器来编辑 Nginx配置文件：\nsudo nano /etc/nginx/sites-available/odoo 一个基本的针对Odoo服务的Nginx配置文件如下例所示：\nupstream odoo { server 127.0.0.1:8069; } upstream odoochat { server 127.0.0.1:8072; } server { listen 80; # Add Headers for odoo proxy mode proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; # log access_log /var/log/nginx/odoo.access.log; error_log /var/log/nginx/odoo.error.log; # Redirect longpoll requests to odoo longpolling port location /longpolling { proxy_pass http://odoochat; } # Redirect requests to odoo backend server location / { proxy_redirect off; proxy_pass http://odoo; } # common gzip gzip_types text/css text/scss text/plain text/xml application/xml application/json application/javascript; gzip on; } 补充：添加域名请在server 配置区内添加对 server_name 的配置\n首先为Odoo服务添加了upstream配置，监听了默认端口8069和8072。8069用于网页客户端和RPC请求，8072用于多进程时 Odoo 实时消息所需的长轮询(long polling)请求。\nNginx应在默认HTTP端口80上接收访问流量，然后重定向到upstream odoo服务中。这在server配置区中进行了定义。/longpolling 地址的访问流量会传递到upstream odoochat，剩余的流量则传递到upstream odoo。这里我们还添加了一些请求头的信息，这样 Odoo 后台服务就会知道这些是经过代理的流量。\n出于安全考虑，应确保proxy_mode参数设为True。这是因为在Nginx作为代理时，所有的请求都会认为是来自本地而不是远程 IP 地址。在代理中设置X-ForwardedFor头以及启动\u0026ndash;proxy-mode可解决这一问题。但是，如果不在代理级别强制header就启用\u0026ndash;proxy-mode 会让其他人可以伪装远程地址。\n在配置文件的最后，可以看到两条gzip相关的命令，它们用于对一些文件进行压缩，提升性能。可通过如下命令测试配置是否正确：\n$ sudo nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful 如果出现错误，请检查配置文件中输入是否正确。常见的问题是默认的HTTP被其它服务所占用，如Apache或默认的Nginx网站，所以在重启Nginx服务前先通过本文中的命令确保并没有这种问题。在完成处理后，可使用如下命令重新加载新的配置：\nsudo /etc/init.d/nginx reload 如果操作系统使用的是systemd，上述命令正确的版本应该是：\nsudo systemctl reload nginx 通过如下命令可确认 Nginx 是否将访问流量重定向到了后台Odoo服务中：\n$ curl http://localhost \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;script\u0026gt;window.location = \u0026#39;/web\u0026#39; + location.hash;\u0026lt;/script\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;/html\u0026gt; 配置HTTPS安全服务 网站数据不应在因特网中以普通文件进行传输，在将Odoo网页服务暴露在网络中时，我们应使用HTTPS协议来对数据进行加密。有时可使用自签署证书。但注意自签署证书可能会带来安全风险，比如中间人攻击(Man-in-the-Middle Attack)，因此有些浏览器会不接受该证书。\n更健壮的解决方案是使用认证的证书机构所签署的证书，在运行商业或电商网站时这就尤为重要了。\n小贴士：Let\u0026rsquo;s Encrypt服务提供免费的证书。Odoo 有现存插件模块处理对Odoo服务SSL证书的自动请求，但在写本文时，还未移植到Odoo 12中，可访问 GitHub 进一步了解。\n创建自签署 SSL 证书 下一步，我们应安装证书来启用SSL。创建一个自签署证书，可使用如下命令：\n$ sudo mkdir /etc/ssl/nginx \u0026amp;\u0026amp; cd /etc/ssl/nginx $ sudo openssl req -x509 -newkey rsa:2048 -keyout server.key -out server.crt -days 365 -nodes $ sudo chmod a-wx * # make files read only $ sudo chown www-data:root * # access only to www-data group 上述命令创建一个/etc/ssl/nginx目录以及不带密码的自签署SSL证书。在运行openssl命令时，会要求用户输入其它信息，然后会生成一个证书和密钥文件。最后，将这些文件的所有权赋予用于运行网页服务的www-data用户。\n在 Nginx上配置HTTPS访问 既然我们已经有了SSL证书，就可以配置 Nginx 来使用它了。要强制使用HTTPS，需要将所有的 HTTP 访问重定向到HTTPS。将前面的server区中替换为如下内容：\nserver { listen 80; rewrite ^(.*) https://$host$1 permanent; } 现在，如果重新加载Nginx配置并在浏览器中访问服务的话，将会看到http://地址被转换成了https:// 地址。但该地址不会返回任何内容，我们需要正确地配置HTTPS服务，可通过添加如下服务器配置来实现：\nserver { listen 443; # Add Headers for odoo proxy mode proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Real-IP $remote_addr; # SSL parameters ssl on; ssl_certificate /etc/ssl/nginx/server.crt; ssl_certificate_key /etc/ssl/nginx/server.key; ssl_session_timeout 30m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers \u0026#39;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCMSHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSAAES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128- SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128- SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256- SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHEDSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256- SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128- SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3- SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3- SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA\u0026#39;; ssl_prefer_server_ciphers on; # log access_log /var/log/nginx/odoo.access.log; error_log /var/log/nginx/odoo.error.log; # Redirect longpoll requests to odoo longpolling port location /longpolling { proxy_pass http://odoochat; } # Redirect requests to odoo backend server location / { proxy_redirect off; proxy_pass http://odoo; } # common gzip gzip_types text/css text/scss text/plain text/xml application/xml application/json application/javascript; gzip on; } 以上配置代码会监听HTTPS端口并使用/etc/ssl/nginx/ 证书文件来对数据进行加密。这与我们在设置 Nginx 反向代理 中看到的server 配置区相似。如果重新加载配置，我们的 Odoo 服务将通过HTTPS进行运作，如以下命令所示：\n$ sudo nginx -t nginx: the configuration file /etc/nginx/nginx.conf syntax is ok nginx: configuration file /etc/nginx/nginx.conf test is successful $ sudo service nginx reload # or: sudo systemctl reload nginx * Reloading nginx configuration nginx ...done. $ curl -k https://localhost \u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;script\u0026gt;window.location = \u0026#39;/web\u0026#39; + location.hash;\u0026lt;/script\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;/html\u0026gt; 最后部分的输入可用于确认Odoo客户端正通过HTTPS进行访问。\n**小贴士：**在更早的Odoo镜像中，PosBox仅在HTTP模式下生效，这就需要在 Nginx 中添加对/pos/ 链接的例外处理。Odoo 10及之后的镜像中包含了自签署证书来让PosBOx和IoT Box可通过HTTPS进行通讯，这一修改在 GitHub 中引入。\n缓存静态内容 我们可以配置 Nginx 来缓存服务端静态文件，这样再次请求时就可以访问Nginx 中的缓存，而无需将请求传递到upstream odoo服务中。启用静态内容缓存可带来更快的响应时间并减少 Odoo 服务的工作负载。要启用这一设置，在location /longpolling区之前加入如下代码：\n# cache static data location ~* /web/static/ { proxy_cache_valid 200 60m; proxy_buffering on; expires 864000; proxy_pass http://odoo; } 通过这一些命令，静态数据就可以缓存60分钟了。在这个期间的其它请求Nginx 会直接使用缓存进行响应。\n服务和模块更新 一旦 Odoo 服务运行了一段时间，就会需要对其进行升级。这包括两个步骤：获取服务或模块的新版本、执行安装。\n创建分阶环境 如果你按照通过源码安装 Odoo一节正确地进行了安装，应该就可以在暂存区仓库中获取并测试新版本源码。强烈建议创建一个生产环境数据库的拷贝，并使用它进行升级测试。如果odoo-prod是我们的生产环境数据库，可通过如下命令创建一个拷贝odoo-stage：\ndropdb odoo-stage createdb --owner=odoo odoo-stage pg_dump odoo-prod | psql -d odoo-stage sudo su odoo cd ~/.local/share/Odoo/filestore/ cp -al odoo-prod odoo-stage # create filestore hardlinks exit 在使用以上数据库拷贝之前，应进行清理，比如停止计划动作、关闭 email 服务（包含发送和接收消息）。根据你的设置来执行这些指定步骤，但通常可使用自动化脚本来执行。记住psql可用于在命令行直接执行SQL命令，如psql -d odoo-stage -c \u0026ldquo;\u0026lt;SQL命令\u0026gt;\u0026quot;。\n**小贴士：**可通过createdb命令来更快地创建拷贝：createdb \u0026ndash;owner=odoo \u0026ndash;template=odoo-prod odoo-stage。但需要说明的是要运行该命令，不能有任何对odoo-prod数据库的连接，因此需要停止Odoo生产环境的服务。\n更新 Odoo 源码 我们使用git pull 命令来从GitHub仓库获取最新的Odoo源码。在那之前，我们可以使用git tag命令来为当前使用的提交创建一个标签，这样可以可容易的对更新进行撤销，命令如下：\nsudo su odoo cd ~/odoo-12 git tag --force 12-last-prod git pull 要让代码修改生效，我们需要重启Odoo服务。而要使用数据文件的修改生效，需要对模块进行升级。通常对Odoo稳定版本的修改都是代码的修复，因此无需冒险执行模块升级。如果需要对模块升级，可使用-u 附加参数，或者是-u base，它将升级所有模块。\n现在可以启动Odoo的分阶服务了，它将使用在分阶数据库上使用升级代码：\n~/odoo-12/odoo-bin -d odoo-stage --http-port=8080 -c /etc/odoo/odoo.conf # optionally add: -u base exit Odoo 分阶服务通过在8080端口上进行配置。可通过浏览器访问http://xxx:8080来检查升级代码是否正确运作。如果出现了错误，可通过如下命令来返回上一个版本：\nsudo su odoo cd ~/odoo-12 git checkout 12-last-prod exit 如果一切运行都如预期，则可安全地执行生产环境服务的升级，通常是通过重启来实现。如果想要执行实际的模块升级，建议的方法是停止服务、运行升级、再重启服务，命令如下：\nsudo service odoo stop sudo su -c \u0026#34;~/odoo-12/odoo-bin -c /etc/odoo/odoo.conf -u base --stop-after-init\u0026#34; odoo sudo service odoo start 记住对在用Git 版本进行记录，可通过 git checkout回到修改前，这让我们可以在需要的时候进行回滚。强烈推荐在执行数据库升级前保存备份。在完成之后，可使用 Git 拉取新的版本到生产仓库并完成升级：\nsudo su odoo cd ~/odoo-12 git tag --force 12-last-prod git pull exit sudo service odoo restart # or: sudo systemctl restart odoo 无需频繁进行升级，但也不建议等上一年再进行升级。每几个月进行一次升级。还要记得重启服务来启用代码升级，但对模块升级则并非如此。但如果需要进行指定的漏洞修复，可以更早的进行升级。还应关注公开渠道对 Odoo 安全漏洞的披露，发 GitHub 上 Odoo 的Issues，具体可查看Security标签，或者是官方的邮件列表，可通过https://www.odoo.com/groups进行订阅。\n作为一项服务，企业版用户会更早地收到邮件通知来警报这一类问题。\n总结 在本文中，我们学习了在Debian系生产服务器中设置和运行 Odoo 所需的其它步骤。我们一起了解了配置文件中最重要的设置项，并学习了如何擅用多进程模式。为提升安全性和扩展性，我们还学习了如何使用 Nginx 来作为 Odoo 服务处理之上的反向代理。\n本文涵盖了运行 Odoo 服务并向用户提供稳定、安全服务的基础知识。要更多地了解 Odoo，可参考官方文档。其中更深入的讲解了一些课题，并包含了一些本系列文章未涉及的课题。\n还有一些有关 Odoo 的出版图书还助于你的学习。Packt Publishing中有一些相关书籍，具体来说Odoo Development Cookbook包含了本系列文章未讨论到的高级课题。\n最后，Odoo是一个拥有活跃社区的开源产品。参与、提问并回馈社区不仅有助于学习，还有助于建立人脉。说到这，就不能不提 Odoo 社区联盟(OCA)，它倡导协作并提供高质量的开源代码，可访问https://odoo-community.org/做更进一步了解。\n扩展阅读 以下Odoo官方文档的内容可作为本文讨论课程的补充材料，来帮助获取额外的参考：\n部署 Odoo 安装 Odoo "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "odoo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/odoo/",
	"title": "odoo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]